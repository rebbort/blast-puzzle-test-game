{"version":3,"sources":["assets/scripts/core/board/BoardGenerator.ts","assets/scripts/core/board/BoardSolver.ts","assets/scripts/core/board/Board.ts","assets/scripts/core/board/commands/BombCommand.ts","assets/scripts/ui/controllers/BoosterPanelController.ts","assets/scripts/core/boosters/BoosterRegistry.ts","assets/scripts/ui/controllers/BoosterSelectAnimationController.ts","assets/scripts/ui/controllers/BoosterSelectPopup.ts","assets/scripts/ui/services/BoosterSelectionService.ts","assets/scripts/core/boosters/BoosterService.ts","assets/scripts/core/boosters/BoosterSetup.ts","assets/scripts/config/ConfigLoader.ts","assets/scripts/core/EventBus.ts","assets/scripts/core/events/EventNames.ts","assets/scripts/infrastructure/ExtendedEventTarget.ts","assets/scripts/core/fx/FXController.ts","assets/scripts/ui/utils/FallAnimator.ts","assets/scripts/core/board/commands/FallCommand.ts","assets/scripts/core/board/commands/FillCommand.ts","assets/scripts/ui/controllers/FillController.ts","assets/scripts/ui/controllers/GameBoardController.ts","assets/scripts/ui/controllers/GameResultPopupController.ts","assets/scripts/GameScene.ts","assets/scripts/ui/controllers/GameStateController.ts","assets/scripts/core/game/GameStateMachine.ts","assets/scripts/ui/controllers/HudController.ts","assets/scripts/infrastructure/InfrastructureEventBus.ts","assets/scripts/core/board/MoveExecutor.ts","assets/scripts/ui/controllers/MoveFlowController.ts","assets/scripts/ui/controllers/MoveSequenceBadge.ts","assets/scripts/core/diagnostics/MoveSequenceLogger.ts","assets/scripts/ui/utils/PositionUtils.ts","assets/scripts/core/board/commands/RemoveCommand.ts","assets/scripts/core/fx/RocketVfxController.ts","assets/scripts/ui/SafeAreaAdjuster.ts","assets/scripts/core/rules/ScoreStrategyQuadratic.ts","assets/scripts/config/ShockwaveConfig.ts","assets/scripts/core/board/ShuffleService.ts","assets/scripts/core/fx/SoundController.ts","assets/scripts/ui/utils/SpriteHighlight.ts","assets/scripts/core/boosters/SuperTileBooster.ts","assets/scripts/core/boosters/SuperTileFactory.ts","assets/scripts/core/board/commands/SwapCommand.ts","assets/scripts/core/boosters/TeleportBooster.ts","assets/scripts/core/board/TileAppearanceConfig.ts","assets/scripts/ui/controllers/TileInputController.ts","assets/scripts/ui/controllers/TilePressFeedback.ts","assets/scripts/ui/views/TileView.ts","assets/scripts/core/board/Tile.ts","assets/scripts/core/rules/TurnManager.ts","assets/scripts/core/fx/VfxInstance.ts","assets/migration/use_v2.0.x_cc.Toggle_event.js"],"names":["seedrandom","require","Board_1","Tile_1","BoardGenerator","[object Object]","cfg","rng","rngSeed","last","attempt","tiles","y","rows","row","x","cols","color","colors","Math","floor","length","push","TileFactory","createNormal","adjacentSameColor","Board","current","right","bottom","exports","EventBus_1","EventNames_1","BoardSolver","board","this","prototype","expandGroupForSuper","tile","pos","kind","TileKind","SuperRow","console","info","Array","from","_","cc","Vec2","SuperCol","SuperBomb","radius","cells","dx","dy","max","abs","p","inBounds","SuperClear","Normal","Error","expandBySupers","group","_this","resultSet","Set","map","queue","filter","t","tileAt","pop","_i","_a","extra","k","has","add","split","Number","findGroup","start","startTile","result_1","EventBus","emit","EventNames","GroupFound","startColor","colorVisited","colorStack","baseGroup","key","neighbors4","n","nKey","result","hasMoves","found","forEach","other","grid","fill","Object","defineProperty","get","colorAt","setTile","candidates","candidates_1","c","callback","MoveExecutor_1","BoardSolver_1","BombCommand","center","bus","execute","__awaiter","Promise","expanded","MoveExecutor","sent","BoosterSetup_1","BoosterRegistry_1","SpriteHighlight_1","BoosterSelectionService_1","_decorator","ccclass","property","BoosterPanelController","_super","__extends","apply","arguments","boosterList","boosterSlotPrefab","boosterLabel","boosterSlots","setupEventListeners","charges","boosterSelectionService","getConfirmedCharges","createSlots","keys","active","warn","removeAllChildren","entries","_loop_1","i","boosterId","count","node","instantiate","this_1","addChild","setPosition","button","getComponent","Button","counterLabel","_b","getChildByName","Label","def","BoosterRegistry","find","b","id","value","icon","_c","Sprite","resources","load","SpriteFrame","err","spriteFrame","log","slot","highlight","isActive","addHighlightToSlot","setupSlotClickHandler","setBoosterIcon","string","String","state_1","layout","Layout","updateLayout","on","BoosterConsumed","onBoosterConsumed","BoosterCancelled","onBoosterCancelled","BoostersSelected","onBoostersSelected","GameRestart","onGameRestart","addComponent","default","highlightColor","Color","YELLOW","highlightOpacity","off","Node","EventType","TOUCH_END","handleSlotClick","clickedSlot","clearActiveSlot","boosterService","cancel","setActiveSlot","activate","setHighlight","startPulse","activeSlot","s","clearHighlight","stopPulse","stopAllActions","pulse","tween","to","scale","call","getCharges","hideBoosterSlot","onDestroy","__decorate","Prefab","Component","TeleportBooster_1","SuperTileBooster_1","factory","TeleportBooster","getView","SuperTileBooster","BoosterSelectAnimationController","gameNameLabel","selectBoosterLabel","boosterSelectBackground","playButton","labelDelay","backgroundDelay","slotsDelay","playButtonDelay","bounceDuration","scaleDuration","rotationDuration","originalScales","Map","originalRotations","onLoad","storeOriginalTransforms","hideAllElements","checkReferences","playEntranceAnimation","elements","__spreadArrays","element","set","eulerAngles","setScale","opacity","scheduleOnce","animateLabel","animateBackground","animateSlots","animatePlayButton","label","name","easing","index","delay","animateSlot","originalScale","replayAnimation","showAllImmediately","originalRotation","error","type","Float","range","BoosterSelectAnimationController_1","BoosterSelectPopup","boosterSlotGrid","slots","animationController","reset","onEnable","updateHighlights","startGame","highlightedNode","onSlotClick","toggle","selected","getSelected","confirm","showImmediately","ConfigLoader_1","BoosterSelectionService","confirmedCharges","limits","loadBoosterLimits","_instance","idx","indexOf","splice","maxTypes","shift","maxPerType","__assign","instance","BoosterService","getState","boosters","activeId","register","boost","canActivate","BoosterActivated","debug","getListenerCount","consume","BoosterService_1","initBoosterService","viewProvider","views","gameConfigCache","loadGameConfig","DefaultBoard","boosterLimits","DefaultBoosterLimits","clearConfigCache","loadGameConfigAsync","resolve","JsonAsset","asset","config","json","tileWidth","tileHeight","superThreshold","superChances","col","bomb","clear","loadBoardConfig","fromEntries","base","storage","window","localStorage","globalThis","getItem","raw","data","JSON","parse","val","undefined","InfrastructureEventBus_1","InfrastructureEventBus","GameStart","GroupSelected","TilesRemoved","MoveCompleted","FillStarted","FillDone","FallStarted","FallDone","TurnsInit","TurnUsed","TurnEnded","OutOfTurns","GameWon","GameLost","BoosterConfirmed","BoosterTargetSelected","StateChanged","GamePaused","GameResumed","AnimationStarted","AnimationEnded","AutoShuffle","ShuffleLimitExceeded","ShuffleDone","SwapCancelled","SwapDone","RemoveStarted","SuperTileCreated","SuperTilePlaced","SuperTileActivated","TilePressed","InvalidTap","ExtendedEventTarget","once","event","listener","args","EventTarget","VfxInstance_1","FXController","setPrefab","prefab","prefabs","setLayer","layer","waitForVfx","position","duration","durations","r","setTimeout","_d","parent","director","getScene","zIndex","VfxInstance","particleSystems","getComponentsInChildren","ParticleSystem","animations","Animation","finished","play","then","race","isValid","destroy","TileView_1","runFallAnimation","end","onComplete","dist","dur","maybe","tileView","startFall","actions","delayTime","moveTo","callFunc","target","visualRoot","prev","getAnchorPoint","setAnchorPoint","v2","bump","sequence","scaleTo","runAction","endFall","FallCommand","columns","emptySlots","kept","y_1","kept_1","FillCommand","randomColor","random","GameBoardController_1","FallAnimator_1","PositionUtils_1","FillController","tileNodePrefab","tilesLayer","pending","boardCtrl","getBoard","tileViews","onFillStarted","onFillDone","byCol","delayStep","colStr","list","parseInt","sort","a","view","computeTilePosition","BoardGenerator_1","MoveFlowController_1","FillController_1","FXController_1","GameBoardController","teleportSelected","generate","spawnAllTiles","flow","onBoosterConfirmed","onBoosterTargetSelected","clearTeleportHighlight","onSwapDone","tileData","boardPos","resetBoard","newBoard","spawn","stage","viewA","viewB","nodeA","nodeB","createDebugGrid","gridContainer","line","graphics","Graphics","lineWidth","strokeColor","RED","startX","startY","endY","lineTo","stroke","BLUE","endX","text","fontSize","PopupController","resultLine","lblTitle","lblFinalScore","btnRestart","originalResultLinePosition","Vec3","ZERO","onWin","score","show","onLose","clone","onDisable","win","animateResultLineFall","startPosition","showRestartButton","hideElementsWithAnimation","endPosition","GameStateMachine_1","ScoreStrategyQuadratic_1","TurnManager_1","MoveSequenceLogger_1","BoosterSelectPopup_1","SoundController_1","GameScene","fsm","currentState","onStateChange","GameStateMachine","solver","executor","scoreStrategy","turns","getComponentInChildren","ScoreStrategyQuadratic","TurnManager","sounds","SoundController","MoveSequenceLogger","selector","GameStateController","boosterSelectPopup","gameBoard","setInitialState","onGameStart","switchToGameBoard","switchToBoosterSelection","turnManager","targetScore","maxShuffles","state","shuffles","onGroupSelected","onBoosterActivated","onMoveCompleted","getRemaining","changeState","useTurn","group_1","calculate","group_2","group_3","group_4","evaluateEnd","hasAvailableMoves","shuffleBoard","newState","positions","j","HudController","lblScore","lblMoves","lblState","btnPause","onTurnUsed","onTurnEnded","onTurnsInit","root","onPauseClick","bind","onStateChanged","left","moveNode","startVal","setInterval","round","clearInterval","registry","eventName","handler","useCapture","boundHandler","delete","size","boundListener","h","handlers","evt","RemoveCommand_1","FallCommand_1","FillCommand_1","SuperTileFactory_1","hasSuper","some","vfxPromises","onSuperActivated","removeDone","wait","RemoveCommand","dirtyCols","all","SuperTileFactory","make","fallDone","fillDone","ShockwaveConfig_1","MoveFlowController","pendingRemoval","onRemove","onFall","onFill","onSuperTileCreated","onSuperTileActivated","fadeOut","rowIndex","colIndex","v","updated","applyBombShockwave","applyLineShockwave","centerPos","_loop_2","this_2","isInteractive","len","sqrt","offset","shock","bombOffset","by","bombDurationOut","bombDurationBack","isRow","lineDuration","targets","_loop_3","this_3","sign","dir","lineOffset","targets_1","MoveSequenceBadge","logger","onStatusChange","step","unsynced","WHITE","l","getStatus","removed","added","cycles","fillTimer","status","listeners","onTilesRemoved","update","cb","clearTimeout","events","dumpBoard","newTiles","chain","join","RocketVfxController","leftTail","rightTail","speed","leftAngle","rightAngle","movementAngle","isPlaying","setupTail","resetSystem","animateNodeMovement","finish","visibleSize","getVisibleSize","screenWidth","width","screenHeight","height","distance","leftAngleRad","PI","leftDirectionX","cos","leftDirectionY","sin","leftEndX","leftEndY","leftMoveAction","rightAngleRad","rightDirectionX","rightDirectionY","rightEndX","rightEndY","rightMoveAction","particleSystem","angle","autoRemoveOnFinish","life","angleVar","startSize","endSize","startSizeVar","endSizeVar","endColor","startColorVar","endColorVar","emissionRate","totalParticles","gravity","tangentialAccel","radialAccel","speedVar","sourcePos","posVar","positionType","PositionType","RELATIVE","startSpin","endSpin","startSpinVar","endSpinVar","rotationIsDir","stop","stopSystem","SafeAreaAdjuster","area","screen","safeArea","uiTransform","paddingLeft","paddingRight","paddingBottom","paddingTop","multiplier","pow","ShuffleService","shuffleCount","ensureMoves","shuffle","cached","clips","audioEngine","playEffect","AudioClip","clip","SpriteHighlight","originalColor","originalOpacity","isHighlighted","sprite","toggleHighlight","isHighlightedState","setHighlightColor","setHighlightOpacity","updateOriginalValues","resetToOriginal","Integer","svc","onPlace","onCancel","superTile","kindSeed","chances","cumulative","SwapCommand","tA","tB","SwapCommand_1","requireMove","first","externalCancel","onFirst","onSecond","rearm","posB","posA","TileAppearanceConfig","spawnFx","activateFx","TileAppearanceConfig_1","ccEnum","Enum","TileInputController","e","worldPos","getLocation","local","convertToNodeSpaceAR","handleTap","TilePressFeedback","onTilePressed","pressFeedback","TileView","normalVariants","superVariants","currentVisual","isFalling","isFeedbackActive","colorIndex","fx","activateSuper","defaultAnchor","order","nextId","initialTurns","turnsLeft","extras","promises","ps","anim","anyExtra","_e","Toggle","_triggerEventInScript_check"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAIA,MAAAA,aAAAC,QAAA;IACA,MAAAC,UAAAD,QAAA;IACA,MAAAE,SAAAF,QAAA;IAOA,MAAAG;MAaSC,SAAAC;QAEL,MAAAC,MAAAD,IAAAE,UAAAR,WAAAM,IAAAE,WAAAR;QAGA,IAAAS,OAAA;QACA,KAAA,IAAAC,UAAA,GAAAA,UAAA,IAAAA,WAAA;UAEE,MAAAC,QAAA;UACA,KAAA,IAAAC,IAAA,GAAAA,IAAAN,IAAAO,MAAAD,KAAA;YACE,MAAAE,MAAA;YACA,KAAA,IAAAC,IAAA,GAAAA,IAAAT,IAAAU,MAAAD,KAAA;cAEE,MAAAE,QAAAX,IAAAY,OAAAC,KAAAC,MAAAb,QAAAD,IAAAY,OAAAG;cAGAP,IAAAQ,KAAAnB,OAAAoB,YAAAC,aAAAP;;YAEFN,MAAAW,KAAAR;;UAIF,IAAAV,eAAAqB,kBAAAd,QACE,OAAA,IAAAT,QAAAwB,MAAApB,KAAAK;UAGFF,OAAAE;;QAOF,OAAA,IAAAT,QAAAwB,MAAApB,KAAAG;;MAUMJ,yBAAAM;QACN,KAAA,IAAAC,IAAA,GAAAA,IAAAD,MAAAU,QAAAT,KACE,KAAA,IAAAG,IAAA,GAAAA,IAAAJ,MAAAC,GAAAS,QAAAN,KAAA;UACE,MAAAY,UAAAhB,MAAAC,GAAAG;UACA,KAAAY,SAAc;UAGd,IAAAZ,IAAA,IAAAJ,MAAAC,GAAAS,QAAA;YACE,MAAAO,QAAAjB,MAAAC,GAAAG,IAAA;YACA,IAAAa,SAAAA,MAAAX,UAAAU,QAAAV,OACE,OAAA;;UAIJ,IAAAL,IAAA,IAAAD,MAAAU,QAAA;YACE,MAAAQ,SAAAlB,MAAAC,IAAA,GAAAG;YACA,IAAAc,UAAAA,OAAAZ,UAAAU,QAAAV,OACE,OAAA;;;QAKR,OAAA;;;IA9EJa,QAAA1B,iBAAAA;;;;;;;;;;;;;;;ICbA,IAAA2B,aAAA9B,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IAEA,IAAAE,SAAAF,QAAA;IAMA,IAAAgC,cAAA;MACE,SAAAA,YAAAC;QAAoBC,KAAAD,QAAAA;;MAOpBD,YAAAG,UAAAC,sBAAA,SAAAC,MAAAC;QACE,IAAAjC,MAAA6B,KAAAD,MAAA5B;QACA,QAAAgC,KAAAE;SACE,KAAArC,OAAAsC,SAAAC;UACEC,QAAAC,KAAA,4BAAAL,IAAAxB,IAAA,MAAAwB,IAAA3B,IAAA,qBAAA2B,IAAA3B;UAKA,OAAAiC,MAAAC,KAAA;YAAAzB,QAAAf,IAAAU;aAAA,SAAA+B,GAAAhC;YAAA,OAAA,IAAAiC,GAAAC,KAAAlC,GAAAwB,IAAA3B;;;SAIF,KAAAT,OAAAsC,SAAAS;UACEP,QAAAC,KAAA,4BAAAL,IAAAxB,IAAA,MAAAwB,IAAA3B,IAAA,wBAAA2B,IAAAxB;UAIA,OAAA8B,MAAAC,KAAA;YAAAzB,QAAAf,IAAAO;aAAA,SAAAkC,GAAAnC;YAAA,OAAA,IAAAoC,GAAAC,KAAAV,IAAAxB,GAAAH;;;SAIF,KAAAT,OAAAsC,SAAAU;UACE,IAAAC,SAAA;UACAT,QAAAC,KAAA,6BAAAL,IAAAxB,IAAA,MAAAwB,IAAA3B,IAAA,wBAAAwC;UAGA,IAAAC,QAAA;UACA,KAAA,IAAAC,MAAAF,QAAAE,MAAAF,QAAAE,MACE,KAAA,IAAAC,MAAAH,QAAAG,MAAAH,QAAAG,MACE,IAAApC,KAAAqC,IAAArC,KAAAsC,IAAAH,KAAAnC,KAAAsC,IAAAF,QAAAH,QAAA;YACE,IAAAM,IAAA,IAAAV,GAAAC,KAAAV,IAAAxB,IAAAuC,IAAAf,IAAA3B,IAAA2C;YACApB,KAAAD,MAAAyB,SAAAD,MAA4BL,MAAA/B,KAAAoC;;UAIlC,OAAAL;;SAEF,KAAAlD,OAAAsC,SAAAmB;UACEjB,QAAAC,KAAA,8BAAAL,IAAAxB,IAAA,MAAAwB,IAAA3B,IAAA;UAIA,IAAAyC,QAAA;UACA,KAAA,IAAAzC,IAAA,GAAAA,IAAAN,IAAAO,MAAAD,KACE,KAAA,IAAAG,IAAA,GAAAA,IAAAT,IAAAU,MAAAD,KACEsC,MAAA/B,KAAA,IAAA0B,GAAAC,KAAAlC,GAAAH;UAGJ,OAAAyC;;SAEF;UACE,IAAAf,KAAAE,SAAArC,OAAAsC,SAAAoB,QACE,MAAA,IAAAC,MAAA,gCAAAxB,KAAAE;UAGF,OAAA,EAAAD;;;MAeNN,YAAAG,UAAA2B,iBAAA,SAAAC;QAAA,IAAAC,QAAA9B;QACE,IAAA+B,YAAA,IAAAC,IAAAH,MAAAI,IAAA,SAAAV;UAAA,OAAAA,EAAA3C,IAAA,MAAA2C,EAAA9C;;QACA,IAAAyD,QAAAL,MAAAM,OAAA,SAAAZ;UACE,IAAAa,IAAAN,MAAA/B,MAAAsC,OAAAd;UACA,OAAA,SAAAa,KAAAA,EAAA/B,SAAArC,OAAAsC,SAAAoB;;QAGF,OAAAQ,MAAAhD,SAAA,GAAA;UACE,IAAAqC,IAAAW,MAAAI;UACA,IAAAnC,OAAAH,KAAAD,MAAAsC,OAAAd;UACA,KAAApB,MAAW;UACX,KAAA,IAAAoC,KAAA,GAAAC,KAAAxC,KAAAE,oBAAAC,MAAAoB,IAAAgB,KAAAC,GAAAtD,QAAAqD,MAAA;YAAK,IAAAE,QAAAD,GAAAD;YACH,IAAAG,IAAAD,MAAA7D,IAAA,MAAA6D,MAAAhE;YACA,KAAAsD,UAAAY,IAAAD,IAAA;cACEX,UAAAa,IAAAF;cACA,IAAAN,IAAApC,KAAAD,MAAAsC,OAAAI;cACAL,KAAAA,EAAA/B,SAAArC,OAAAsC,SAAAoB,UACEQ,MAAA/C,KAAAsD;;;;QAMR,OAAA/B,MAAAC,KAAAoB,WAAAE,IAAA,SAAAS;UACQ,IAAAF,KAAAE,EAAAG,MAAA,KAAAZ,IAAAa,SAAAlE,IAAA4D,GAAA,IAAA/D,IAAA+D,GAAA;UACN,OAAA,IAAA3B,GAAAC,KAAAlC,GAAAH;;;MAcJqB,YAAAG,UAAA8C,YAAA,SAAAC;QAEE,KAAAhD,KAAAD,MAAAyB,SAAAwB,QACE,OAAA;QAEF,IAAAC,YAAAjD,KAAAD,MAAAsC,OAAAW;QACA,KAAAC,WACE,OAAA;QAIF,IAAAA,UAAA5C,SAAArC,OAAAsC,SAAAoB,QAAA;UACE,IAAAwB,WAAAlD,KAAA4B,eAAA,EAAAoB;UACApD,WAAAuD,SAAAC,KAAAvD,aAAAwD,WAAAC,YAAAJ;UACA,OAAAA;;QAGF,IAAAK,aAAAN,UAAAnE;QAGA,IAAA0E,eAAA,IAAAxB;QACA,IAAAyB,aAAA,EAAAT;QACA,IAAAU,YAAA;QAEA,OAAAD,WAAAvE,SAAA,GAAA;UACE,IAAAqC,IAAAkC,WAAAnB;UACA,IAAAqB,MAAApC,EAAA3C,IAAA,MAAA2C,EAAA9C;UACA,IAAA+E,aAAAb,IAAAgB,MAA2B;UAC3BH,aAAAZ,IAAAe;UAEA,IAAAxD,OAAAH,KAAAD,MAAAsC,OAAAd;UACA,KAAApB,QAAAA,KAAArB,UAAAyE,cAAApD,KAAAE,SAAArC,OAAAsC,SAAAoB,QACE;UAEFgC,UAAAvE,KAAAoC;UAEA,KAAA,IAAAgB,KAAA,GAAAC,KAAAxC,KAAAD,MAAA6D,WAAArC,IAAAgB,KAAAC,GAAAtD,QAAAqD,MAAA;YAAK,IAAAsB,IAAArB,GAAAD;YACH,IAAAuB,OAAAD,EAAAjF,IAAA,MAAAiF,EAAApF;YACA+E,aAAAb,IAAAmB,SACEL,WAAAtE,KAAA0E;;;QAKN,IAAAE,SAAA/D,KAAA4B,eAAA8B;QAGA9D,WAAAuD,SAAAC,KAAAvD,aAAAwD,WAAAC,YAAAS;QACA,OAAAA;;MAQFjE,YAAAG,UAAA+D,WAAA;QAAA,IAAAlC,QAAA9B;QACE,IAAAiE,QAAA;QAEAjE,KAAAD,MAAAmE,QAAA,SAAA3C,GAAApB;UACE,IAAA8D,OAAW;UAEX,KAAA,IAAA1B,KAAA,GAAAC,KAAAV,MAAA/B,MAAA6D,WAAArC,IAAAgB,KAAAC,GAAAtD,QAAAqD,MAAA;YAAK,IAAAsB,IAAArB,GAAAD;YACH,IAAA4B,QAAArC,MAAA/B,MAAAsC,OAAAwB;YACA,IAAAM,SAAAA,MAAArF,UAAAqB,KAAArB,OAAA;cACEmF,QAAA;cACA;;;;QAIN,OAAAA;;MAEJ,OAAAnE;KA9LA;IAAaH,QAAAG,cAAAA;;;;;;;;;;;;;;;ICHb,IAAAP,QAAA;MAYE,SAAAA,MAAApB,KAAAK;;QACEwB,KAAA7B,MAAAA;QACA6B,KAAAoE,OAAA;QACA,KAAA,IAAA3F,IAAA,GAAAA,IAAAN,IAAAO,MAAAD,KACE,IAAAD,SAAAA,MAAAC,IAAA;UAEE,IAAAE,MAAA;UACA,KAAA,IAAAC,IAAA,GAAAA,IAAAT,IAAAU,MAAAD,KACED,IAAAC,KAAA,UAAA4D,KAAAhE,MAAAC,GAAAG,YAAA,MAAA4D,KAAAA,KAAA;UAEFxC,KAAAoE,KAAA3F,KAAAE;eAGAqB,KAAAoE,KAAA3F,KAAAiC,MAAAvC,IAAAU,MAAAwF,KAAA;;MAKNC,OAAAC,eAAAhF,MAAAU,WAAA,UAAA;QAAAuE,KAAA;UACE,OAAAxE,KAAA7B;;;;;MAIFmG,OAAAC,eAAAhF,MAAAU,WAAA,QAAA;QAAAuE,KAAA;UACE,OAAAxE,KAAA7B,IAAAO;;;;;MAIF4F,OAAAC,eAAAhF,MAAAU,WAAA,QAAA;QAAAuE,KAAA;UACE,OAAAxE,KAAA7B,IAAAU;;;;;MAUKU,MAAAU,UAAAuB,WAAA,SAAAD;QACL,OAAAA,EAAA3C,KAAA,KAAA2C,EAAA9C,KAAA,KAAA8C,EAAA3C,IAAAoB,KAAA7B,IAAAU,QAAA0C,EAAA9C,IAAAuB,KAAA7B,IAAAO;;MAQKa,MAAAU,UAAAoC,SAAA,SAAAd;QACL,OAAAvB,KAAAwB,SAAAD,KAAAvB,KAAAoE,KAAA7C,EAAA9C,GAAA8C,EAAA3C,KAAA;;MAQKW,MAAAU,UAAAwE,UAAA,SAAAlD;QACL,IAAApB,OAAAH,KAAAqC,OAAAd;QACA,OAAApB,OAAAA,KAAArB,QAAA;;MASKS,MAAAU,UAAAyE,UAAA,SAAAnD,GAAAa;QACL,KAAApC,KAAAwB,SAAAD,IACE,MAAA,IAAAI,MAAA,6BAAAJ,EAAA3C,IAAA,OAAA2C,EAAA9C,IAAA;QAEFuB,KAAAoE,KAAA7C,EAAA9C,GAAA8C,EAAA3C,KAAAwD;;MASK7C,MAAAU,UAAA2D,aAAA,SAAArC;QACL,IAAAwC,SAAA;QACA,IAAAY,aAAA,EACE,IAAA9D,GAAAC,KAAAS,EAAA3C,GAAA2C,EAAA9C,IAAA,IACA,IAAAoC,GAAAC,KAAAS,EAAA3C,IAAA,GAAA2C,EAAA9C,IACA,IAAAoC,GAAAC,KAAAS,EAAA3C,GAAA2C,EAAA9C,IAAA,IACA,IAAAoC,GAAAC,KAAAS,EAAA3C,IAAA,GAAA2C,EAAA9C;QAEF,KAAA,IAAA8D,KAAA,GAAAqC,eAAAD,YAAApC,KAAAqC,aAAA1F,QAAAqD,MAAA;UAAK,IAAAsC,IAAAD,aAAArC;UACHvC,KAAAwB,SAAAqD,MACEd,OAAA5E,KAAA0F;;QAGJ,OAAAd;;MAOKxE,MAAAU,UAAAiE,UAAA,SAAAY;QACL,KAAA,IAAArG,IAAA,GAAAA,IAAAuB,KAAA7B,IAAAO,MAAAD,KACE,KAAA,IAAAG,IAAA,GAAAA,IAAAoB,KAAA7B,IAAAU,MAAAD,KAAA;UACE,IAAAuB,OAAAH,KAAAoE,KAAA3F,GAAAG;UACAuB,QACE2E,SAAA,IAAAjE,GAAAC,KAAAlC,GAAAH,IAAA0B;;;MAKV,OAAAZ;KA3HA;IAAaI,QAAAJ,QAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICHb,IAAAwF,iBAAAjH,QAAA;IACA,IAAAkH,gBAAAlH,QAAA;IAKA,IAAAmH,cAAA;MACE,SAAAA,YAAAlF,OAAAmF,QAAAjE,QAAAkE;QACUnF,KAAAD,QAAAA;QACAC,KAAAkF,SAAAA;QACAlF,KAAAiB,SAAAA;QACAjB,KAAAmF,MAAAA;;MAGJF,YAAAhF,UAAAmF,UAAA;QAAW,OAAAC,UAAArF,WAAA,GAAAsF,SAAA;;;;;cAKTzD,QAAA;cACN,KAAAV,MAAAnB,KAAAiB,QAAAE,MAAAnB,KAAAiB,QAAAE,MACE,KAAAC,MAAApB,KAAAiB,QAAAG,MAAApB,KAAAiB,QAAAG,MACE,IAAApC,KAAAqC,IAAArC,KAAAsC,IAAAH,KAAAnC,KAAAsC,IAAAF,QAAApB,KAAAiB,QAAA;gBACQM,IAAA,IAAAV,GAAAC,KAAAd,KAAAkF,OAAAtG,IAAAuC,IAAAnB,KAAAkF,OAAAzG,IAAA2C;gBACNpB,KAAAD,MAAAyB,SAAAD,MAA4BM,MAAA1C,KAAAoC;;cAM5BgE,WAAA,IAAAP,cAAAlF,YAAAE,KAAAD,OAAA6B,eAAAC;cAKN,OAAA,EAAA,GAAA,IAAAkD,eAAAS,aAAAxF,KAAAD,OAAAC,KAAAmF,KAAAC,QAAAG;;;cAAA/C,GAAAiD;;;;;;MAEJ,OAAAR;KA/BA;IAAatF,QAAAsF,cAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICTb,IAAArF,aAAA9B,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IACA,IAAA4H,iBAAA5H,QAAA;IACA,IAAA6H,oBAAA7H,QAAA;IACA,IAAA8H,oBAAA9H,QAAA;IACA,IAAA+H,4BAAA/H,QAAA;IAEM,IAAA0E,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAkBN,IAAAC,yBAAA,SAAAC;MAAoDC,UAAAF,wBAAAC;MAApD,SAAAD;QAAA,IAAAnE,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAEE8B,MAAAwE,cAAA;QAGAxE,MAAAyE,oBAAA;QAGAzE,MAAA0E,eAAA;QAEQ1E,MAAA2E,eAAA;;;MAERR,uBAAAhG,UAAA+C,QAAA;QACEhD,KAAA0G;QACA,IAAAC,UAAAd,0BAAAe,wBAAAC;QACA7G,KAAA8G,YAAAH;QAEA,MAAArC,OAAAyC,KAAAJ,SAAAzH,SACEc,KAAAwG,aAAAQ,SAAA,QAEAhH,KAAAwG,aAAAQ,SAAA;;MAIIf,uBAAAhG,UAAA6G,cAAA,SAAAH;;QACN,KAAA3G,KAAAsG,gBAAAtG,KAAAuG,mBAAA;UACE/F,QAAAyG,KAAA;UACA;;QAIFjH,KAAAsG,YAAAY;QACAlH,KAAAyG,eAAA;QAEA,IAAAU,UAAA7C,OAAA6C,QAAAR,SAAAxE,OAAA,SAAAK;UAAmD,IAAAqC,IAAArC,GAAA;UAAO,OAAAqC,IAAA;;QAEjD,IAAAuC,UAAA,SAAAC;UACD,IAAA7E,KAAA2E,QAAAE,IAAAC,YAAA9E,GAAA,IAAA+E,QAAA/E,GAAA;UACN,IAAAgF,OAAA3G,GAAA4G,YAAAC,OAAAnB;UACAmB,OAAApB,YAAAqB,SAAAH;UACAA,KAAAI,YAAA,GAAA,GAAA;UAEA,IAAAC,SAAAL,KAAAM,aAAAjH,GAAAkH;UACA,IAAAC,gBAEK,UAFLC,KAEK,UAFLzF,KAAAgF,KAEKU,eAAA,2BAAA,MAAA1F,UAAA,IAAAA,GAAA0F,eAAA,yBAAA,MAAAD,UAAA,IAAAA,GAAAH,aAAAjH,GAAAsH,WAAA;UAIL,IAAAC,MAAAzC,kBAAA0C,gBAAAC,KAAA,SAAAC;YAAA,OAAAA,EAAAC,OAAAlB;;UACA,KAAAc,KAAiB,OAAA;YAAAK,YAAA;;UAEjB,IAAAC,QAAA,UAAAC,KAAAnB,KAAAU,eAAA,wBAAA,MAAAS,UAAA,IAAAA,GAAAb,aAAAjH,GAAA+H,YAAA;UAEAF,QACE7H,GAAAgI,UAAAC,KAAAV,IAAAM,MAAA7H,GAAAkI,aAAA,SAAAC,KAAAC;aACED,OAAAC,eAAAP,SACEA,KAAAO,cAAAA;;UAINzI,QAAA0I,IAAA,QAAAR;UAEA,IAAAS,OAAA;YACE3B,MAAAA;YACAK,QAAAA;YACAa,MAAAA;YACAV,cAAAA;YACAoB,WAAA;YACA9B,WAAAA;YACAX,SAAAY;YACA8B,UAAA;;UAGF3B,OAAA4B,mBAAAH;UACAzB,OAAA6B,sBAAAJ;UACAzB,OAAA8B,eAAAL,MAAA7B;UAEA6B,KAAAnB,iBACEmB,KAAAnB,aAAAyB,SAAAC,OAAAnC;UAGF4B,KAAA3B,KAAAR,SAAA;UACAU,OAAAjB,aAAAtH,KAAAgK;;;QA/CF,KAAA,IAAA9B,IAAA,GAAAA,IAAAF,QAAAjI,QAAAmI,KAAA;UAAS,IAAAsC,UAAAvC,QAAAC;;;QAmDT,IAAAuC,SAAA5J,KAAAsG,YAAAwB,aAAAjH,GAAAgJ;QACAD,UACEA,OAAAE;;MAII7D,uBAAAhG,UAAAyG,sBAAA;QACN9G,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAA2G,iBAAAhK,KAAAiK,mBAAAjK;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAA6G,kBAAAlK,KAAAmK,oBAAAnK;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAA+G,kBAAApK,KAAAqK,oBAAArK;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAiH,aAAAtK,KAAAuK,eAAAvK;;MAGMiG,uBAAAhG,UAAAuJ,iBAAA,SAAAL,MAAA7B;QACN,KAAA6B,KAAAT,MAAgB;QAChB,IAAAN,MAAAzC,kBAAA0C,gBAAAC,KAAA,SAAAC;UAAA,OAAAA,EAAAC,OAAAlB;;QACA,KAAAc,KAAU;QACVvH,GAAAgI,UAAAC,KAAAV,IAAAM,MAAA7H,GAAAkI,aAAA,SAAAC,KAAAC;WACED,OAAAC,eAAAE,KAAAT,SACES,KAAAT,KAAAO,cAAAA;;;MAKEhD,uBAAAhG,UAAAqJ,qBAAA,SAAAH;QACN,IAAAC,YAAAD,KAAA3B,KAAAgD,aAAA5E,kBAAA6E;QACArB,UAAAsB,iBAAA7J,GAAA8J,MAAAC;QACAxB,UAAAyB,mBAAA;QACA1B,KAAAC,YAAAA;;MAGMnD,uBAAAhG,UAAAsJ,wBAAA,SAAAJ;QAAR,IAAArH,QAAA9B;QACE,KAAAmJ,KAAAtB,QAAkB;QAClBsB,KAAAtB,OAAAL,KAAAsD,IAAAjK,GAAAkK,KAAAC,UAAAC;QACA9B,KAAAtB,OAAAL,KAAAuC,GAAAlJ,GAAAkK,KAAAC,UAAAC,WAAA;UACEnJ,MAAAoJ,gBAAA/B;;;MAIIlD,uBAAAhG,UAAAiL,kBAAA,SAAAC;QACN,KAAAA,YAAA7D,WAA4B;QAC5B,IAAA6D,YAAA9B,UAAA;UACErJ,KAAAoL;UACA,SAAA1F,eAAA2F,uBAAA,MAAA3F,eAAA2F,sBAAA,IAAA3F,eAAA2F,eAAAC;UACA;;QAEFtL,KAAAuL,cAAAJ;;MAGMlF,uBAAAhG,UAAAsL,gBAAA,SAAApC;;QACNnJ,KAAAoL;QACA,SAAA1F,eAAA2F,uBAAA,MAAA3F,eAAA2F,sBAAA,IAAA3F,eAAA2F,eAAAG,SAAArC,KAAA7B;QACA6B,KAAAE,WAAA;QACA,UAAA7G,KAAA2G,KAAAC,mBAAA,MAAA5G,UAAA,IAAAA,GAAAiJ;QACAzL,KAAA0L,WAAAvC,KAAA3B;;MAGMvB,uBAAAhG,UAAAmL,kBAAA;;QACN,IAAAO,aAAA3L,KAAAyG,aAAA6B,KAAA,SAAAsD;UAAA,OAAAA,EAAAvC;;QACA,IAAAsC,YAAA;UACEA,WAAAtC,WAAA;UACA,UAAA7G,KAAAmJ,WAAAvC,mBAAA,MAAA5G,UAAA,IAAAA,GAAAqJ;UACA7L,KAAA8L,UAAAH,WAAAnE;;;MAIIvB,uBAAAhG,UAAAyL,aAAA,SAAAlE;QACNA,KAAAuE;QACA,IAAAC,QAAA;UACEnL,GAAAoL,MAAAzE,MACG0E,GAAA,IAAA;YAAAC,OAAA;aACAD,GAAA,IAAA;YAAAC,OAAA;aACAC,KAAAJ,OACAhJ;;QAELgJ;;MAGM/F,uBAAAhG,UAAA6L,YAAA,SAAAtE;QACNA,KAAAuE;QACAvE,KAAA2E,QAAA;;MAGMlG,uBAAAhG,UAAAgK,oBAAA,SAAA3C;;QACN,IAAA6B,OAAAnJ,KAAAyG,aAAA6B,KAAA,SAAAsD;UAAA,OAAAA,EAAAtE,cAAAA;;QACA,IAAA6B,MAAA;UACEA,KAAAxC,UAAA,UAAAnE,KAAA,SAAAkD,eAAA2F,uBAAA,MAAA3F,eAAA2F,sBAAA,IAAA3F,eAAA2F,eAAAgB,WAAA/E,oBAAA,MAAA9E,KAAAA,KAAA;UACA2G,KAAAnB,iBACEmB,KAAAnB,aAAAyB,SAAAC,OAAAP,KAAAxC;UAEFwC,KAAAxC,WAAA,KACE3G,KAAAsM,gBAAAnD;;QAKJnJ,KAAAoL;;MAGMnF,uBAAAhG,UAAAkK,qBAAA;QACNnK,KAAAoL;;MAGMnF,uBAAAhG,UAAAoK,qBAAA,SAAA1D;QACN3G,KAAA8G,YAAAH;QAEA,MAAArC,OAAAyC,KAAAJ,SAAAzH,SACEc,KAAAwG,aAAAQ,SAAA,QAEAhH,KAAAwG,aAAAQ,SAAA;;MAIIf,uBAAAhG,UAAAsK,gBAAA;QACN,SAAA7E,eAAA2F,uBAAA,MAAA3F,eAAA2F,sBAAA,IAAA3F,eAAA2F,eAAAC;QACAtL,KAAAoL;QACApL,KAAA8G,YAAA;;MAGMb,uBAAAhG,UAAAqM,kBAAA,SAAAnD;;QACNA,KAAA3B,KAAAR,SAAA;QACAmC,KAAAE,WAAA;QACA,UAAA7G,KAAA2G,KAAAC,mBAAA,MAAA5G,UAAA,IAAAA,GAAAqJ;QACA7L,KAAA8L,UAAA3C,KAAA3B;;MAGFvB,uBAAAhG,UAAAsM,YAAA;QACE3M,WAAAuD,SAAA2H,IAAAjL,aAAAwD,WAAA2G,iBAAAhK,KAAAiK,mBAAAjK;QACAJ,WAAAuD,SAAA2H,IAAAjL,aAAAwD,WAAA6G,kBAAAlK,KAAAmK,oBAAAnK;QACAJ,WAAAuD,SAAA2H,IAAAjL,aAAAwD,WAAA+G,kBAAApK,KAAAqK,oBAAArK;QACAJ,WAAAuD,SAAA2H,IAAAjL,aAAAwD,WAAAiH,aAAAtK,KAAAuK,eAAAvK;;MAvNFwM,WAAA,EADCxG,SAAAnF,GAAAkK,SAC2B9E,uBAAAhG,WAAA,oBAAA;MAG5BuM,WAAA,EADCxG,SAAAnF,GAAA4L,WACmCxG,uBAAAhG,WAAA,0BAAA;MAGpCuM,WAAA,EADCxG,SAAAnF,GAAAkK,SAC4B9E,uBAAAhG,WAAA,qBAAA;MARVgG,yBAAAuG,WAAA,EADpBzG,aACoBE;MA2NrB,OAAAA;KA3NA,CAAApF,GAAA6L;IAAqB/M,QAAA8K,UAAAxE;;;;;;;;;;;;;;;;;;ICpBrB,IAAA0G,oBAAA7O,QAAA;IACA,IAAA8O,qBAAA9O,QAAA;IACA,IAAAE,SAAAF,QAAA;IAiBa6B,QAAA0I,kBAAA,EACX;MACEG,IAAA;MACAE,MAAA;MACAmE,SAAA,SAAArK;QAAY,IAAAzC,QAAAyC,GAAAzC,OAAAoF,MAAA3C,GAAA2C,KAAAwB,UAAAnE,GAAAmE;QACV,OAAA,IAAAgG,kBAAAG,gBAAA/M,OAAAoF,KAAAwB;;OAEJ;MACE6B,IAAA;MACAE,MAAA;MACAmE,SAAA,SAAArK;QAAY,IAAAzC,QAAAyC,GAAAzC,OAAAgN,UAAAvK,GAAAuK,SAAA5H,MAAA3C,GAAA2C,KAAAkG,iBAAA7I,GAAA6I,gBAAA1E,UAAAnE,GAAAmE;QACV,OAAA,IAAAiG,mBAAAI,iBAAA,QAAAjN,OAAAgN,SAAA5H,KAAAkG,gBAAA1E,SAAA3I,OAAAsC,SAAAU;;OAUJ;MACEwH,IAAA;MACAE,MAAA;MACAmE,SAAA,SAAArK;QAAY,IAAAzC,QAAAyC,GAAAzC,OAAAgN,UAAAvK,GAAAuK,SAAA5H,MAAA3C,GAAA2C,KAAAkG,iBAAA7I,GAAA6I,gBAAA1E,UAAAnE,GAAAmE;QACV,OAAA,IAAAiG,mBAAAI,iBAAA,YAAAjN,OAAAgN,SAAA5H,KAAAkG,gBAAA1E,SAAA3I,OAAAsC,SAAAC;;OAUJ;MACEiI,IAAA;MACAE,MAAA;MACAmE,SAAA,SAAArK;QAAY,IAAAzC,QAAAyC,GAAAzC,OAAAgN,UAAAvK,GAAAuK,SAAA5H,MAAA3C,GAAA2C,KAAAkG,iBAAA7I,GAAA6I,gBAAA1E,UAAAnE,GAAAmE;QACV,OAAA,IAAAiG,mBAAAI,iBAAA,YAAAjN,OAAAgN,SAAA5H,KAAAkG,gBAAA1E,SAAA3I,OAAAsC,SAAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC/DA,IAAAyB,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAON,IAAAiH,mCAAA,SAAA/G;MAA8DC,UAAA8G,kCAAA/G;MAA9D,SAAA+G;QAAA,IAAAnL,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAEE8B,MAAAoL,gBAAA;QAGApL,MAAAqL,qBAAA;QAGArL,MAAAsL,0BAAA;QAGAtL,MAAA2E,eAAA;QAGA3E,MAAAuL,aAAA;QAIAvL,MAAAwL,aAAA;QAGAxL,MAAAyL,kBAAA;QAGAzL,MAAA0L,aAAA;QAGA1L,MAAA2L,kBAAA;QAGA3L,MAAA4L,iBAAA;QAGA5L,MAAA6L,gBAAA;QAGA7L,MAAA8L,mBAAA;QAEQ9L,MAAA+L,iBAAA,IAAAC;QACAhM,MAAAiM,oBAAA,IAAAD;;;MAERb,iCAAAhN,UAAA+N,SAAA;QACEhO,KAAAiO;QACAjO,KAAAkO;;MAGFjB,iCAAAhN,UAAA+C,QAAA;QACEhD,KAAAmO;QACAnO,KAAAoO;;MAMMnB,iCAAAhN,UAAAgO,0BAAA;QAAR,IAAAnM,QAAA9B;QACE,IAAAqO,WAAAC,eAAA,EACEtO,KAAAkN,eACAlN,KAAAmN,oBACAnN,KAAAoN,2BACGpN,KAAAyG,cAAA,EACHzG,KAAAqN;QAGFgB,SAAAnK,QAAA,SAAAqK;UACE,IAAAA,SAAA;YACEzM,MAAA+L,eAAAW,IAAAD,SAAAA,QAAApC;YACArK,MAAAiM,kBAAAS,IAAAD,SAAAA,QAAAE;iBAEAjO,QAAAyG,KAAA;;;MAQEgG,iCAAAhN,UAAAiO,kBAAA;QACN,IAAAG,WAAAC,eAAA,EACEtO,KAAAkN,eACAlN,KAAAmN,oBACAnN,KAAAoN,2BACGpN,KAAAyG,cAAA,EACHzG,KAAAqN;QAGFgB,SAAAnK,QAAA,SAAAqK;UACE,IAAAA,SAAA;YACEA,QAAAG,SAAA,GAAA,GAAA;YACAH,QAAAI,UAAA;iBAIAnO,QAAAyG,KAAA;;;MAQCgG,iCAAAhN,UAAAmO,wBAAA;QAAP,IAAAtM,QAAA9B;QAEEA,KAAA4O,aAAA;UACE9M,MAAA+M,aAAA/M,MAAAoL;WACF;QAEAlN,KAAA4O,aAAA;UACE9M,MAAA+M,aAAA/M,MAAAqL;WACFnN,KAAAsN;QAGAtN,KAAA4O,aAAA;UACE9M,MAAAgN;WACF9O,KAAAuN;QAGAvN,KAAA4O,aAAA;UACE9M,MAAAiN;WACF/O,KAAAwN;QAGAxN,KAAA4O,aAAA;UACE9M,MAAAkN;WACFhP,KAAAyN;;MAMMR,iCAAAhN,UAAA4O,eAAA,SAAAI;QACN,KAAAA,OAAA;UACEzO,QAAAyG,KAAA;UACA;;QAGFzG,QAAA0I,IAAA,sBAAA+F,MAAAC;QAGAD,MAAAjI,SAAA;QACAiI,MAAAN,UAAA;QACAM,MAAAP,SAAA,GAAA,GAAA;QAGA7N,GAAAoL,MAAAgD,OACG/C,GAAAlM,KAAA0N,gBAAA;UAAAvB,OAAA;WAAA;UAAAgD,QAAA;WACAjD,GAAA,KAAAlM,KAAA0N,gBAAA;UAAAvB,OAAA;WAAA;UAAAgD,QAAA;WACAnM;;MAMGiK,iCAAAhN,UAAA6O,oBAAA;QACN,KAAA9O,KAAAoN,yBAAA;UACE5M,QAAAyG,KAAA;UACA;;QAGFjH,KAAAoN,wBAAApG,SAAA;QACAhH,KAAAoN,wBAAAuB,UAAA;QACA3O,KAAAoN,wBAAAsB,SAAA,GAAA,GAAA;QAEA7N,GAAAoL,MAAAjM,KAAAoN,yBACGlB,GAAAlM,KAAA0N,gBAAA;UAAAvB,OAAA;WAAA;UAAAgD,QAAA;WACAjD,GAAA,KAAAlM,KAAA0N,gBAAA;UAAAvB,OAAA;WAAA;UAAAgD,QAAA;WACAnM;;MAMGiK,iCAAAhN,UAAA8O,eAAA;QAAR,IAAAjN,QAAA9B;QACEA,KAAAyG,aAAAvC,QAAA,SAAAiF,MAAAiG;UACE,KAAAjG,MAAA;YACE3I,QAAAyG,KAAA,UAAAmI,QAAA;YACA;;UAGF,IAAAC,QAAA,KAAAD;UAEAtN,MAAA8M,aAAA;YACE9M,MAAAwN,YAAAnG;aACFkG;;;MAOIpC,iCAAAhN,UAAAqP,cAAA,SAAAnG;QACN,KAAAA,MAAW;QAEX,IAAAoG,gBAAAvP,KAAA6N,eAAArJ,IAAA2E,SAAA;QAGAA,KAAAnC,SAAA;QACAmC,KAAAwF,UAAA;QACAxF,KAAAuF,SAAA,KAAAa;QAGA1O,GAAAoL,MAAA9C,MACG+C,GAAAlM,KAAA2N,eAAA;UAGGxB,OAAAoD;WACD;UAAAJ,QAAA;WAGFnM;;MAMGiK,iCAAAhN,UAAA+O,oBAAA;QACN,KAAAhP,KAAAqN,YAAA;UACE7M,QAAAyG,KAAA;UACA;;QAGFjH,KAAAqN,WAAArG,SAAA;QACAhH,KAAAqN,WAAAsB,UAAA;QACA3O,KAAAqN,WAAAqB,SAAA,GAAA,GAAA;QAEA7N,GAAAoL,MAAAjM,KAAAqN,YACGnB,GAAAlM,KAAA0N,gBAAA;UAAAvB,OAAA;WAAA;UAAAgD,QAAA;WACAjD,GAAA,KAAAlM,KAAA0N,gBAAA;UAAAvB,OAAA;WAAA;UAAAgD,QAAA;WACAnM;;MAMEiK,iCAAAhN,UAAAuP,kBAAA;QACLxP,KAAAkO;QACAlO,KAAAoO;;MAMKnB,iCAAAhN,UAAAwP,qBAAA;QAAP,IAAA3N,QAAA9B;QACEQ,QAAA0I,IAAA;QAEA,IAAAmF,WAAAC,eAAA,EACEtO,KAAAkN,eACAlN,KAAAmN,oBACAnN,KAAAoN,2BACGpN,KAAAyG,cAAA,EACHzG,KAAAqN;QAGFgB,SAAAnK,QAAA,SAAAqK;UACE,IAAAA,SAAA;YACEA,QAAAI,UAAA;YACA,IAAAY,gBAAAzN,MAAA+L,eAAArJ,IAAA+J,YAAA;YACA,IAAAmB,mBAAA5N,MAAAiM,kBAAAvJ,IAAA+J;YACAA,QAAAG,SAAAa;YACAhB,QAAAE,cAAAiB;iBAEAlP,QAAAyG,KAAA;;;MAKEgG,iCAAAhN,UAAAkO,kBAAA;QACNnO,KAAAkN,iBACE1M,QAAAmP,MAAA;QAIF3P,KAAAmN,sBACE3M,QAAAmP,MAAA;QAIF3P,KAAAoN,2BACE5M,QAAAmP,MAAA;QAIF,MAAA3P,KAAAyG,aAAAvH,UACEsB,QAAAmP,MAAA;QAIF3P,KAAAqN,cACE7M,QAAAmP,MAAA;;MA7RJnD,WAAA,EADCxG,SAAAnF,GAAAkK,SAC6BkC,iCAAAhN,WAAA,sBAAA;MAG9BuM,WAAA,EADCxG,SAAAnF,GAAAkK,SACkCkC,iCAAAhN,WAAA,2BAAA;MAGnCuM,WAAA,EADCxG,SAAAnF,GAAAkK,SACuCkC,iCAAAhN,WAAA,gCAAA;MAGxCuM,WAAA,EADCxG,SAAA,EAAAnF,GAAAkK,WAC4BkC,iCAAAhN,WAAA,qBAAA;MAG7BuM,WAAA,EADCxG,SAAAnF,GAAAkK,SAC0BkC,iCAAAhN,WAAA,mBAAA;MAI3BuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,IAAA,GAAA;YACwB7C,iCAAAhN,WAAA,mBAAA;MAGzBuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,IAAA,GAAA;YAC6B7C,iCAAAhN,WAAA,wBAAA;MAG9BuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,IAAA,GAAA;YACwB7C,iCAAAhN,WAAA,mBAAA;MAGzBuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,IAAA,GAAA;YAC6B7C,iCAAAhN,WAAA,wBAAA;MAG9BuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,IAAA,IAAA;YAC4B7C,iCAAAhN,WAAA,uBAAA;MAG7BuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,IAAA,IAAA;YAC2B7C,iCAAAhN,WAAA,sBAAA;MAG5BuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,IAAA,IAAA;YAC8B7C,iCAAAhN,WAAA,yBAAA;MApCZgN,mCAAAT,WAAA,EADpBzG,aACoBkH;MAkSrB,OAAAA;KAlSA,CAAApM,GAAA6L;IAAqB/M,QAAA8K,UAAAwC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICPrB,IAAA8C,qCAAAjS,QAAA;IACA,IAAA6H,oBAAA7H,QAAA;IACA,IAAA+H,4BAAA/H,QAAA;IACA,IAAA8H,oBAAA9H,QAAA;IAEM,IAAA0E,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAcN,IAAAgK,qBAAA,SAAA9J;MAAgDC,UAAA6J,oBAAA9J;MAAhD,SAAA8J;QAAA,IAAAlO,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAEE8B,MAAAmO,kBAAA;QAGAnO,MAAAyE,oBAAA;QAEQzE,MAAAoO,QAAA;QACApO,MAAAqO,sBAAA;;;MAERH,mBAAA/P,UAAA+N,SAAA;QACEhO,KAAAmQ,sBAAAnQ,KAAA8H,aAAAiI,mCAAAtF;QAGA5E,0BAAAe,wBAAAwJ;QACApQ,KAAA8G;;MAGFkJ,mBAAA/P,UAAAoQ,WAAA;;QACExK,0BAAAe,wBAAAwJ;QACApQ,KAAAsQ;QACA,UAAA9N,KAAAxC,KAAAmQ,6BAAA,MAAA3N,UAAA,IAAAA,GAAAgN;;MAGFQ,mBAAA/P,UAAA+C,QAAA;QAAA,IAAAlB,QAAA9B;QACE,IAAAqN,aAAArN,KAAAwH,KAAAU,eAAA;QACA,SAAAmF,mBAAA,MAAAA,kBAAA,IAAAA,WAAAtD,GAAAlJ,GAAAkK,KAAAC,UAAAC,WAAA;UAAA,OAAAnJ,MAAAyO;;;MAGMP,mBAAA/P,UAAA6G,cAAA;QAAR,IAAAhF,QAAA9B;;QACE,KAAAA,KAAAiQ,oBAAAjQ,KAAAuG,mBAAA;UACE/F,QAAAyG,KAAA;UACA;;QAEFjH,KAAAkQ,QAAA;QAES,IAAA9I,UAAA,SAAAC;UACP,IAAAe,MAAAzC,kBAAA0C,gBAAAhB;UACA,IAAAG,OAAA3G,GAAA4G,YAAAC,OAAAnB;UACAmB,OAAAuI,gBAAAtI,SAAAH;UACAA,KAAAI,YAAA,GAAA,GAAA;UAEA,IAAAc,QAAA,UAAAlG,KAAAgF,KAAAU,eAAA,wBAAA,MAAA1F,UAAA,IAAAA,GAAAsF,aAAAjH,GAAA+H,YAAA;UAEAF,QACE7H,GAAAgI,UAAAC,KAAAV,IAAAM,MAAA7H,GAAAkI,aAAA,SAAAC,KAAAC;aACED,OAAAC,eAAAP,SACEA,KAAAO,cAAAA;;UAKN,IAAAuH,kBAAAhJ,KAAAU,eAAA;UACA,IAAAkB,YAAAoH,gBAAAhG,aAAA5E,kBAAA6E;UACArB,UAAAsB,iBAAA7J,GAAA8J,MAAAC;UACAxB,UAAAyB,mBAAA;UAEA,IAAA1B,OAAA;YACE3B,MAAAA;YACAF,WAAAc,IAAAI;YACAY,WAAAA;YACAV,MAAA;;UAGFlB,KAAAuC,GAAAlJ,GAAAkK,KAAAC,UAAAC,WAAA;YAAA,OAAAnJ,MAAA2O,YAAAtH;;UAEA3B,KAAAR,SAAA;UAEAU,OAAAwI,MAAA/Q,KAAAgK;;;QAhCF,KAAA,IAAA9B,IAAA,GAAAA,IAAA1B,kBAAA0C,gBAAAnJ,QAAAmI,KAASD,QAAAC;QAoCT,IAAAuC,SAAA5J,KAAAiQ,gBAAAnI,aAAAjH,GAAAgJ;QACAD,UACEA,OAAAE;QAGF9J,KAAAmQ,wBACEnQ,KAAAmQ,oBAAA1J,eAAAzG,KAAAkQ,MAAAjO,IAAA,SAAA2J;UAAA,OAAAA,EAAApE;;;MAIIwI,mBAAA/P,UAAAwQ,cAAA,SAAAtH;QACNtD,0BAAAe,wBAAA8J,OAAAvH,KAAA7B;QACAtH,KAAAsQ;;MAGMN,mBAAA/P,UAAAqQ,mBAAA;QACN,IAAAK,WAAA,IAAA3O,IAAA6D,0BAAAe,wBAAAgK;QACA5Q,KAAAkQ,MAAAhM,QAAA,SAAA0H;UACE+E,SAAAhO,IAAAiJ,EAAAtE,aACEsE,EAAAxC,UAAAqC,iBAEAG,EAAAxC,UAAAyC;;;MAKEmE,mBAAA/P,UAAA4Q,UAAA;QACNrQ,QAAA0I,IAAA;QACArD,0BAAAe,wBAAAiK;QACC7Q,KAAAwH,KAAAR,SAAA;;MAGKgJ,mBAAA/P,UAAAsQ,YAAA;QACNvQ,KAAA6Q;;MAGKb,mBAAA/P,UAAAuP,kBAAA;QACLxP,KAAAmQ,uBACEnQ,KAAAmQ,oBAAAX;;MAIGQ,mBAAA/P,UAAA6Q,kBAAA;QACL9Q,KAAAmQ,uBACEnQ,KAAAmQ,oBAAAV;;MAlHJjD,WAAA,EADCxG,SAAAnF,GAAAkK,SAC+BiF,mBAAA/P,WAAA,wBAAA;MAGhCuM,WAAA,EADCxG,SAAAnF,GAAA4L,WACmCuD,mBAAA/P,WAAA,0BAAA;MALjB+P,qBAAAxD,WAAA,EADpBzG,aACoBiK;MAuHrB,OAAAA;KAvHA,CAAAnP,GAAA6L;IAAqB/M,QAAA8K,UAAAuF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICnBrB,IAAApQ,aAAA9B,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IACA,IAAAiT,iBAAAjT,QAAA;IAUA,IAAAkT,0BAAA;MAcE,SAAAA;QAHQhR,KAAA2Q,WAAA;QACA3Q,KAAAiR,mBAAA;QAGNjR,KAAAkR,SAAAH,eAAAI;;MAZF7M,OAAAC,eAAAyM,yBAAA,YAAA;QAAAxM,KAAA;UACExE,KAAAoR,cACEpR,KAAAoR,YAAA,IAAAJ;UAEF,OAAAhR,KAAAoR;;;;;MAiBFJ,wBAAA/Q,UAAAyQ,SAAA,SAAAlI;QACE,IAAA6I,MAAArR,KAAA2Q,SAAAW,QAAA9I;QACA,KAAA,MAAA6I,KACErR,KAAA2Q,SAAAY,OAAAF,KAAA,SACK;UACLrR,KAAA2Q,SAAAzR,UAAAc,KAAAkR,OAAAM,YACExR,KAAA2Q,SAAAc;UAEFzR,KAAA2Q,SAAAxR,KAAAqJ;;QAEF,OAAAxI,KAAA4Q;;MAGFI,wBAAA/Q,UAAA2Q,cAAA;QACE,OAAAtC,eAAAtO,KAAA2Q;;MAQFK,wBAAA/Q,UAAA4Q,UAAA;QAAA,IAAA/O,QAAA9B;QACE,IAAA2G,UAAA;QACA3G,KAAA2Q,SAAAzM,QAAA,SAAAsE;;UACE,IAAAnH,MAAA,UAAAmB,KAAAV,MAAAoP,OAAAQ,WAAAlJ,aAAA,MAAAhG,KAAAA,KAAA;UACAmE,QAAA6B,MAAAnH;;QAEFrB,KAAAiR,mBAAAtK;QACA/G,WAAAuD,SAAAC,KAAAvD,aAAAwD,WAAA+G,kBAAAzD;;MAGFqK,wBAAA/Q,UAAAmQ,QAAA;QACEpQ,KAAA2Q,WAAA;QACA3Q,KAAAiR,mBAAA;;MAGFD,wBAAA/Q,UAAA4G,sBAAA;QACE,OAAA8K,SAAA,IAAA3R,KAAAiR;;MA7DaD,wBAAAI,YAAA;MA+DjB,OAAAJ;KAhEA;IAAarR,QAAAqR,0BAAAA;IAkEArR,QAAAiH,0BAAAoK,wBAAAY;;;;;;;;;;;;;;;IC5Eb,IAAA/R,eAAA/B,QAAA;IAOA,IAAA+T,iBAAA;MAME,SAAAA,eAAA1M,KAGU2M;QAFA9R,KAAAmF,MAAAA;QAEAnF,KAAA8R,WAAAA;QAPF9R,KAAA+R,WAAA;QAEA/R,KAAAgS,WAAA;;MAYRH,eAAA5R,UAAAgS,WAAA,SAAAC;QAEElS,KAAA+R,SAAAG,MAAA1J,MAAA0J;;MAQFL,eAAA5R,UAAAuL,WAAA,SAAAhD;QACE,IAAA0J,QAAAlS,KAAA+R,SAAAvJ;QACA,KAAA0J,OAEE;QAIFlS,KAAAgS,YAAAhS,KAAAgS,aAAAxJ,MACExI,KAAAsL;QAIF,IAAA,mBAAAtL,KAAA8R,YACE;QAIF,KAAAI,MAAAC,eACE;QAIFD,MAAAlP;QACAhD,KAAAgS,WAAAxJ;QAEAxI,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAA+O,kBAAA5J;QACAhI,QAAA6R,MAAA,mCAAArS,KAAAmF,IAAAmN,iBAAAzS,aAAAwD,WAAA+O;;MAUFP,eAAA5R,UAAAsS,UAAA,SAAA/J;QACE,IAAA0J,QAAAlS,KAAA+R,SAAAvJ;QACA,KAAA0J,OAEE;QAEF,IAAAA,MAAAvL,WAAA,GAEE;QAGFuL,MAAAvL;QACA3G,KAAAgS,aAAAxJ,OACExI,KAAAgS,WAAA;QAGFhS,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAA2G,iBAAAxB;;MAMFqJ,eAAA5R,UAAAqL,SAAA;QACE,SAAAtL,KAAAgS,aACEhS,KAAAgS,WAAA;QAGFhS,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAA6G;;MAQF2H,eAAA5R,UAAAoM,aAAA,SAAA7D;QACE,IAAA0J,QAAAlS,KAAA+R,SAAAvJ;QACA,OAAA0J,QAAAA,MAAAvL,UAAA;;MAEJ,OAAAkL;KAtGA;IAAalS,QAAAkS,iBAAAA;;;;;;;;;;;;;ICTb,IAAAjS,aAAA9B,QAAA;IACA,IAAA0U,mBAAA1U,QAAA;IAIA,IAAA6H,oBAAA7H,QAAA;IAQA,SAAA2U,mBAAA1S,OAAA2S,cAAAZ,UAAAnL;MAMEhH,QAAA0L,iBAAA,IAAAmH,iBAAAX,eAAAjS,WAAAuD,UAAA2O;MACA,IAAA/E,UAAA,SAAAxL;;QACE,IAAAoR,QAAAD;QACA,OAAA,UAAAlQ,KAAAmQ,MAAApR,EAAA9C,YAAA,MAAA+D,UAAA,IAAAA,GAAAjB,EAAA3C;;MAEF+G,kBAAA0C,gBAAAnE,QAAA,SAAAkE;;QACE,IAAA8J,QAAA9J,IAAAyE,QAAA;UACE9M,OAAAA;UACAgN,SAAAA;UACA5H,KAAAvF,WAAAuD;UACAkI,gBAAA1L,QAAA0L;UACA1E,SAAA,UAAAnE,KAAAmE,QAAAyB,IAAAI,aAAA,MAAAhG,KAAAA,KAAA;;QAEF7C,QAAA0L,eAAA4G,SAAAC;;;IAnBJvS,QAAA8S,qBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICbA,IAAA9M,oBAAA7H,QAAA;IAGA,IAAA8U,kBAAA;IAQA,SAAAC;MAKE,IAAAD,iBACE,OAAAA;MAUFA,kBAAA;QACE7S,OAAAJ,QAAAmT;QACAC,eAAApT,QAAAqT;;MAGF,OAAAJ;;IAMF,SAAAK;MACEL,kBAAA;;IADFjT,QAAAsT,mBAAAA;IAQA,SAAAC;MAIE,OAAA,IAAA5N,QAAA,SAAA6N;QACEtS,GAAAgI,UAAAC,KAAA,qBAAAjI,GAAAuS,WAAA,SAAApK,KAAAqK;UACE,KAAArK,OAAAqK,OAAA;YACE,IAAAC,SAAAD,MAAAE;YAKA,IAAAxP,SAAA;cACEhE,OAAA4R,SAAAA,SAAA,IAAAhS,QAAAmT,eAAAQ,OAAAvT;cACAgT,eAAApB,SAAAA,SAAA,IAAAhS,QAAAqT,uBAAAM,OAAAP;;YAIFH,kBAAA7O;YACAoP,QAAApP;iBACK;YAEL,IAAAA,SAAA;cACEhE,OAAAJ,QAAAmT;cACAC,eAAApT,QAAAqT;;YAEFJ,kBAAA7O;YACAoP,QAAApP;;;;;IA3BRpE,QAAAuT,sBAAAA;IAwDavT,QAAAmT,eAAA;MACXjU,MAAA;MACAH,MAAA;MACA8U,WAAA;MACAC,YAAA;MACA1U,QAAA,EAAA,OAAA,QAAA,SAAA,UAAA;MACA2U,gBAAA;MACAC,cAAA;QACEhV,KAAA;QACAiV,KAAA;QACAC,MAAA;QACAC,OAAA;;;IAOJ,SAAAC;MACE,IAAAT,SAAAT;MACA,OAAAS,OAAAvT;;IAFFJ,QAAAoU,kBAAAA;IAcapU,QAAAqT,uBAAA;MACXxB,UAAA;MACAE,YAAApN,OAAA0P,YAAArO,kBAAA0C,gBAAApG,IAAA,SAAAsG;QAAA,OAAA,EAAAA,EAAAC,IAAA;;;IAIF,SAAA2I;MACE,IAAAmC,SAAAT;MACA,IAAAoB,OAAAtC,SAAA,IAAA2B,OAAAP;MAGA;QACE,IAAAmB,UAAA,uBAAAC,UAAAA,OAAAC,gBAEGC,WACED;QACL,IAAAF,WAAA,sBAAAA,QAAAI,SAAA;UACE,IAAAC,MAAAL,QAAAI,QAAA;UACA,IAAAC,KAAA;YACE,IAAAC,OAAAC,KAAAC,MAAAH;YACA,oBAAAC,KAAAhD,aACEyC,KAAAzC,WAAAgD,KAAAhD;YAEFgD,KAAA9C,cACEpN,OAAA6C,QAAAqN,KAAA9C,YAAAxN,QAAA,SAAA1B;cAA0C,IAAAgG,KAAAhG,GAAA,IAAAmS,MAAAnS,GAAA;mBACxCoS,MAAAX,KAAAvC,WAAAlJ,QACEyL,KAAAvC,WAAAlJ,MAAAmM;;;;QAMV,OAAAhF;QACAnP,QAAAyG,KAAA,oDAAA0I;;MAGF,OAAAsE;;IA9BFtU,QAAAwR,oBAAAA;;;;;;;;;;;;;IC3IA,IAAA0D,2BAAA/W,QAAA;IAKa6B,QAAAwD,WAAA,IAAA0R,yBAAAC;;;;;;;;;;;;;ICFAnV,QAAA0D,aAAA;MACX0R,WAAA;MACAzK,aAAA;MACA0K,eAAA;MACAC,cAAA;MACAC,eAAA;MACAC,aAAA;MACAC,UAAA;MACAC,aAAA;MACAC,UAAA;MACAC,WAAA;MACAC,UAAA;MACAC,WAAA;MACAC,YAAA;MACAC,SAAA;MACAC,UAAA;MACAxD,kBAAA;MACApI,iBAAA;MACAE,kBAAA;MACAE,kBAAA;MACAyL,kBAAA;MACAC,uBAAA;MACAC,cAAA;MACAC,YAAA;MACAC,aAAA;MACAC,kBAAA;MACAC,gBAAA;MACAC,aAAA;MACAC,sBAAA;MACAC,aAAA;MACAhT,YAAA;MACAiT,eAAA;MACAC,UAAA;MACAC,eAAA;MACAC,kBAAA;MACAC,iBAAA;MACAC,oBAAA;MAEAC,aAAA;MAEAC,YAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICxCF,IAAAC,sBAAA,SAAA7Q;MAAyCC,UAAA4Q,qBAAA7Q;MAAzC,SAAA6Q;;;MAGEA,oBAAA9W,UAAA+W,OAAA,SAAAC,OAAAC;QAAA,IAAApV,QAAA9B;QACE,IAAA8E,WAAA;UAAkB,IAAAqS,OAAA;UAAA,KAAA,IAAA5U,KAAA,GAAAA,KAAA8D,UAAAnH,QAAAqD,MAAA4U,KAAA5U,MAAA8D,UAAA9D;UAChBT,MAAAgJ,IAAAmM,OAAAnS;UACAoS,SAAA9Q,WAAA,GAAA+Q;;QAEFnX,KAAA+J,GAAAkN,OAAAnS;;MAEJ,OAAAiS;KAVA,CAUAlW,GAAAuW;IAVazX,QAAAoX,sBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICJb,IAAA/Y,SAAAF,QAAA;IACA,IAAAuZ,gBAAAvZ,QAAA;IAOA,IAAAwZ,eAAA;MAAA,SAAAA;MAkBSA,aAAAC,YAAA,SAAAlX,MAAAmX;QACLF,aAAAG,QAAApX,QAAAmX;;MAIKF,aAAAI,WAAA,SAAAlQ;QACL8P,aAAAK,QAAAnQ;;MAQW8P,aAAAM,aAAA,SAAAvX,MAAAwX;;QAAgD,OAAAxS,UAAArF,WAAA,GAAAsF,SAAA;;;;;cACrDkS,SAAAF,aAAAG,QAAApX;cACAyX,WAAAR,aAAAS,UAAA1X;cACF,MAAAmX,QAAA,OAAA,EAAA,GAAA;cACE,KAAAM,UAAA,OAAA,EAAA,GAAA;cACF,OAAA,EAAA,GAAA,IAAAxS,QAAA,SAAA0S;gBAAA,OAAAC,WAAAD,GAAAF;;;;cAAAI,GAAAzS;;;aAEF,KAAA;cAAA,OAAA,EAAA;;;cAEI+B,OAAA3G,GAAA4G,YAAA+P;cACAW,SAAAb,aAAAK,UAAA,UAAA1P,MAAAzF,KAAA3B,GAAAuX,UAAAC,kBAAA,MAAApQ,UAAA,IAAAA,GAAAmE,KAAA5J;cACN,SAAA2V,eAAA,MAAAA,cAAA,IAAAA,OAAAxQ,SAAAH;cACAqQ,YACErQ,KAAAI,YAAAiQ;cAEFrQ,KAAA8Q,SAAA;cACM1G,WAAApK,KAAAM,aAAAuP,cAAAkB,gBAAA/Q,KAAAgD,aAAA6M,cAAAkB;cAEN,MAAA3G,SAAA4G,gBAAAtZ,WACE0S,SAAA4G,kBAAAhR,KAAAiR,wBAAA5X,GAAA6X;cAIF,MAAA9G,SAAA+G,WAAAzZ,WACE0S,SAAA+G,aAAAnR,KAAAiR,wBAAA5X,GAAA+X;cAEEC,WAAA;cACEC,OAAAlH,SAAAkH,OAAAC,KAAA;gBACJF,WAAA;;cAEE,KAAAf,UAAA,OAAA,EAAA,GAAA;cACF,OAAA,EAAA,GAAAxS,QAAA0T,KAAA,EACEF,MACA,IAAAxT,QAAA,SAAA0S;gBAAA,OAAAC,WAAAD,GAAAF;;;;cAFFI,GAAAzS;eAIAoT,aAAA,UAAAlQ,KAAA9H,GAAAoY,iBAAA,MAAAtQ,UAAA,IAAAA,GAAAyD,KAAAvL,IAAA2G,UACEA,KAAA0R;;;aAGF,KAAA;cAAA,OAAA,EAAA,GAAAJ;;;cAAAZ,GAAAzS;;;;;;;;;MArEoB6R,aAAAG,UAAA;MAGTH,aAAAK,QAAA;MAGSL,aAAAS,aAAAvV,KAAA,IACtBA,GAAAxE,OAAAsC,SAAAU,aAAA,KACAwB,GAAAxE,OAAAsC,SAAAC,YAAA;MACAiC,GAAAxE,OAAAsC,SAAAS,YAAA,KACAyB;MA8DJ,OAAA8U;KA1EA;IAAa3X,QAAA2X,eAAAA;;;;;;;;;;;;;;ICRb,IAAA6B,aAAArb,QAAA;IAEA,SAAAsb,iBAAA5R,MAAA6R,KAAAhK,OAAAiK;WAGE,MAAAjK,UAAAA,QAAA;MAGA,IAAAkK,OAAAva,KAAAsC,IAAAkG,KAAA/I,IAAA4a,IAAA5a;MACA,IAAA+a,MAAAD,OAAA;MACA,IAAAE,QAAAjS;MACA,sBAAAiS,MAAA1N,kBAAgD0N,MAAA1N;MAEhD,IAAA2N,WAAAlS,KAAAM,aAAAqR,WAAA1O;MACA,SAAAiP,iBAAA,MAAAA,gBAAA,IAAAA,SAAAC;MAEA,IAAAC,UAAA;MACAvK,QAAA,KAAeuK,QAAAza,KAAA0B,GAAAgZ,UAAAxK;MACfuK,QAAAza,KAAA0B,GAAAiZ,OAAAN,KAAAH,IAAAza,GAAAya,IAAA5a;MAEA8a,OAAA,KACEK,QAAAza,KAAA0B,GAAAkZ,SAAA;;QAEI,IAAAL,WAAAlS,KAAAM,aAAAqR,WAAA1O;QACA,IAAAuP,SAAA,UAAAxX,KAAA,SAAAkX,iBAAA,MAAAA,gBAAA,IAAAA,SAAAO,oBAAA,MAAAzX,KAAAA,KAAAgF;QACA,IAAA0S,OAAAF,OAAAG;QACAH,OAAAI,eAAAvZ,GAAAwZ,GAAA,IAAA;QACA,IAAAC,OAAAzZ,GAAA0Z,SAAA1Z,GAAA2Z,QAAA,IAAA,GAAA,KAAA3Z,GAAA2Z,QAAA,IAAA,GAAA,IAAA3Z,GAAAkZ,SAAA;UAAA,OAAAC,OAAAI,eAAAF;;QAKAF,OAAAS,UAAAH;;MAKNhB,cACEM,QAAAza,KAAA0B,GAAAkZ,SAAA;QAEIT;;MAINM,QAAAza,KAAA0B,GAAAkZ,SAAA;QAEI,SAAAL,iBAAA,MAAAA,gBAAA,IAAAA,SAAAgB;;MAMJlT,KAAAiT,UAAA5Z,GAAA0Z,SAAAnU,MAAAvF,IAAA+Y;;IAlDFja,QAAAyZ,mBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICGA,IAAAvZ,eAAA/B,QAAA;IAQA,IAAA6c,cAAA;MACE,SAAAA,YAAA5a,OAAAoF,KAAAyV;QACU5a,KAAAD,QAAAA;QACAC,KAAAmF,MAAAA;QACAnF,KAAA4a,UAAAA;;MAGVtW,OAAAC,eAAAoW,YAAA1a,WAAA,OAAA;QAAAuE,KAAA;UAEE,OAAAxE,KAAAD,MAAA5B;;;;;MAGIwc,YAAA1a,UAAAmF,UAAA;QAAW,OAAAC,UAAArF,WAAA,GAAAsF,SAAA;;;YACf,IAAA,MAAAtF,KAAA4a,QAAA1b,QACE,MAAA,IAAAyC,MAAA;YAGF3B,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAgS,aAAArV,KAAA4a;YAEMC,aAAA;YACAnc,OAAAsB,KAAA7B,IAAAO;YAEN,KAAA6D,KAAA,GAAAC,KAAAxC,KAAA4a,SAAArY,KAAAC,GAAAtD,QAAAqD,MAAA;cAAW3D,IAAA4D,GAAAD;cACHuY,OAAA;cAEN,KAAAC,MAAArc,OAAA,GAAAqc,OAAA,GAAAA,OAAA;gBACQ3Y,IAAApC,KAAAD,MAAAsC,OAAA,IAAAxB,GAAAC,KAAAlC,GAAAmc;gBACN3Y,KACE0Y,KAAA3b,KAAAiD;;cAIA3D,IAAAC,OAAA;cACJ,KAAAuJ,KAAA,GAAA+S,SAAAF,MAAA7S,KAAA+S,OAAA9b,QAAA+I,MAAA;gBAAW7F,IAAA4Y,OAAA/S;gBACTjI,KAAAD,MAAA2E,QAAA,IAAA7D,GAAAC,KAAAlC,GAAAH,IAAA2D;gBACA3D;;cAGF,MAAAA,KAAA,GAAAA,KAAA;gBACQ8C,IAAA,IAAAV,GAAAC,KAAAlC,GAAAH;gBACNuB,KAAAD,MAAA2E,QAAAnD,GAAA;gBACAsZ,WAAA1b,KAAAoC;;;YAIJvB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAiS,UAAAuF;;;;;MAEJ,OAAAF;KA/CA;IAAahb,QAAAgb,cAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICVb,IAAA3c,SAAAF,QAAA;IAEA,IAAA+B,eAAA/B,QAAA;IAMA,IAAAmd,cAAA;MACE,SAAAA,YAAAlb,OAAAoF,KAAA+K;QACUlQ,KAAAD,QAAAA;QACAC,KAAAmF,MAAAA;QACAnF,KAAAkQ,QAAAA;;MAGV5L,OAAAC,eAAA0W,YAAAhb,WAAA,OAAA;QAAAuE,KAAA;UAEE,OAAAxE,KAAAD,MAAA5B;;;;;MAGI8c,YAAAhb,UAAAmF,UAAA;QAAW,OAAAC,UAAArF,WAAA,GAAAsF,SAAA;;;YACf,IAAA,MAAAtF,KAAAkQ,MAAAhR,QACE,MAAA,IAAAyC,MAAA;YAGF3B,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAA8R,aAAAnV,KAAAkQ;YAEA,KAAA3N,KAAA,GAAAC,KAAAxC,KAAAkQ,OAAA3N,KAAAC,GAAAtD,QAAAqD,MAAA;cAAWhB,IAAAiB,GAAAD;cACT,KAAAvC,KAAAD,MAAAyB,SAAAD,IAA6B;cACvBzC,QAAAkB,KAAAkb;cACNlb,KAAAD,MAAA2E,QAAAnD,GAAAvD,OAAAoB,YAAAC,aAAAP;;YAGFkB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAA+R;;;;;MAGM6F,YAAAhb,UAAAib,cAAA;QACN,IAAAnc,SAAAiB,KAAA7B,IAAAY;QACA,IAAAsS,MAAArS,KAAAC,MAAAD,KAAAmc,WAAApc,OAAAG;QACA,OAAAH,OAAAsS;;MAEJ,OAAA4J;KAjCA;IAAatb,QAAAsb,cAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICXP,IAAAzY,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAEN,IAAApG,aAAA9B,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IACA,IAAAsd,wBAAAtd,QAAA;IACA,IAAAqb,aAAArb,QAAA;IAEA,IAAAud,iBAAAvd,QAAA;IACA,IAAAwd,kBAAAxd,QAAA;IAGA,IAAAyd,iBAAA,SAAArV;MAA4CC,UAAAoV,gBAAArV;MAA5C,SAAAqV;QAAA,IAAAzZ,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAGE8B,MAAA0Z,iBAAA;QAGA1Z,MAAA2Z,aAAA;QAKQ3Z,MAAA4Z,UAAA;;;MAERH,eAAAtb,UAAA+N,SAAA;QACE,IAAA2N,YAAA3b,KAAA8H,aAAAsT,sBAAA3Q;QACAzK,KAAAD,QAAA4b,UAAAC;QACA5b,KAAAyb,aAAAzb,KAAAwH,KAAAU,eAAA;QACAlI,KAAA6b,YAAAF,UAAAE;QACAjc,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAA8R,aAAAnV,KAAA8b,eAAA9b;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAA+R,UAAApV,KAAA+b,YAAA/b;;MAQMub,eAAAtb,UAAA6b,gBAAA,SAAA5L;QACNlQ,KAAA6b,YAAA7b,KAAA8H,aAAAsT,sBAAA3Q,SAAAoR;QACA7b,KAAA0b,UAAAxL;QAEA,IAAA8L,QAAA;QACA,KAAA,IAAA3U,IAAA,GAAAA,IAAA6I,MAAAhR,QAAAmI,KAAA;UACE,IAAA9F,IAAA2O,MAAA7I;UACA2U,MAAAza,EAAA3C,OAAiBod,MAAAza,EAAA3C,KAAA;UACjBod,MAAAza,EAAA3C,GAAAO,KAAAoC;;QAGF,IAAA0a,YAAA;QAEA,KAAA,IAAA1Z,KAAA,GAAAC,KAAA8B,OAAAyC,KAAAiV,QAAAzZ,KAAAC,GAAAtD,QAAAqD,MAAA;UAAK,IAAA2Z,SAAA1Z,GAAAD;UACH,IAAA4Z,OAAAH,MAAAI,SAAAF,QAAA;UACAC,KAAAE,KAAA,SAAAC,GAAA/T;YAAA,OAAAA,EAAA9J,IAAA6d,EAAA7d;;UACA,KAAA,IAAA2Q,QAAA,GAAAA,QAAA+M,KAAAjd,QAAAkQ,SAAA;YACE,IAAA7N,IAAA4a,KAAA/M;YACA,IAAAmN,OAAA1b,GACG4G,YAAAzH,KAAAwb,gBACA1T,aAAAqR,WAAA1O;YAEH8R,KAAA/U,KAAA2Q,SAAAnY,KAAAyb;YACAc,KAAA/U,KAAAR,SAAA;YACAuV,KAAA/U,KAAAmH,UAAA;YAEA,IAAA3L,QAAAsY,gBAAAkB,oBAAAjb,EAAA3C,IAAA,GAAAoB,KAAAD;YACAwc,KAAA/U,KAAAI,YAAA5E;YACA,IAAAqW,MAAAiC,gBAAAkB,oBAAAjb,EAAA3C,GAAA2C,EAAA9C,GAAAuB,KAAAD;YACAsb,eAAAjC,iBAAAmD,KAAA/U,MAAA6R,KAAAjK,QAAA6M;YAEAM,KAAA/U,KAAA8Q,SAAAtY,KAAAD,MAAArB,OAAA6C,EAAA9C,IAAA;YACAuB,KAAA6b,UAAAta,EAAA9C,GAAA8C,EAAA3C,KAAA2d;;;;MAKEhB,eAAAtb,UAAA8b,aAAA;QACN,KAAA,IAAA1U,IAAA,GAAAA,IAAArH,KAAA0b,QAAAxc,QAAAmI,KAAA;UACE,IAAA9F,IAAAvB,KAAA0b,QAAArU;UACA,IAAAkV,OAAAvc,KAAA6b,UAAAta,EAAA9C,GAAA8C,EAAA3C;UACA2d,QACEA,KAAAnW,MAAApG,KAAAD,MAAAsC,OAAAd;;QAGJvB,KAAA0b,UAAA;;MAMKH,eAAAtb,UAAAmQ,QAAA,SAAArQ,OAAA8b;QACL7b,KAAAD,QAAAA;QACAC,KAAA6b,YAAAA;QACA7b,KAAA0b,UAAA;;MA9EFlP,WAAA,EADCxG,SAAAnF,GAAA4L,WACgC8O,eAAAtb,WAAA,uBAAA;MAGjCuM,WAAA,EADCxG,SAAAnF,GAAAkK,SAC0BwQ,eAAAtb,WAAA,mBAAA;MANRsb,iBAAA/O,WAAA,EADpBzG,aACoBwV;MAmFrB,OAAAA;KAnFA,CAAA1a,GAAA6L;IAAqB/M,QAAA8K,UAAA8Q;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICXf,IAAA/Y,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAGN,IAAAyW,mBAAA3e,QAAA;IACA,IAAAiT,iBAAAjT,QAAA;IACA,IAAAqb,aAAArb,QAAA;IACA,IAAA4e,uBAAA5e,QAAA;IACA,IAAA6e,mBAAA7e,QAAA;IACA,IAAAwd,kBAAAxd,QAAA;IACA,IAAA8B,aAAA9B,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IACA,IAAA8e,iBAAA9e,QAAA;IAGA,IAAA+e,sBAAA,SAAA3W;MAAiDC,UAAA0W,qBAAA3W;MAAjD,SAAA2W;QAAA,IAAA/a,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAGE8B,MAAA0Z,iBAAA;QAGA1Z,MAAA2Z,aAAA;QASA3Z,MAAA+Z,YAAA;QAGQ/Z,MAAAgb,mBAAA;;;MAPRD,oBAAA5c,UAAA2b,WAAA;QACE,OAAA5b,KAAAD;;MAeF8c,oBAAA5c,UAAA+N,SAAA;QAEE,IAAA7P,MAAA4S,eAAAgD;QAEA/T,KAAAD,QAAA,IAAA0c,iBAAAxe,iBAAA8e,SAAA5e;QAEA6B,KAAAgd;QACAJ,eAAAtF,aAAAI,SAAA1X,KAAAyb;QAEA,IAAAwB,OAAAjd,KAAAwH,KAAAgD,aAAAkS,qBAAAjS;QACAwS,KAAAxB,aAAAzb,KAAAyb;QACA,IAAApX,OAAArE,KAAAwH,KAAAgD,aAAAmS,iBAAAlS;QACApG,KAAAmX,iBAAAxb,KAAAwb;QACAnX,KAAAoX,aAAAzb,KAAAyb;QACA7b,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAwS,kBAAA7V,KAAAkd,oBAAAld;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAyS,uBAAA9V,KAAAmd,yBAAAnd;QAKAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAA6G,kBAAAlK,KAAAod,wBAAApd;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAmT,UAAAxW,KAAAqd,YAAArd;;MAQM6c,oBAAA5c,UAAA+c,gBAAA;QACN,KAAA,IAAAhF,IAAA,GAAAA,IAAAhY,KAAAD,MAAArB,MAAAsZ,KAAA;UACEhY,KAAA6b,UAAA7D,KAAA;UACA,KAAA,IAAAnT,IAAA,GAAAA,IAAA7E,KAAAD,MAAAlB,MAAAgG,KAAA;YACE,IAAAyY,WAAAtd,KAAAD,MAAAsC,OAAA,IAAAxB,GAAAC,KAAA+D,GAAAmT;YACA,IAAAxQ,OAAA3G,GAAA4G,YAAAzH,KAAAwb;YACAhU,KAAA2Q,SAAAnY,KAAAyb;YAEAjU,KAAA4S,eAAAvZ,GAAAwZ,GAAA,GAAA;YAEA7S,KAAAI,YAAA0T,gBAAAkB,oBAAA3X,GAAAmT,GAAAhY,KAAAD;YAEAyH,KAAA8Q,SAAAtY,KAAAD,MAAArB,OAAAsZ,IAAA;YAEA,IAAAuE,OAAA/U,KAAAM,aAAAqR,WAAA1O;YACA8R,KAAAnW,MAAAkX;YACAf,KAAAgB,WAAA1c,GAAAwZ,GAAAxV,GAAAmT;YACAhY,KAAA6b,UAAA7D,GAAAnT,KAAA0X;;;;MASCM,oBAAA5c,UAAAud,aAAA;QAEL,IAAArf,MAAA4S,eAAAgD;QACA,IAAA0J,WAAA,IAAAhB,iBAAAxe,iBAAA8e,SAAA5e;QAEA,KAAA,IAAAM,IAAA,GAAAA,IAAAN,IAAAO,MAAAD,KACE,KAAA,IAAAG,IAAA,GAAAA,IAAAT,IAAAU,MAAAD,KAAA;UACE,IAAAuB,OAAAsd,SAAApb,OAAA,IAAAxB,GAAAC,KAAAlC,GAAAH;UACAuB,KAAAD,MAAA2E,QAAA,IAAA7D,GAAAC,KAAAlC,GAAAH,IAAA0B;;QAKJH,KAAAyb,WAAAvU;QACAlH,KAAA6b,YAAA;QACA7b,KAAAgd;QAGA,IAAAC,OAAAjd,KAAA8H,aAAA4U,qBAAAjS;QACA,SAAAwS,aAAA,MAAAA,YAAA,IAAAA,KAAA7M,MAAApQ,KAAAD,OAAAC,KAAA6b;QACA,IAAAxX,OAAArE,KAAA8H,aAAA6U,iBAAAlS;QACA,SAAApG,aAAA,MAAAA,YAAA,IAAAA,KAAA+L,MAAApQ,KAAAD,OAAAC,KAAA6b;QACA7b,KAAA8c,mBAAA;;MAMFD,oBAAA5c,UAAAyd,QAAA,SAAAtd;QACE,IAAAkd,WAAAtd,KAAAD,MAAAsC,OAAAjC;QACA,IAAAoH,OAAA3G,GAAA4G,YAAAzH,KAAAwb;QACAhU,KAAA2Q,SAAAnY,KAAAyb;QACAjU,KAAA4S,eAAAvZ,GAAAwZ,GAAA,GAAA;QACA7S,KAAAI,YAAA0T,gBAAAkB,oBAAApc,IAAAxB,GAAAwB,IAAA3B,GAAAuB,KAAAD;QACAyH,KAAA8Q,SAAAtY,KAAAD,MAAArB,OAAA0B,IAAA3B,IAAA;QACA,IAAA8d,OAAA/U,KAAAM,aAAAqR,WAAA1O;QACA8R,KAAAnW,MAAAkX;QACAf,KAAAgB,WAAA1c,GAAAwZ,GAAAja,IAAAxB,GAAAwB,IAAA3B;QACAuB,KAAA6b,UAAAzb,IAAA3B,GAAA2B,IAAAxB,KAAA2d;QACA,OAAAA;;MAGMM,oBAAA5c,UAAAid,qBAAA,SAAA1a;QAAqB,IAAAqV,WAAArV,GAAAqV;aAG3BA;;MAGMgF,oBAAA5c,UAAAkd,0BAAA,SAAA3a;;QACN,IAAAgG,KAAAhG,GAAAgG,IAAAmV,QAAAnb,GAAAmb,OAAAvd,MAAAoC,GAAApC;QAQA,IAAA,eAAAoI,IAAuB;QACvB,IAAA,YAAAmV,OAAA;UACE3d,KAAAod;UACA,IAAAb,OAAA,UAAAtU,KAAAjI,KAAA6b,UAAAzb,IAAA3B,YAAA,MAAAwJ,UAAA,IAAAA,GAAA7H,IAAAxB;UACA,IAAA2d,MAAA;YACEA,KAAA/U,KAAAkH,SAAA,KAAA;YACA1O,KAAA8c,mBAAAP;;eAIFvc,KAAAod;;MAIIP,oBAAA5c,UAAAmd,yBAAA;QACN,IAAApd,KAAA8c,kBAAA;UACE9c,KAAA8c,iBAAAtV,KAAAkH,SAAA,GAAA;UACA1O,KAAA8c,mBAAA;;;MAIID,oBAAA5c,UAAAod,aAAA,SAAAf,GAAA/T;QAAR,IAAAzG,QAAA9B;;QACE,IAAA4d,QAAA,UAAApb,KAAAxC,KAAA6b,UAAAS,EAAA7d,YAAA,MAAA+D,UAAA,IAAAA,GAAA8Z,EAAA1d;QACA,IAAAif,QAAA,UAAA5V,KAAAjI,KAAA6b,UAAAtT,EAAA9J,YAAA,MAAAwJ,UAAA,IAAAA,GAAAM,EAAA3J;QACA,KAAAgf,UAAAC,OAAsB;QACtB,IAAAC,QAAAF,MAAApW;QACA,IAAAuW,QAAAF,MAAArW;QACA3G,GAAAoL,MAAA6R,OACG5R,GAAA,IAAA;UAAAC,OAAA;WACAC,KAAA;UAAA,OAAAwR,MAAAxX,MAAAtE,MAAA/B,MAAAsC,OAAAia;WACApQ,GAAA,IAAA;UAAAC,OAAA;WACAnJ;QACHnC,GAAAoL,MAAA8R,OACG7R,GAAA,IAAA;UAAAC,OAAA;WACAC,KAAA;UAAA,OAAAyR,MAAAzX,MAAAtE,MAAA/B,MAAAsC,OAAAkG;WACA2D,GAAA,IAAA;UAAAC,OAAA;WACAnJ;;MAMG6Z,oBAAA5c,UAAA+d,kBAAA;QACN,IAAA7f,MAAA4S,eAAAgD;QAGA,IAAAkK,gBAAA,IAAApd,GAAAkK,KAAA;QACAkT,cAAA9F,SAAAnY,KAAAyb;QACAwC,cAAA3F,SAAA;QAGA,KAAA,IAAAzT,IAAA,GAAAA,KAAA7E,KAAAD,MAAAlB,MAAAgG,KAAA;UACE,IAAAqZ,OAAA,IAAArd,GAAAkK,KAAA;UACAmT,KAAA/F,SAAA8F;UAEA,IAAAE,WAAAD,KAAA1T,aAAA3J,GAAAud;UACAD,SAAAE,YAAA;UACAF,SAAAG,cAAAzd,GAAA8J,MAAA4T;UAEA,IAAAC,UAAA3Z,IAAA7E,KAAAD,MAAAlB,OAAA,KAAAV,IAAAqV;UACA,IAAAiL,SAAAze,KAAAD,MAAArB,OAAA,IAAAP,IAAAsV;UACA,IAAAiL,QAAA1e,KAAAD,MAAArB,OAAA,IAAAP,IAAAsV;UAEA0K,SAAArE,OAAA0E,QAAAC;UACAN,SAAAQ,OAAAH,QAAAE;UACAP,SAAAS;;QAIF,KAAA,IAAA5G,IAAA,GAAAA,KAAAhY,KAAAD,MAAArB,MAAAsZ,KAAA;UACE,IAAAkG,OAAA,IAAArd,GAAAkK,KAAA;UACAmT,KAAA/F,SAAA8F;UAEA,IAAAE,WAAAD,KAAA1T,aAAA3J,GAAAud;UACAD,SAAAE,YAAA;UACAF,SAAAG,cAAAzd,GAAA8J,MAAAkU;UAEA,IAAAJ,UAAAze,KAAAD,MAAArB,OAAA,IAAAsZ,KAAA7Z,IAAAsV;UACA,IAAA+K,UAAAxe,KAAAD,MAAAlB,OAAA,IAAAV,IAAAqV;UACA,IAAAsL,OAAA9e,KAAAD,MAAAlB,OAAA,IAAAV,IAAAqV;UAEA2K,SAAArE,OAAA0E,QAAAC;UACAN,SAAAQ,OAAAG,MAAAL;UACAN,SAAAS;;QAIF,KAAA,IAAA5G,IAAA,GAAAA,IAAAhY,KAAAD,MAAArB,MAAAsZ,KACE,KAAA,IAAAnT,IAAA,GAAAA,IAAA7E,KAAAD,MAAAlB,MAAAgG,KAAA;UACE,IAAAoK,QAAA,IAAApO,GAAAkK,KAAA;UACAkE,MAAAkJ,SAAA8F;UAEA,IAAAc,OAAA9P,MAAAzE,aAAA3J,GAAAsH;UACA4W,KAAAtV,SAAA5E,IAAA,MAAAmT;UACA+G,KAAAC,WAAA;UACAD,KAAAvX,KAAA1I,QAAA+B,GAAA8J,MAAAC;UAEA,IAAAxK,MAAAkb,gBAAAkB,oBAAA3X,GAAAmT,GAAAhY,KAAAD;UACAkP,MAAArH,YAAAxH,IAAAxB,IAAAT,IAAAqV,YAAA,GAAApT,IAAA3B,IAAAN,IAAAsV,aAAA;;;MA1ONjH,WAAA,EADCxG,SAAAnF,GAAA4L,WACgCoQ,oBAAA5c,WAAA,uBAAA;MAGjCuM,WAAA,EADCxG,SAAAnF,GAAAkK,SAC0B8R,oBAAA5c,WAAA,mBAAA;MANR4c,sBAAArQ,WAAA,EADpBzG,aACoB8W;MAoPrB,OAAAA;KApPA,CAAAhc,GAAA6L;IAAqB/M,QAAA8K,UAAAoS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICdrB,IAAAjd,aAAA9B,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IACM,IAAA0E,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAQN,IAAAiZ,kBAAA,SAAA/Y;MAAqCC,UAAA8Y,iBAAA/Y;MAArC,SAAA+Y;QAAA,IAAAnd,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAGE8B,MAAAod,aAAA;QAIApd,MAAAqd,WAAA;QAIArd,MAAAsd,gBAAA;QAIAtd,MAAAud,aAAA;QAGQvd,MAAAwd,6BAAAze,GAAA0e,KAAAC;QAGA1d,MAAA2d,QAAA,SAAAC;UAAA,OAAA5d,MAAA6d,KAAA,MAAAD;;QACA5d,MAAA8d,SAAA,SAAAF;UAAA,OAAA5d,MAAA6d,KAAA,OAAAD;;;;MAERT,gBAAAhf,UAAA+N,SAAA;QAEE,IAAAhO,KAAAkf,YAAA;UACElf,KAAAsf,6BAAAtf,KAAAkf,WAAArH,SAAAgI;UACA7f,KAAAkf,WAAAlY,SAAA;;QAIFhH,KAAAqf,eACErf,KAAAqf,WAAA7X,KAAAR,SAAA;;MAIJiY,gBAAAhf,UAAAoQ,WAAA;QACEzQ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAsS,SAAA3V,KAAAyf,OAAAzf;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAuS,UAAA5V,KAAA4f,QAAA5f;;MAGFif,gBAAAhf,UAAA6f,YAAA;QACElgB,WAAAuD,SAAA2H,IAAAjL,aAAAwD,WAAAsS,SAAA3V,KAAAyf;QACA7f,WAAAuD,SAAA2H,IAAAjL,aAAAwD,WAAAuS,UAAA5V,KAAA4f;;MASFX,gBAAAhf,UAAA0f,OAAA,SAAAI,KAAAL;QACE,IAAA1f,KAAAmf,UAAA;UACEnf,KAAAmf,SAAA1V,SAAAsW,MAAA,0CAAA;UACA/f,KAAAmf,SAAA3X,KAAA1I,QAAAihB,MAAAlf,GAAA8J,MAAAC,SAAA/J,GAAA8J,MAAA4T;;QAGFve,KAAAof,kBACEpf,KAAAof,cAAA3V,SAAAC,OAAAgW;QAIF1f,KAAAqf,eACErf,KAAAqf,WAAA7X,KAAAR,SAAA;QAIFhH,KAAAggB;;MAGMf,gBAAAhf,UAAA+f,wBAAA;QAAR,IAAAle,QAAA9B;QACE,KAAAA,KAAAkf,YAAsB;QAGtB,IAAAe,gBAAAjgB,KAAAsf,2BAAAO;QACAI,cAAAxhB,KAAA;QACAuB,KAAAkf,WAAAlY,SAAA;QACAhH,KAAAkf,WAAAtX,YAAAqY;QAGApf,GAAAoL,MAAAjM,KAAAkf,YACGhT,GAAA,IAAA;UAAA2L,UAAA7X,KAAAsf;WAAA;UAAAnQ,QAAA;WAKA/C,KAAA;UAECtK,MAAAoe;WAEDld;;MAGGic,gBAAAhf,UAAAigB,oBAAA;QAAR,IAAApe,QAAA9B;QACE,KAAAA,KAAAqf,YAAsB;QAGtBrf,KAAAqf,WAAA7X,KAAAR,SAAA;QACAhH,KAAAqf,WAAA7X,KAAA2E,QAAA;QAGAtL,GAAAoL,MAAAjM,KAAAqf,WAAA7X,MACG0E,GAAA,IAAA;UAAAC,OAAA;WAAA;UAAAgD,QAAA;WACAnM;QAGHhD,KAAAqf,WAAA7X,KAAAwP,KAAA,SAAA;UACExW,QAAA0I,IAAA;UAGApH,MAAAqe,0BAAA;YACEvgB,WAAAuD,SAAAC,KAAAvD,aAAAwD,WAAAiH;;;;MAOE2U,gBAAAhf,UAAAkgB,4BAAA,SAAArb;QAAR,IAAAhD,QAAA9B;QAEEA,KAAAqf,cACExe,GAAAoL,MAAAjM,KAAAqf,WAAA7X,MACG0E,GAAA,IAAA;UAAAC,OAAA;WAAA;UAAAgD,QAAA;WACA/C,KAAA;UACCtK,MAAAud,WAAA7X,KAAAR,SAAA;WAEDhE;QAIL,IAAAhD,KAAAkf,YAAA;UACE,IAAAkB,cAAApgB,KAAAsf,2BAAAO;UACAO,YAAA3hB,KAAA;UAEAoC,GAAAoL,MAAAjM,KAAAkf,YACGhT,GAAA,IAAA;YAAA2L,UAAAuI;aAAA;YAAAjR,QAAA;aACA/C,KAAA;YACCtK,MAAAod,WAAAlY,SAAA;YACAlC;aAED9B;;;MA3IPwJ,WAAA,EADCxG,SAAAnF,GAAAkK,SAC0BkU,gBAAAhf,WAAA,mBAAA;MAI3BuM,WAAA,EADCxG,SAAAnF,GAAAsH,UACyB8W,gBAAAhf,WAAA,iBAAA;MAI1BuM,WAAA,EADCxG,SAAAnF,GAAAsH,UAC8B8W,gBAAAhf,WAAA,sBAAA;MAI/BuM,WAAA,EADCxG,SAAAnF,GAAAkH,WAC4BkX,gBAAAhf,WAAA,mBAAA;MAflBgf,kBAAAzS,WAAA,EADZzG,QAAA,OACYkZ;MAiJb,OAAAA;KAjJA,CAAApe,GAAA6L;IAAa/M,QAAAsf,kBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICVb,IAAArf,aAAA9B,QAAA;IACA,IAAAuiB,qBAAAviB,QAAA;IACA,IAAAkH,gBAAAlH,QAAA;IACA,IAAAiH,iBAAAjH,QAAA;IACA,IAAAwiB,2BAAAxiB,QAAA;IACA,IAAAyiB,gBAAAziB,QAAA;IACA,IAAAsd,wBAAAtd,QAAA;IACA,IAAA0iB,uBAAA1iB,QAAA;IACA,IAAA4H,iBAAA5H,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IACA,IAAA2iB,uBAAA3iB,QAAA;IACA,IAAA+H,4BAAA/H,QAAA;IACA,IAAA4iB,oBAAA5iB,QAAA;IAEQ,IAAAiI,UAAAlF,GAAAiF,WAAAC;IAGR,IAAA4a,YAAA,SAAAza;MAAuCC,UAAAwa,WAAAza;MAAvC,SAAAya;QAAA,IAAA7e,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QACU8B,MAAA8e,MAAA;QAMA9e,MAAA+e,eAAA;QAGA/e,MAAAgf,gBAAA,SAAAlV;UACN9J,MAAA+e,eAAAjV;;QAGM9J,MAAAuI,qBAAA,SAAA1D;UACN,IAAA5G,QAAA+B,MAAA6Z,UAAAC;UACAlW,eAAA+M,mBAAA1S,OAAA;YAAA,OAAA+B,MAAA6Z,UAAAE;aAAA;YAAA,OAAA/Z,MAAA+e;aAAAla;UAMA,IAAA7E,MAAA8e,KAaE9e,MAAA8e,IAAAxQ,cAbF;YACEtO,MAAA8e,MAAA,IAAAP,mBAAAU,iBAAAnhB,WAAAuD,UAAApD,OAAA+B,MAAAkf,QAAAlf,MAAAmf,UAAAnf,MAAAof,eAAApf,MAAAqf,OAAA,KAAA;YAUArf,MAAA8e,IAAA5d;;;QAMIlB,MAAAyI,gBAAA;;UACNzI,MAAA6Z,UAAA6B;UACA,UAAAhb,KAAAV,MAAA8e,aAAA,MAAApe,UAAA,IAAAA,GAAA4N;;;;MAGFuQ,UAAA1gB,UAAA+C,QAAA;QACEhD,KAAA2b,YAAA3b,KAAAohB,uBAAAhG,sBAAA3Q;QACA,KAAAzK,KAAA2b,WAAA;UACEnb,QAAAmP,MAAA;UACA;;QAGF,IAAA5P,QAAAC,KAAA2b,UAAAC;QACA5b,KAAAghB,SAAA,IAAAhc,cAAAlF,YAAAC;QACAC,KAAAihB,WAAA,IAAAlc,eAAAS,aAAAzF,OAAAH,WAAAuD;QACAnD,KAAAkhB,gBAAA,IAAAZ,yBAAAe,uBAAA;QACArhB,KAAAmhB,QAAA,IAAAZ,cAAAe,YAAA,IAAA1hB,WAAAuD;QAGAnD,KAAAuhB,SAAA,IAAAb,kBAAAc,gBAAA5hB,WAAAuD;QAGA,IAAAqd,qBAAAiB,mBAAA7hB,WAAAuD,UAAApD;QAEAH,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAA0S,cAAA/V,KAAA8gB;QACAlhB,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAA+G,kBAAApK,KAAAqK;QACAzK,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAiH,aAAAtK,KAAAuK;QAGA,IAAAmX,WAAA1hB,KAAAohB,uBAAAX,qBAAAhW;QACA,IAAAiX,UACGA,SAAAla,KAAAR,SAAA,WACI;UAELnB,0BAAAe,wBAAAwJ;UACAvK,0BAAAe,wBAAAiK;;;MAIJ8P,UAAA1gB,UAAAsM,YAAA;QACE3M,WAAAuD,SAAA2H,IAAAjL,aAAAwD,WAAA0S,cAAA/V,KAAA8gB;QACAlhB,WAAAuD,SAAA2H,IAAAjL,aAAAwD,WAAA+G,kBAAApK,KAAAqK;QACAzK,WAAAuD,SAAA2H,IAAAjL,aAAAwD,WAAAiH,aAAAtK,KAAAuK;QACAvK,KAAAuhB,OAAArI;;MAlFiByH,YAAAnU,WAAA,EADpBzG,aACoB4a;MAoFrB,OAAAA;KApFA,CAAA9f,GAAA6L;IAAqB/M,QAAA8K,UAAAkW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICjBrB,IAAA/gB,aAAA9B,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IAEM,IAAA0E,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAON,IAAA2b,sBAAA,SAAAzb;MAAiDC,UAAAwb,qBAAAzb;MAAjD,SAAAyb;QAAA,IAAA7f,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAEE8B,MAAA8f,qBAAA;QAGA9f,MAAA+f,YAAA;;;MAEAF,oBAAA1hB,UAAA+C,QAAA;QACExC,QAAA0I,IAAA;QACAlJ,KAAA0G;QACA1G,KAAA8hB;;MAMMH,oBAAA1hB,UAAA6hB,kBAAA;QACN9hB,KAAA4hB,qBACE5hB,KAAA4hB,mBAAA5a,SAAA,OAEAxG,QAAAyG,KAAA;QAGFjH,KAAA6hB,YACE7hB,KAAA6hB,UAAA7a,SAAA,QAEAxG,QAAAyG,KAAA;;MAOI0a,oBAAA1hB,UAAAyG,sBAAA;QAEN9G,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAA+G,kBAAApK,KAAA+hB,aAAA/hB;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAiH,aAAAtK,KAAAuK,eAAAvK;;MAMM2hB,oBAAA1hB,UAAA8hB,cAAA,SAAApb;QACNnG,QAAA0I,IAAA,oDAAAvC;QACA3G,KAAAgiB;;MAGML,oBAAA1hB,UAAAsK,gBAAA;QACNvK,KAAAiiB;;MAMKN,oBAAA1hB,UAAAgiB,2BAAA;QACLjiB,KAAA4hB,uBACE5hB,KAAA4hB,mBAAA5a,SAAA;QAGFhH,KAAA6hB,cACE7hB,KAAA6hB,UAAA7a,SAAA;;MAOG2a,oBAAA1hB,UAAA+hB,oBAAA;QACLhiB,KAAA4hB,uBACE5hB,KAAA4hB,mBAAA5a,SAAA;QAGFhH,KAAA6hB,cACE7hB,KAAA6hB,UAAA7a,SAAA;;MAIJ2a,oBAAA1hB,UAAAsM,YAAA;QACE3M,WAAAuD,SAAA2H,IAAAjL,aAAAwD,WAAA+G,kBAAApK,KAAA+hB,aAAA/hB;QACAJ,WAAAuD,SAAA2H,IAAAjL,aAAAwD,WAAAiH,aAAAtK,KAAAuK,eAAAvK;;MA7EFwM,WAAA,EADCxG,SAAAnF,GAAAkK,SACkC4W,oBAAA1hB,WAAA,2BAAA;MAGnCuM,WAAA,EADCxG,SAAAnF,GAAAkK,SACyB4W,oBAAA1hB,WAAA,kBAAA;MALP0hB,sBAAAnV,WAAA,EADpBzG,aACoB4b;MAiFrB,OAAAA;KAjFA,CAAA9gB,GAAA6L;IAAqB/M,QAAA8K,UAAAkX;;;;;;;;;;;;;;ICQrB,IAAA9hB,eAAA/B,QAAA;IACA,IAAAE,SAAAF,QAAA;IAMA,IAAAijB,mBAAA;MAQE,SAAAA,iBAAA5b,KAAApF,OAAAihB,QAAAC,UAAAC,eAAAgB,aAAAC,aAAAC;aAQU,MAAAA,gBAAAA,cAAA;QAPApiB,KAAAmF,MAAAA;QACAnF,KAAAD,QAAAA;QACAC,KAAAghB,SAAAA;QACAhhB,KAAAihB,WAAAA;QACAjhB,KAAAkhB,gBAAAA;QACAlhB,KAAAkiB,cAAAA;QACAliB,KAAAmiB,cAAAA;QACAniB,KAAAoiB,cAAAA;QAdFpiB,KAAAqiB,QAAA;QAEAriB,KAAA0f,QAAA;QAEA1f,KAAAsiB,WAAA;;MAgBRvB,iBAAA9gB,UAAA+C,QAAA;QAAA,IAAAlB,QAAA9B;QACEA,KAAAmF,IAAA4E,GAAAlK,aAAAwD,WAAA2R,eAAA,SAAAzT;UACE,OAAAO,MAAAygB,gBAAAhhB;;QAEFvB,KAAAmF,IAAA4E,GAAAlK,aAAAwD,WAAA+O,kBAAA;UAAA,OAAAtQ,MAAA0gB;;QACAxiB,KAAAmF,IAAA4E,GAAAlK,aAAAwD,WAAA2G,iBAAA;UAAA,OAAAlI,MAAAmI;;QACAjK,KAAAmF,IAAA4E,GAAAlK,aAAAwD,WAAA6G,kBAAA;UAAA,OAAApI,MAAAqI;;QACAnK,KAAAmF,IAAA4E,GAAAlK,aAAAwD,WAAA6R,eAAA;UAAA,OAAApT,MAAA2gB;;QACAjiB,QAAA6R,MAAA,gCAAArS,KAAAmF,IAAAmN,iBAAAzS,aAAAwD,WAAA2R;QAKA,IAAAmM,QAAAnhB,KAAAkiB,YAAAQ;QACA1iB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAkS,WAAA;UACE4L,OAAAA;UACAzB,OAAA1f,KAAA0f;UACAyC,aAAAniB,KAAAmiB;;QAGFniB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAmS,UAAA2L;QACAnhB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAoS,WAAA;UAAAiK,OAAA1f,KAAA0f;;QACA1f,KAAA2iB,YAAA;QACAniB,QAAAC,KAAA;;MAOFsgB,iBAAA9gB,UAAAmQ,QAAA;QACEpQ,KAAA0f,QAAA;QACA1f,KAAAsiB,WAAA;QACAtiB,KAAAkiB,YAAA9R;QAEA,IAAA+Q,QAAAnhB,KAAAkiB,YAAAQ;QACA1iB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAkS,WAAA;UACE4L,OAAAA;UACAzB,OAAA1f,KAAA0f;UACAyC,aAAAniB,KAAAmiB;;QAEFniB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAmS,UAAA2L;QACAnhB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAoS,WAAA;UAAAiK,OAAA1f,KAAA0f;;QAEA1f,KAAA2iB,YAAA;;MAOM5B,iBAAA9gB,UAAAsiB,kBAAA,SAAAvf;QACNxC,QAAAC,KAAA,iCAAAuC;QACAhD,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAwT,aAAA7T;QACA,IAAA,mBAAAhD,KAAAqiB,OAAA;UACE7hB,QAAAC,KAAA,oDAAAT,KAAAqiB;UAIA;;QAGF,IAAAliB,OAAAH,KAAAD,MAAAsC,OAAAW;QACA,KAAA7C,MAAW;QAKX,IAAAA,KAAAE,SAAArC,OAAAsC,SAAAoB,QAAA;UACE1B,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAwS,kBAAA;YACExV,MAAAF,KAAAE;YACAwX,UAAA7U;;UAEFhD,KAAAkiB,YAAAU;UACA5iB,KAAA2iB,YAAA;UAEA,QAAAxiB,KAAAE;WACE,KAAArC,OAAAsC,SAAAU;YACE,IAAA6hB,UAAA;YACA,KAAA,IAAA1hB,MAAA,GAAAA,MAAA,GAAAA,MACE,KAAA,IAAAC,MAAA,GAAAA,MAAA,GAAAA,MACE,IAAApC,KAAAqC,IAAArC,KAAAsC,IAAAH,KAAAnC,KAAAsC,IAAAF,QAAA,GAAA;cACE,IAAAG,IAAA,IAAAV,GAAAC,KAAAkC,MAAApE,IAAAuC,IAAA6B,MAAAvE,IAAA2C;cACApB,KAAAD,MAAAyB,SAAAD,MAA4BshB,QAAA1jB,KAAAoC;;YAIlC,IAAAgE,WAAAvF,KAAAghB,OAAApf,eAAAihB;YACA7iB,KAAA0f,SAAA1f,KAAAkhB,cAAA4B,UAAAvd,SAAArG;iBACAc,KAAAihB,SAAA7b,QAAAG;YACA;;WAEF,KAAAvH,OAAAsC,SAAAC;YACE,IAAAwiB,UAAAriB,MAAAC,KAAA;cAAAzB,QAAAc,KAAAD,MAAAlB;eAAA,SAAA+B,GAAAhC;cAAA,OAAA,IAAAiC,GAAAC,KAAAlC,GAAAoE,MAAAvE;;YAIA,IAAA8G,WAAAvF,KAAAghB,OAAApf,eAAAmhB;YACA/iB,KAAA0f,SAAA1f,KAAAkhB,cAAA4B,UAAAvd,SAAArG;iBACAc,KAAAihB,SAAA7b,QAAAG;YACA;;WAEF,KAAAvH,OAAAsC,SAAAS;YACE,IAAAiiB,UAAAtiB,MAAAC,KAAA;cAAAzB,QAAAc,KAAAD,MAAArB;eAAA,SAAAkC,GAAAnC;cAAA,OAAA,IAAAoC,GAAAC,KAAAkC,MAAApE,GAAAH;;YAIA,IAAA8G,WAAAvF,KAAAghB,OAAApf,eAAAohB;YACAhjB,KAAA0f,SAAA1f,KAAAkhB,cAAA4B,UAAAvd,SAAArG;iBACAc,KAAAihB,SAAA7b,QAAAG;YACA;;WAEF,KAAAvH,OAAAsC,SAAAmB;YACE,IAAAwhB,UAAA;YACA,KAAA,IAAArkB,IAAA,GAAAA,IAAAoB,KAAAD,MAAAlB,MAAAD,KACE,KAAA,IAAAH,IAAA,GAAAA,IAAAuB,KAAAD,MAAArB,MAAAD,KACEwkB,QAAA9jB,KAAA,IAAA0B,GAAAC,KAAAlC,GAAAH;YAGJ,IAAA8G,WAAAvF,KAAAghB,OAAApf,eAAAqhB;YACAjjB,KAAA0f,SAAA1f,KAAAkhB,cAAA4B,UAAAvd,SAAArG;iBACAc,KAAAihB,SAAA7b,QAAAG;;UAMJ;;QAIF,IAAA1D,QAAA7B,KAAAghB,OAAAje,UAAAC;QACA,IAAAnB,MAAA3C,SAAA,GAAA;UACEsB,QAAAC,KAAA,yCAAAuC,MAAApE,IAAA,MAAAoE,MAAAvE;UACAuB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAyT,YAAA9T;UACA;;QAGFxC,QAAAC,KAAA,sCAAAoB,MAAA3C;QAEAc,KAAAkiB,YAAAU;QACA5iB,KAAA0f,SAAA1f,KAAAkhB,cAAA4B,UAAAjhB,MAAA3C;QACAc,KAAA2iB,YAAA;aAGA3iB,KAAAihB,SAAA7b,QAAAvD;;MAIMkf,iBAAA9gB,UAAAuiB,qBAAA;QACN,mBAAAxiB,KAAAqiB,SACEriB,KAAA2iB,YAAA;;MAKI5B,iBAAA9gB,UAAAgK,oBAAA;QACN,mBAAAjK,KAAAqiB,SACEriB,KAAA2iB,YAAA;;MAKI5B,iBAAA9gB,UAAAkK,qBAAA;QACN,mBAAAnK,KAAAqiB,SACEriB,KAAA2iB,YAAA;;MAQI5B,iBAAA9gB,UAAAwiB,kBAAA;QACN,IAAA,oBAAAziB,KAAAqiB,OAAoC;QAEpCriB,KAAA2iB,YAAA;QACA3iB,KAAA2iB,YAAA;QACA3iB,KAAA2iB,YAAA;QACA3iB,KAAAkjB;QAEAljB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAoS,WAAA;UAAAiK,OAAA1f,KAAA0f;;;MAMMqB,iBAAA9gB,UAAAijB,cAAA;QACN,IAAAlf,WAAAhE,KAAAmjB;QACA,IAAAhC,QAAAnhB,KAAAkiB,YAAAQ;QAEA,IAAA1iB,KAAA0f,SAAA1f,KAAAmiB,aAAA;UACEniB,KAAA2iB,YAAA;UACA;;QAGF,KAAA3e,YAAAhE,KAAAsiB,WAAAtiB,KAAAoiB,aAAA;UACEpiB,KAAA2iB,YAAA;UACA3iB,KAAAojB;UACApjB,KAAAsiB;UACAtiB,KAAA2iB,YAAA;UACA;;QAGF,IAAA,MAAAxB,UAAAnd,YAAAhE,KAAAsiB,YAAAtiB,KAAAoiB,aAAA;UACEpiB,KAAA2iB,YAAA;UACA;;QAGF3iB,KAAA2iB,YAAA;;MAMM5B,iBAAA9gB,UAAA0iB,cAAA,SAAAU;QACNrjB,KAAAqiB,QAAAgB;QACArjB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAA0S,cAAAsN;QACA7iB,QAAAC,KAAA,oBAAA4iB;QACA,UAAAA,YACErjB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAsS,SAAA3V,KAAA0f;QAEF,WAAA2D,YACErjB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAuS,UAAA5V,KAAA0f;;MAQIqB,iBAAA9gB,UAAAkjB,oBAAA;QACN,IAAAlf,QAAA;QAGA,IAAAqf,YAAA;QACA,IAAA9kB,QAAA;QAGAwB,KAAAD,MAAAmE,QAAA,SAAA3C,GAAApB;UACEmjB,UAAAnkB,KAAAoC;UACA/C,MAAAW,KAAAgB;;QAIF,KAAA,IAAAkH,IAAA,GAAAA,IAAAic,UAAApkB,QAAAmI,KAAA;UACE,IAAApD,OAAW;UACX,IAAA1C,IAAA+hB,UAAAjc;UACA,IAAAlH,OAAA3B,MAAA6I;UAEA,KAAA,IAAA9E,KAAA,GAAAC,KAAAxC,KAAAD,MAAA6D,WAAArC,IAAAgB,KAAAC,GAAAtD,QAAAqD,MAAA;YAAK,IAAAsB,IAAArB,GAAAD;YACH,IAAA4B,QAAAnE,KAAAD,MAAAsC,OAAAwB;YACA,IAAAM,SAAAA,MAAArF,UAAAqB,KAAArB,OAAA;cACEmF,QAAA;cACA;;;;QAKN,OAAAA;;MAIM8c,iBAAA9gB,UAAAmjB,eAAA;;;QACN,IAAAjlB,MAAA6B,KAAAD,MAAA5B;QACA,IAAAK,QAAA;QACA,KAAA,IAAAC,IAAA,GAAAA,IAAAN,IAAAO,MAAAD,KACE,KAAA,IAAAG,IAAA,GAAAA,IAAAT,IAAAU,MAAAD,KACEJ,MAAAW,KAAAa,KAAAD,MAAAsC,OAAA,IAAAxB,GAAAC,KAAAlC,GAAAH;QAIJ,KAAA,IAAA4I,IAAA7I,MAAAU,SAAA,GAAAmI,IAAA,GAAAA,KAAA;UACE,IAAAkc,IAAAvkB,KAAAC,MAAAD,KAAAmc,YAAA9T,IAAA;UACA7E,KAAA,EAAAhE,MAAA+kB,IAAA/kB,MAAA6I,MAAA7I,MAAA6I,KAAA7E,GAAA,IAAAhE,MAAA+kB,KAAA/gB,GAAA;;QAEF,IAAA6O,MAAA;QACA,KAAA,IAAA5S,IAAA,GAAAA,IAAAN,IAAAO,MAAAD,KACE,KAAA,IAAAG,IAAA,GAAAA,IAAAT,IAAAU,MAAAD,KACEoB,KAAAD,MAAA2E,QAAA,IAAA7D,GAAAC,KAAAlC,GAAAH,IAAA,UAAAwJ,KAAAzJ,MAAA6S,gBAAA,MAAApJ,KAAAA,KAAA;;MAIR,OAAA8Y;KAjTA;IAAaphB,QAAAohB,mBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICzBb,IAAAnhB,aAAA9B,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IACM,IAAA0E,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAkBN,IAAAwd,gBAAA,SAAAtd;MAAmCC,UAAAqd,eAAAtd;MAAnC,SAAAsd;QAAA,IAAA1hB,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAEE8B,MAAA2hB,WAAA;QAEA3hB,MAAA4hB,WAAA;QAEA5hB,MAAA6hB,WAAA;QAEQ7hB,MAAA8hB,WAAA;QAEA9hB,MAAAqf,QAAA;QACArf,MAAA4d,QAAA;QACA5d,MAAAqgB,cAAA;;;MAERqB,cAAAvjB,UAAA+N,SAAA;QAEEpO,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAmS,UAAAxV,KAAA6jB,YAAA7jB;QAGAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAoS,WAAAzV,KAAA8jB,aAAA9jB;QAGAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAkS,WAAAvV,KAAA+jB,aAAA/jB;QAEAQ,QAAA0I,IAAA;;MAIFsa,cAAAvjB,UAAA+C,QAAA;;QACE,IAAAghB,OAAAhkB,KAAAwH;QAGA,KAAAxH,KAAA2jB,UAAA;UACE,IAAA9f,IAAAmgB,KAAA9b,eAAA;UACAlI,KAAA2jB,WAAA,SAAA9f,UAAA,MAAAA,SAAA,IAAAA,EAAAiE,aAAA;;QAEF,KAAA9H,KAAAyjB,UAAA;UACE,IAAA5f,IAAAmgB,KAAA9b,eAAA;UACAlI,KAAAyjB,WAAA,SAAA5f,UAAA,MAAAA,SAAA,IAAAA,EAAAiE,aAAA;;QAEF,KAAA9H,KAAA0jB,UAAA;UACE,IAAA7f,IAAAmgB,KAAA9b,eAAA;UACAlI,KAAA0jB,WAAA,SAAA7f,UAAA,MAAAA,SAAA,IAAAA,EAAAiE,aAAA;;QAGF9H,KAAA4jB,WACG,UADHphB,KAAAwhB,KACG9b,eAAA,qBAAA,MAAA1F,UAAA,IAAAA,GAAAsF,aAAA;QAGH,UAAAa,KAAA,UAAAV,KAAAjI,KAAA4jB,kBAAA,MAAA3b,UAAA,IAAAA,GAAAT,cAAA,MAAAmB,UAAA,IAAAA,GAAAoB,GAAA,SAAA/J,KAAAikB,aAAAC,KAAAlkB;QAGAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAA0S,cAAA/V,KAAAmkB,gBAAAnkB;;MAGMwjB,cAAAvjB,UAAA8jB,cAAA,SAAAvP;QAKNxU,KAAAmhB,QAAA3M,KAAA2M;QACAnhB,KAAA0f,QAAAlL,KAAAkL;QACA1f,KAAAmiB,cAAA3N,KAAA2N;QAEAniB,KAAAyjB,aACEzjB,KAAAyjB,SAAAha,SAAAzJ,KAAA0f,QAAA,QAAA1f,KAAAmiB;QACFniB,KAAA0jB,aAAmB1jB,KAAA0jB,SAAAja,SAAAC,OAAA1J,KAAAmhB;;MAMbqC,cAAAvjB,UAAA4jB,aAAA,SAAAO;;QACNpkB,KAAA0jB,aAAmB1jB,KAAA0jB,SAAAja,SAAAC,OAAA0a;QACnB,IAAAC,WAAA,UAAA7hB,KAAAxC,KAAA0jB,kBAAA,MAAAlhB,UAAA,IAAAA,GAAAgF;QACA,IAAA4c,QAAA,KAAAC,UAAA;UACEzkB,WAAAuD,SAAAC,KAAAvD,aAAAwD,WAAA6S,kBAAA;UACArV,GAAAoL,MAAAoY,UACGnY,GAAA,KAAA;YAAA2L,UAAA,IAAAhX,GAAA0e,MAAA,GAAA,GAAA;aACArT,GAAA,KAAA;YAAA2L,UAAA,IAAAhX,GAAA0e,KAAA,GAAA,GAAA;aACArT,GAAA,KAAA;YAAA2L,UAAA,IAAAhX,GAAA0e,KAAA,GAAA,GAAA;aACAvc;UACHiV,WAAA;YAAA,OAAArY,WAAAuD,SAAAC,KAAAvD,aAAAwD,WAAA8S,gBAAA;aAAA;;;MAUIqN,cAAAvjB,UAAA6jB,cAAA,SAAAthB;QAAR,IAAAV,QAAA9B;QAAsB,IAAA0f,QAAAld,GAAAkd;QACpB,KAAA1f,KAAAyjB,UAAoB;QACpB,IAAAa,WAAAlI,SAAApc,KAAAyjB,SAAAha,QAAA,OAAA;QACA,IAAA+K,OAAA;UAAA/L,OAAA6b;;QACA1kB,WAAAuD,SAAAC,KAAAvD,aAAAwD,WAAA6S,kBAAA;QAEArV,GAAAoL,MAAAuI,MAAAtI,GAAA,IAAA;UAAAzD,OAAAiX;WAAA;UAAAvQ,QAAA;WAAAnM;QACA,IAAAwF,KAAA+b,YAAA;UACEziB,MAAA2hB,aACE3hB,MAAA2hB,SAAAha,SAAAzK,KAAAwlB,MAAAhQ,KAAA/L,SAAA,QAAA3G,MAAAqgB;WAEJ;QACAlK,WAAA;UACEwM,cAAAjc;UACA1G,MAAA2hB,aACE3hB,MAAA2hB,SAAAha,SAAAiW,QAAA,QAAA5d,MAAAqgB;UACFviB,WAAAuD,SAAAC,KAAAvD,aAAAwD,WAAA8S,gBAAA;WACF;;MAMMqN,cAAAvjB,UAAAgkB,eAAA;QACNrkB,WAAAuD,SAAAC,KAAAvD,aAAAwD,WAAA2S;;MAMMwN,cAAAvjB,UAAAkkB,iBAAA,SAAA9B;QACNriB,KAAA2jB,aAAmB3jB,KAAA2jB,SAAAla,SAAA4Y;;MAzHrB7V,WAAA,EADCxG,SAAAnF,GAAAsH,UACyBqb,cAAAvjB,WAAA,iBAAA;MAE1BuM,WAAA,EADCxG,SAAAnF,GAAAsH,UACyBqb,cAAAvjB,WAAA,iBAAA;MAE1BuM,WAAA,EADCxG,SAAAnF,GAAAsH,UACyBqb,cAAAvjB,WAAA,iBAAA;MANfujB,gBAAAhX,WAAA,EADZzG,aACYyd;MA6Hb,OAAAA;KA7HA,CAAA3iB,GAAA6L;IAAa/M,QAAA6jB,gBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICpBb,IAAA1O,yBAAA;MAAA,SAAAA;QACU9U,KAAAga,SAAA,IAAAnZ,GAAAuW;QACApX,KAAA0kB,WAAA,IAAA5W;;MAERgH,uBAAA7U,UAAA8J,KAAA,SAAA4a,WAAAC,SAAA5K,QAAA6K;QAOE,IAAAC,eAAA9K,SAAA4K,QAAAV,KAAAlK,UAAA4K;QAGA5kB,KAAAga,OAAAjQ,GAAA4a,WAAAG,cAAA9K,QAAA6K;QACA,IAAArW,MAAAxO,KAAA0kB,SAAAlgB,IAAAmgB;QACA,KAAAnW,KAAA;UACEA,MAAA,IAAAxM;UACAhC,KAAA0kB,SAAAlW,IAAAmW,WAAAnW;;QAEFA,IAAA5L,IAAAkiB;;MAGFhQ,uBAAA7U,UAAA6K,MAAA,SAAA6Z,WAAAC,SAAA5K;QAME,IAAA8K,eAAA9K,UAAA4K,UAAAA,QAAAV,KAAAlK,UAAA4K;QAGA5kB,KAAAga,OAAAlP,IAAA6Z,WAAAG,cAAA9K;QACA,IAAAxL,MAAAxO,KAAA0kB,SAAAlgB,IAAAmgB;QACA,IAAAnW,OAAAsW,cAAA;UACEtW,IAAAuW,OAAAD;UACA,MAAAtW,IAAAwW,QACEhlB,KAAA0kB,SAAAK,OAAAJ;eAEGnW,QAAAsW,gBACL9kB,KAAA0kB,SAAAK,OAAAJ;;MAIJ7P,uBAAA7U,UAAA+W,OAAA,SAAAC,OAAAC,UAAA8C;QAAA,IAAAlY,QAAA9B;QAKE,IAAA8E,WAAA;UAAkB,IAAAqS,OAAA;UAAA,KAAA,IAAA5U,KAAA,GAAAA,KAAA8D,UAAAnH,QAAAqD,MAAA4U,KAAA5U,MAAA8D,UAAA9D;UAChBT,MAAAgJ,IAAAmM,OAAAnS,UAAAkV;UAEA,IAAAiL,gBAAAjL,SAAA9C,SAAAgN,KAAAlK,UAAA9C;UACA+N,cAAA7e,WAAA,GAAA+Q;;QAEFnX,KAAA+J,GAAAkN,OAAAnS,UAAAkV;;MAGFlF,uBAAA7U,UAAAmD,OAAA,SAAAuhB;;QAAwB,IAAAxN,OAAA;QAAA,KAAA,IAAA5U,KAAA,GAAAA,KAAA8D,UAAAnH,QAAAqD,MAAA4U,KAAA5U,KAAA,KAAA8D,UAAA9D;QACtB,IAAAgF,QAAAvH,KAAAsS,iBAAAqS;QACA,MAAApd,SACE/G,QAAAyG,KAAA,8BAAA0d,YAAA;QAOFnkB,QAAA0I,IAAA,QAAAyb,WAAAxN;SACA3U,KAAAxC,KAAAga,QAAA5W,KAAAgD,MAAA5D,IAAA8L,eAAA,EAAAqW,aAAAxN;;MAGFrC,uBAAA7U,UAAAqS,mBAAA,SAAAqS;;QACE,OAAA,UAAA1c,KAAA,UAAAzF,KAAAxC,KAAA0kB,SAAAlgB,IAAAmgB,oBAAA,MAAAniB,UAAA,IAAAA,GAAAwiB,cAAA,MAAA/c,KAAAA,KAAA;;MAGF6M,uBAAA7U,UAAA6T,QAAA,SAAA6Q;QAAA,IAAA7iB,QAAA9B;QACE,IAAA2kB,WAAA;UACE,IAAAnW,MAAAxO,KAAA0kB,SAAAlgB,IAAAmgB;UACAnW,OAEEA,IAAAtK,QAAA,SAAAghB;YAEEpjB,MAAAkY,OAAAlP,IAAA6Z,WAAAO;;UAGJllB,KAAA0kB,SAAAK,OAAAJ;eACK;UACL3kB,KAAA0kB,SAAAxgB,QAAA,SAAAihB,UAAAC;YAEED,SAAAjhB,QAAA,SAAAghB;cAEEpjB,MAAAkY,OAAAlP,IAAAsa,KAAAF;;;UAGJllB,KAAA0kB,SAAA5Q;;;MAGN,OAAAgB;KAlGA;IAAanV,QAAAmV,yBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICEb,IAAAuQ,kBAAAvnB,QAAA;IACA,IAAAwnB,gBAAAxnB,QAAA;IACA,IAAAynB,gBAAAznB,QAAA;IACA,IAAAE,SAAAF,QAAA;IACA,IAAA0nB,qBAAA1nB,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IACA,IAAA8e,iBAAA9e,QAAA;IAOA,IAAA0H,eAAA;MACE,SAAAA,aAAAzF,OAAAoF;QACUnF,KAAAD,QAAAA;QACAC,KAAAmF,MAAAA;;MAGJK,aAAAvF,UAAAmF,UAAA,SAAAvD;QAA2B,OAAAwD,UAAArF,WAAA,GAAAsF,SAAA;;;;;;cAC/B,IAAA,MAAAzD,MAAA3C,QACE,MAAA,IAAAyC,MAAA;cAGIxD,MAAA6B,KAAAD,MAAAuT;cACAtQ,QAAAnB,MAAA;cACAoB,YAAAjD,KAAAD,MAAAsC,OAAAW;cACAyiB,WAAA5jB,MAAA6jB,KAAA,SAAAnkB;gBACJ,IAAAa,IAAAN,MAAA/B,MAAAsC,OAAAd;gBACA,OAAA,SAAAa,KAAAA,EAAA/B,SAAArC,OAAAsC,SAAAoB;;cAMIikB,cAAA;cACAC,mBAAA,SAAAvlB,MAAAD;gBACJ,IAAAjC,MAAA2D,MAAA/B,MAAAuT;gBACA,IAAA1U,KAAAwB,IAAAxB,IAAAkD,MAAA/B,MAAAlB,OAAA,KAAAV,IAAAqV,YAAArV,IAAAqV,YAAA;gBAEA,IAAA/U,KAAAqD,MAAA/B,MAAArB,OAAA,IAAA0B,IAAA3B,KAAAN,IAAAsV,aAAAtV,IAAAsV,aAAA;gBAEAkS,YAAAxmB,KAAAyd,eAAAtF,aAAAM,WAAAvX,MAAAQ,GAAAwZ,GAAAzb,GAAAH;;cAEFuB,KAAAmF,IAAA4E,GAAAlK,aAAAwD,WAAAuT,oBAAAgP;cAKMC,aAAA7lB,KAAA8lB,KAAAjmB,aAAAwD,WAAA4R;cACN,IAAAoQ,gBAAAU,cAAA/lB,KAAAD,OAAAC,KAAAmF,KAAAtD,OAAAuD;cACqB,OAAA,EAAA,GAAAygB;;;cAAdG,YAAAxjB,GAAAiD,OAAA;cAKPzF,KAAAmF,IAAA2F,IAAAjL,aAAAwD,WAAAuT,oBAAAgP;cACA,OAAA,EAAA,GAAAtgB,QAAA2gB,IAAAN;;;cAAAnjB,GAAAiD;cAIA,IAAAxC,aAAApB,MAAA3C,UAAAf,IAAAuV,mBAAA+R,UAAA;gBACQplB,OAAA,IAAAmlB,mBAAAU,iBAAA/nB,KAAAgoB;gBACAhmB,OAAAnC,OAAAoB,YAAAC,aAAA4D,UAAAnE;gBACNqB,KAAAE,OAAAA;gBACAL,KAAAD,MAAA2E,QAAA1B,OAAA7C;gBACAH,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAqT,kBAAA1T,OAAA7C;;cAIIimB,WAAApmB,KAAA8lB,KAAAjmB,aAAAwD,WAAAiS;cACN,IAAAgQ,cAAA3K,YAAA3a,KAAAD,OAAAC,KAAAmF,KAAA6gB,WAAA5gB;cACsB,OAAA,EAAA,GAAAghB;;;cAAfvL,aAAArY,GAAAiD,OAAA;cAGD4gB,WAAArmB,KAAA8lB,KAAAjmB,aAAAwD,WAAA+R;cACN,IAAAmQ,cAAAtK,YAAAjb,KAAAD,OAAAC,KAAAmF,KAAA0V,YAAAzV;cACA,OAAA,EAAA,GAAAihB;;;cAAA7jB,GAAAiD;cAGAzF,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAA6R;;;;;;MAMM1P,aAAAvF,UAAA6lB,OAAA,SAAA7O;QAAR,IAAAnV,QAAA9B;QACE,OAAA,IAAAsF,QAAA,SAAA6N;UACErR,MAAAqD,IAAA6R,KAAAC,OAAA;YAAsB,IAAAE,OAAA;YAAA,KAAA,IAAA5U,KAAA,GAAAA,KAAA8D,UAAAnH,QAAAqD,MAAA4U,KAAA5U,MAAA8D,UAAA9D;YAAuB,OAAA4Q,QAAAgE;;;;MAGnD,OAAA3R;KA9EA;IAAa7F,QAAA6F,eAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICfP,IAAAhD,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAEN,IAAApG,aAAA9B,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IACA,IAAAsd,wBAAAtd,QAAA;IAGA,IAAAud,iBAAAvd,QAAA;IACA,IAAAwd,kBAAAxd,QAAA;IACA,IAAAE,SAAAF,QAAA;IACA,IAAAwoB,oBAAAxoB,QAAA;IAGA,IAAAyoB,qBAAA,SAAArgB;MAAgDC,UAAAogB,oBAAArgB;MAAhD,SAAAqgB;QAAA,IAAAzkB,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAGE8B,MAAA2Z,aAAA;QASQ3Z,MAAA0kB,iBAAA,IAAAxkB;;;MAERukB,mBAAAtmB,UAAA+N,SAAA;QAEEhO,KAAA2b,YAAA3b,KAAAwH,KAAAM,aAAAsT,sBAAA3Q;QACAzK,KAAAD,QAAAC,KAAA2b,UAAAC;QACA5b,KAAA6b,YAAA7b,KAAA2b,UAAAE;QAGAjc,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAoT,eAAAzW,KAAAymB,UAAAzmB;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAiS,UAAAtV,KAAA0mB,QAAA1mB;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAA+R,UAAApV,KAAA2mB,QAAA3mB;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAqT,kBAAA1W,KAAA4mB,oBAAA5mB;QACAJ,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAuT,oBAAA5W,KAAA6mB,sBAAA7mB;;MAOMumB,mBAAAtmB,UAAAwmB,WAAA,SAAAnD;;QACNtjB,KAAAwmB,iBAAA,IAAAxkB,IAAAshB,UAAArhB,IAAA,SAAAV;UAAA,OAAAA,EAAA3C,IAAA,MAAA2C,EAAA9C;;QAEAuB,KAAA6b,YAAA7b,KAAA2b,UAAAE;QACS,IAAAzU,UAAA,SAAAC;UACP,IAAA9F,IAAA+hB,UAAAjc;UACA,IAAAkV,OAAA,UAAA/Z,KAAAkF,OAAAmU,UAAAta,EAAA9C,YAAA,MAAA+D,UAAA,IAAAA,GAAAjB,EAAA3C;UACA,KAAA2d,MAAoB,OAAA;UACpBA,KAAA/U,KAAAiT,UAAA5Z,GAAA0Z,SAAA1Z,GAAA6c,MAAA7c,GAAA2Z,QAAA,KAAA,IAAA3Z,GAAAimB,QAAA,OAAAjmB,GAAAkZ,SAAA;YAAA,OAAAwC,KAAA/U,KAAA0R;;UAMAxR,OAAAmU,UAAAta,EAAA9C,GAAA8C,EAAA3C,UAAAgW;UACAlN,OAAAiU,UAAAE,UAAAta,EAAA9C,GAAA8C,EAAA3C,UAAAgW;;;QAXF,KAAA,IAAAvN,IAAA,GAAAA,IAAAic,UAAApkB,QAAAmI,KAASD,QAAAC;;MAqBHkf,mBAAAtmB,UAAAymB,SAAA;QAEN,IAAAzkB,MAAA,IAAA6L;QACA,KAAA,IAAAiZ,WAAA,GAAAA,WAAA/mB,KAAA6b,UAAA3c,QAAA6nB,YAAA;UACE,IAAApoB,MAAAqB,KAAA6b,UAAAkL;UACA,KAAA,IAAAC,WAAA,GAAAA,WAAAroB,IAAAO,QAAA8nB,YAAA;YACE,IAAAC,IAAAtoB,IAAAqoB;YACA,KAAAC,GAAQ;YACRhlB,IAAAuM,IAAAyY,EAAA9mB,MAAA8mB;;;QAKJ,IAAAC,UAAA;QACA,KAAA,IAAAlP,IAAA,GAAAA,IAAAhY,KAAAD,MAAArB,MAAAsZ,KACEkP,QAAAlP,KAAA,IAAAtX,MAAAV,KAAAD,MAAAlB;QAIF,IAAAykB,YAAA;QACA,IAAA9kB,QAAA;QAEAwB,KAAAD,MAAAmE,QAAA,SAAA3C,GAAAa;UACEkhB,UAAAnkB,KAAAoC;UACA/C,MAAAW,KAAAiD;;QAIF,KAAA,IAAAiF,IAAA,GAAAA,IAAAic,UAAApkB,QAAAmI,KAAA;UACE,IAAA9F,IAAA+hB,UAAAjc;UACA,IAAAjF,IAAA5D,MAAA6I;UACA,IAAAkV,OAAAta,IAAAuC,IAAApC;UAEA,KAAAma,MACE;UAGF,IAAAvC,SAAAsB,gBAAAkB,oBAAAjb,EAAA3C,GAAA2C,EAAA9C,GAAAuB,KAAAD;UACA,IAAAwZ,OAAAva,KAAAC,MAAAD,KAAAsC,IAAAib,KAAA/U,KAAA/I,IAAAub,OAAAvb;UAEA8a,OAAA,KACE8B,eAAAjC,iBAAAmD,KAAA/U,MAAAwS;UAGFuC,KAAA/U,KAAA8Q,SAAAtY,KAAAD,MAAArB,OAAA6C,EAAA9C,IAAA;UACA8d,KAAAgB,WAAA1c,GAAAwZ,GAAA9Y,EAAA3C,GAAA2C,EAAA9C;UACAyoB,QAAA3lB,EAAA9C,GAAA8C,EAAA3C,KAAA2d;;QAGFvc,KAAA6b,YAAAqL;QACAlnB,KAAA2b,UAAAE,YAAA7b,KAAA6b;;MAMM0K,mBAAAtmB,UAAA0mB,SAAA;QACN3mB,KAAA6b,YAAA7b,KAAA2b,UAAAE;;MAMM0K,mBAAAtmB,UAAA2mB,qBAAA,SAAAxmB;QACN,IAAAmc,OAAAvc,KAAA2b,UAAA+B,MAAAtd;QACAmc,KAAAnW,MAAApG,KAAAD,MAAAsC,OAAAjC;QACAJ,KAAA6b,YAAA7b,KAAA2b,UAAAE;;MAIM0K,mBAAAtmB,UAAA4mB,uBAAA,SAAAxmB,MAAAD;QACN,QAAAC;SACE,KAAArC,OAAAsC,SAAAU;UACEhB,KAAAmnB,mBAAA/mB;UACA;;SACF,KAAApC,OAAAsC,SAAAC;UACEP,KAAAonB,mBAAAhnB,KAAA;UACA;;SACF,KAAApC,OAAAsC,SAAAS;UACEf,KAAAonB,mBAAAhnB,KAAA;;;MAQEmmB,mBAAAtmB,UAAAknB,qBAAA,SAAAjiB;;QACN,IAAAmiB,YAAA/L,gBAAAkB,oBAAAtX,OAAAtG,GAAAsG,OAAAzG,GAAAuB,KAAAD;QAEA,KAAA,IAAAtB,IAAAyG,OAAAzG,IAAA,GAAAA,KAAAyG,OAAAzG,IAAA,GAAAA,KAAA;UACW,IAAA6oB,UAAA,SAAA1oB;YACP,IAAA2a,OAAAva,KAAAqC,IAAArC,KAAAsC,IAAA1C,IAAAsG,OAAAtG,IAAAI,KAAAsC,IAAA7C,IAAAyG,OAAAzG;YACA,IAAA8a,OAAA,KAAAA,OAAA,GAAmC,OAAA;YACnC,IAAA5V,MAAA/E,IAAA,MAAAH;YACA,IAAA8oB,OAAAf,eAAA7jB,IAAAgB,MAA2C,OAAA;YAE3C,IAAA4Y,OAAA,UAAA/Z,KAAA+kB,OAAA1L,UAAApd,YAAA,MAAA+D,UAAA,IAAAA,GAAA5D;YACA,KAAA2d,SAAAA,KAAAiL,iBAA6C,OAAA;YAE7C,IAAAhgB,OAAA+U,KAAA/U;YACA,IAAArG,KAAAqG,KAAA5I,IAAAyoB,UAAAzoB;YACA,IAAAwC,KAAAoG,KAAA/I,IAAA4oB,UAAA5oB;YACA,IAAAgpB,MAAAzoB,KAAA0oB,KAAAvmB,KAAAA,KAAAC,KAAAA,OAAA;YACA,IAAAumB,SAAA9mB,GAAAwZ,GAAAlZ,KAAAsmB,MAAAnB,kBAAAsB,MAAAC,YAAAzmB,KAAAqmB,MAAAnB,kBAAAsB,MAAAC;YAMChnB,GAAAoL,MAAAzE,MACEsgB,GAAAxB,kBAAAsB,MAAAG,iBAAA;cAAAlQ,UAAA8P;eACAG,GAAAxB,kBAAAsB,MAAAI,kBAAA;cAAAnQ,UAAAhX,GAAAwZ,IAAAsN,OAAA/oB,IAAA+oB,OAAAlpB;eAAA;cAAA0Q,QAAA;eAKA/C,KAAA;cAAA,OAAA5E,KAAAI,YAAA5I,KAAAwlB,MAAAhd,KAAA5I,IAAAI,KAAAwlB,MAAAhd,KAAA/I;eACAuE;;;UA3BL,KAAA,IAAApE,IAAAsG,OAAAtG,IAAA,GAAAA,KAAAsG,OAAAtG,IAAA,GAAAA,KAAS0oB,QAAA1oB;;;MAoCL2nB,mBAAAtmB,UAAAmnB,qBAAA,SAAAliB,QAAA+iB;;QACN,IAAA5mB,MAAA4mB,QAAAjoB,KAAAD,MAAAlB,OAAAmB,KAAAD,MAAArB;QACA,KAAA,IAAA2I,IAAA,GAAAA,IAAAhG,KAAAgG,KAAA;UACE,IAAAlG,KAAA8mB,QAAAjpB,KAAAsC,IAAA+F,IAAAnC,OAAAtG,KAAA;UACA,IAAAwC,KAAA6mB,QAAA,IAAAjpB,KAAAsC,IAAA+F,IAAAnC,OAAAzG;UACA,IAAA4Q,SAAAlO,KAAAC,MAAAklB,kBAAAsB,MAAAM;UAEA,IAAAC,UAAA;UACAF,QACEE,QAAAhpB,KAAA0B,GAAAwZ,GAAAhT,GAAAnC,OAAAzG,IAAA,IAAAoC,GAAAwZ,GAAAhT,GAAAnC,OAAAzG,IAAA,MAEA0pB,QAAAhpB,KAAA0B,GAAAwZ,GAAAnV,OAAAtG,IAAA,GAAAyI,IAAAxG,GAAAwZ,GAAAnV,OAAAtG,IAAA,GAAAyI;UAGS,IAAA+gB,UAAA,SAAAhmB;YACT,IAAAuB,MAAAvB,EAAAxD,IAAA,MAAAwD,EAAA3D;YACA,KAAA4pB,OAAAtoB,MAAAyB,SAAAY,MAAAimB,OAAA7B,eAAA7jB,IAAAgB,MAAsE,OAAA;YACtE,IAAA4Y,OAAA,UAAA/Z,KAAA6lB,OAAAxM,UAAAzZ,EAAA3D,YAAA,MAAA+D,UAAA,IAAAA,GAAAJ,EAAAxD;YACA,KAAA2d,SAAAA,KAAAiL,iBAA6C,OAAA;YAE7C,IAAAhgB,OAAA+U,KAAA/U;YAKA,IAAA8gB,OAAAL,QACEjpB,KAAAspB,KAAAlmB,EAAA3D,IAAAyG,OAAAzG,KACAO,KAAAspB,KAAAlmB,EAAAxD,IAAAsG,OAAAtG;YACF,IAAA2pB,MAAAN,QACEpnB,GAAAwZ,GAAA,IAAAiO,OAAAhC,kBAAAsB,MAAAY,cACA3nB,GAAAwZ,GAAAiO,OAAAhC,kBAAAsB,MAAAY,YAAA;YAGD3nB,GAAAoL,MAAAzE,MACE6H,MAAAA,OACAyY,GAAAxB,kBAAAsB,MAAAM,cAAA;cAAArQ,UAAA0Q;eACAT,GAAAxB,kBAAAsB,MAAAM,cAAA;cAAArQ,UAAAhX,GAAAwZ,IAAAkO,IAAA3pB,IAAA2pB,IAAA9pB;eAAA;cAAA0Q,QAAA;eAKA/C,KAAA;cAAA,OAAA5E,KAAAI,YAAA5I,KAAAwlB,MAAAhd,KAAA5I,IAAAI,KAAAwlB,MAAAhd,KAAA/I;eACAuE;;;UA5BL,KAAA,IAAAT,KAAA,GAAAkmB,YAAAN,SAAA5lB,KAAAkmB,UAAAvpB,QAAAqD,MAAA;YAAK,IAAAH,IAAAqmB,UAAAlmB;YAAM6lB,QAAAhmB;;;;MAoCRmkB,mBAAAtmB,UAAAmQ,QAAA,SAAArQ,OAAA8b;QACL7b,KAAAD,QAAAA;QACAC,KAAA6b,YAAAA;QACA7b,KAAA2b,YAAA3b,KAAAwH,KAAAM,aAAAsT,sBAAA3Q;;MA1OF+B,WAAA,EADCxG,SAAAnF,GAAAkK,SAC0Bwb,mBAAAtmB,WAAA,mBAAA;MAHRsmB,qBAAA/Z,WAAA,EADpBzG,aACoBwgB;MA+OrB,OAAAA;KA/OA,CAAA1lB,GAAA6L;IAAqB/M,QAAA8K,UAAA8b;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICbf,IAAA/jB,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAEN,IAAAwa,uBAAA1iB,QAAA;IAGA,IAAA4qB,oBAAA,SAAAxiB;MAA+CC,UAAAuiB,mBAAAxiB;MAA/C,SAAAwiB;QAAA,IAAA5mB,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAEE8B,MAAAmN,QAAA;;;MAIAyZ,kBAAAzoB,UAAA+N,SAAA;QAAA,IAAAlM,QAAA9B;QACEA,KAAAiP,UACEjP,KAAAiP,QACEjP,KAAA8H,aAAAjH,GAAAsH,UAAAnI,KAAAwH,KAAAgD,aAAA3J,GAAAsH;QAEJnI,KAAA2oB,SAAAnI,qBAAAiB,mBAAAjiB;QACA,KAAAQ,KAAA2oB,QAAkB;QAClB3oB,KAAA2oB,OAAAC,eAAA,SAAAhd;UACE9J,MAAAmN,MAAAxF,SAAA,gBAAAmC,EAAAid;UACA/mB,MAAAmN,MAAAzH,KAAA1I,QAAA8M,EAAAkd,WAAAjoB,GAAA8J,MAAA4T,MAAA1d,GAAA8J,MAAAoe;;QAEF,IAAAC,IAAAhpB,KAAA2oB,OAAAM;QACAjpB,KAAAiP,MAAAxF,SAAA,gBAAAuf,EAAAH;;MAhBFrc,WAAA,EADCxG,SAAAnF,GAAAsH,UACsBugB,kBAAAzoB,WAAA,cAAA;MAFJyoB,oBAAAlc,WAAA,EADpBzG,aACoB2iB;MAoBrB,OAAAA;KApBA,CAAA7nB,GAAA6L;IAAqB/M,QAAA8K,UAAAie;;;;;;;;;;;;;ICHrB,IAAA7oB,eAAA/B,QAAA;IASA,IAAA2jB,qBAAA;MAUE,SAAAA,mBAAAtc,KAAApF;QAAA,IAAA+B,QAAA9B;QACUA,KAAAmF,MAAAA;QACAnF,KAAAD,QAAAA;QATFC,KAAAkpB,UAAA;QACAlpB,KAAAmpB,QAAA;QACAnpB,KAAAopB,SAAA;QACAppB,KAAAqpB,YAAA;QACArpB,KAAAspB,SAAA;UAAAT,MAAA;UAAAC,UAAA;;QACA9oB,KAAAupB,YAAA;QAMN9H,mBAAAjiB,UAAAQ;QACAmF,IAAA4E,GAAAlK,aAAAwD,WAAA2R,eAAAhV,KAAAuiB,iBAAAviB;QACAmF,IAAA4E,GAAAlK,aAAAwD,WAAA4R,cAAAjV,KAAAwpB,gBAAAxpB;QACAmF,IAAA4E,GAAAlK,aAAAwD,WAAAiS,UAAA;UAAA,OAAAxT,MAAA2nB,OAAA;WAAAzpB;QACAmF,IAAA4E,GAAAlK,aAAAwD,WAAA8R,aAAAnV,KAAA8b,eAAA9b;QACAmF,IAAA4E,GAAAlK,aAAAwD,WAAA+R,UAAApV,KAAA+b,YAAA/b;QACAmF,IAAA4E,GAAAlK,aAAAwD,WAAA6R,eAAAlV,KAAAyiB,iBAAAziB;;MAGFyhB,mBAAAxhB,UAAA2oB,iBAAA,SAAAc;QACE1pB,KAAAupB,UAAApqB,KAAAuqB;;MAGFjI,mBAAAxhB,UAAAgpB,YAAA;QACE,OAAAjpB,KAAAspB;;MAGM7H,mBAAAxhB,UAAAsiB,kBAAA;QACNviB,KAAAkpB,UAAA;QACAlpB,KAAAmpB,QAAA;QACAnpB,KAAAopB,SAAA;QACAppB,KAAAypB,OAAA,kBAAA;;MAGMhI,mBAAAxhB,UAAAupB,iBAAA,SAAAlG;QACNtjB,KAAAkpB,WAAA5F,UAAApkB;QACAc,KAAAypB,OAAA;;MAGMhI,mBAAAxhB,UAAA6b,gBAAA;QAAR,IAAAha,QAAA9B;QACEA,KAAAqpB,aAAoBM,aAAA3pB,KAAAqpB;QACpBrpB,KAAAqpB,YAAApR,WAAA;UACEzX,QAAAyG,KAAA,6CAAA;YACE2iB,QAAA9nB,MAAAwnB,OAAAT;YACA9oB,OAAA+B,MAAA+nB;;UAEF/nB,MAAA2nB,OAAA,gBAAA;UACA3nB,MAAAunB,YAAA;WACF;QACArpB,KAAAypB,OAAA;;MAGMhI,mBAAAxhB,UAAA8b,aAAA,SAAA+N;;QACN,IAAA9pB,KAAAqpB,WAAA;UACEM,aAAA3pB,KAAAqpB;UACArpB,KAAAqpB,YAAA;;QAEFrpB,KAAAmpB,SAAA,UAAA3mB,KAAA,SAAAsnB,iBAAA,MAAAA,gBAAA,IAAAA,SAAA5qB,gBAAA,MAAAsD,KAAAA,KAAA;QACAxC,KAAAopB;QACAppB,KAAAypB,OAAA;;MAGMhI,mBAAAxhB,UAAAwiB,kBAAA;QACN,IAAAsH,QAAA/pB,KAAAopB,SAAA,IAAA,QAAA;QACA5oB,QAAAC,KAAA,2BAAAT,KAAAkpB,UAAA,aAAAlpB,KAAAmpB,QAAA,aAAAY;QAGA/pB,KAAAypB,OAAA;;MAGMhI,mBAAAxhB,UAAAwpB,SAAA,SAAAZ,MAAAC;QAAR,IAAAhnB,QAAA9B;aAA6B,MAAA8oB,aAAAA,WAAA;QAC3B9oB,KAAAspB,SAAA;UAAAT,MAAAA;UAAAC,UAAAA;;QACA9oB,KAAAupB,UAAArlB,QAAA,SAAA8kB;UAAA,OAAAA,EAAAlnB,MAAAwnB;;;MAGM7H,mBAAAxhB,UAAA4pB,YAAA;QACN,IAAAnrB,OAAA;QACA,KAAA,IAAAD,IAAA,GAAAA,IAAAuB,KAAAD,MAAArB,MAAAD,KAAA;UACE,IAAAI,OAAA;UACA,KAAA,IAAAD,IAAA,GAAAA,IAAAoB,KAAAD,MAAAlB,MAAAD,KAAA;YACE,IAAAwD,IAAApC,KAAAD,MAAAsC,OAAA,IAAAxB,GAAAC,KAAAlC,GAAAH;YACAI,KAAAM,KAAAiD,IAAAA,EAAAtD,MAAA,KAAA;;UAEFJ,KAAAS,KAAAN,KAAAmrB,KAAA;;QAEF,OAAAtrB,KAAAsrB,KAAA;;MAxFKvI,mBAAAjiB,UAAA;MA0FT,OAAAiiB;KA3FA;IAAa9hB,QAAA8hB,qBAAAA;;;;;;;;;;;;;ICXb,IAAA1Q,iBAAAjT,QAAA;IAOA,SAAA0e,oBAAA5I,KAAAjV,KAAAoB;MAKE,IAAA5B,MAAA4S,eAAAgD;MACA,IAAAnV,KAAAgV,MAAA7T,MAAAlB,OAAA,KAAAV,IAAAqV,YAAArV,IAAAqV,YAAA;MACA,IAAA/U,KAAAsB,MAAArB,OAAA,IAAAC,OAAAR,IAAAsV,aAAAtV,IAAAsV,aAAA;MACA,OAAA5S,GAAAwZ,GAAAzb,GAAAH;;IARFkB,QAAA6c,sBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICJA,IAAA3c,eAAA/B,QAAA;IACA,IAAAE,SAAAF,QAAA;IAOA,IAAAioB,gBAAA;MACE,SAAAA,cAAAhmB,OAAAoF,KAAAtD;QACU7B,KAAAD,QAAAA;QACAC,KAAAmF,MAAAA;QACAnF,KAAA6B,QAAAA;;MAGJkkB,cAAA9lB,UAAAmF,UAAA;QAAW,OAAAC,UAAArF,WAAA,GAAAsF,SAAA;;;YACf,IAAA,MAAAtF,KAAA6B,MAAA3C,QACE,MAAA,IAAAyC,MAAA;YAIF3B,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAoT,eAAAzW,KAAA6B;YAEMhD,OAAA,IAAAmD;YACN,KAAAO,KAAA,GAAAC,KAAAxC,KAAA6B,OAAAU,KAAAC,GAAAtD,QAAAqD,MAAA;cAAWhB,IAAAiB,GAAAD;cAET,KAAAvC,KAAAD,MAAAyB,SAAAD,IAA6B;cACvBpB,OAAAH,KAAAD,MAAAsC,OAAAd;cACN,IAAApB,MAAA;gBAGEA,KAAAE,SAAArC,OAAAsC,SAAAoB,UACE1B,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAuT,oBAAAzW,KAAAE,MAAA,IAAAQ,GAAAC,KAAAS,EAAA3C,GAAA2C,EAAA9C;gBAMFuB,KAAAD,MAAA2E,QAAAnD,GAAA;gBACA1C,KAAA+D,IAAArB,EAAA3C;;;YAKJoB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAA4R,cAAAvU,MAAAC,KAAA9B;;;;;MAEJ,OAAAknB;KAtCA;IAAapmB,QAAAomB,gBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICXP,IAAAvjB,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAON,IAAAikB,sBAAA,SAAA/jB;MAAyCC,UAAA8jB,qBAAA/jB;MAAzC,SAAA+jB;QAAA,IAAAnoB,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAEE8B,MAAAooB,WAAA;QAGApoB,MAAAqoB,YAAA;QAGAroB,MAAAsoB,QAAA;QAGAtoB,MAAAgW,WAAA;QAGAhW,MAAAuoB,YAAA;QAGAvoB,MAAAwoB,aAAA;QAGAxoB,MAAAyoB,gBAAA;QAEQzoB,MAAA0oB,YAAA;;;MAMRP,oBAAAhqB,UAAA6Y,OAAA;QAAA,IAAAhX,QAAA9B;QACE,OAAA,IAAAsF,QAAA,SAAA6N;;UACE,IAAArR,MAAA0oB,WAAA;YACErX;YACA;;UAGF,KAAArR,MAAA0F,SAAA3G,GAAAoY,QAAAnX,MAAA0F,OAAA;YACEhH,QAAAyG,KAAA;YACAkM;YACA;;UAGFrR,MAAA0oB,YAAA;UAGA,IAAA1oB,MAAAooB,UAAA;YACEpoB,MAAA2oB,UAAA3oB,MAAAooB,UAAApoB,MAAAuoB;YACAvoB,MAAAooB,SAAAQ;;UAIF,IAAA5oB,MAAAqoB,WAAA;YACEroB,MAAA2oB,UAAA3oB,MAAAqoB,WAAAroB,MAAAwoB;YACAxoB,MAAAqoB,UAAAO;;UAIF5oB,MAAA6oB;UAGA,IAAAC,SAAA;YACE9oB,MAAA0oB,YAAA;YACA1oB,MAAA0F,QAAA3G,GAAAoY,QAAAnX,MAAA0F,SACE1F,MAAA0F,KAAA0R;YAEF/F;;WAIF,UAAA3Q,KAAAV,MAAAooB,kBAAA,MAAA1nB,UAAA,IAAAA,GAAAgF,SAAA3G,GAAAoY,QAAAnX,MAAAooB,SAAA1iB,SACE1F,MAAAooB,SAAA1iB,KAAAwP,KAAA,YAAA4T;WAEF,UAAA3iB,KAAAnG,MAAAqoB,mBAAA,MAAAliB,UAAA,IAAAA,GAAAT,SAAA3G,GAAAoY,QAAAnX,MAAAqoB,UAAA3iB,SACE1F,MAAAqoB,UAAA3iB,KAAAwP,KAAA,YAAA4T;UAIF3S,WAAA;YACEnW,MAAA0oB,aACEI;aAEJ,MAAA9oB,MAAAgW;;;MAOImS,oBAAAhqB,UAAA0qB,sBAAA;;QAEN,IAAAE,cAAAhqB,GAAA0b,KAAAuO;QACA,IAAAC,cAAAF,YAAAG;QACA,IAAAC,eAAAJ,YAAAK;QACA,IAAAC,WAAA,MAAAnsB,KAAAqC,IAAA0pB,aAAAE;QAGA,KAAA,UAAAzoB,KAAAxC,KAAAkqB,kBAAA,MAAA1nB,UAAA,IAAAA,GAAAgF,SAAA3G,GAAAoY,QAAAjZ,KAAAkqB,SAAA1iB,OAAA;UACE,IAAA4jB,eAAAprB,KAAAqqB,YAAArrB,KAAAqsB,KAAA;UACA,IAAAC,iBAAAtsB,KAAAusB,IAAAH;UACA,IAAAI,iBAAAxsB,KAAAysB,IAAAL;UAEA,IAAAM,WAAA1rB,KAAAkqB,SAAA1iB,KAAA5I,IAAA0sB,iBAAAH;UACA,IAAAQ,WAAA3rB,KAAAkqB,SAAA1iB,KAAA/I,IAAA+sB,iBAAAL;UAEA,IAAAS,iBAAA/qB,GAAAiZ,OAAA9Z,KAAA8X,UAAA4T,UAAAC;UACA3rB,KAAAkqB,SAAA1iB,KAAAiT,UAAAmR;;QAIF,KAAA,UAAA3jB,KAAAjI,KAAAmqB,mBAAA,MAAAliB,UAAA,IAAAA,GAAAT,SAAA3G,GAAAoY,QAAAjZ,KAAAmqB,UAAA3iB,OAAA;UACE,IAAAqkB,gBAAA7rB,KAAAsqB,aAAAtrB,KAAAqsB,KAAA;UACA,IAAAS,kBAAA9sB,KAAAusB,IAAAM;UACA,IAAAE,kBAAA/sB,KAAAysB,IAAAI;UAEA,IAAAG,YAAAhsB,KAAAmqB,UAAA3iB,KAAA5I,IAAAktB,kBAAAX;UACA,IAAAc,YAAAjsB,KAAAmqB,UAAA3iB,KAAA/I,IAAAstB,kBAAAZ;UAEA,IAAAe,kBAAArrB,GAAAiZ,OAAA9Z,KAAA8X,UAAAkU,WAAAC;UACAjsB,KAAAmqB,UAAA3iB,KAAAiT,UAAAyR;;;MAOIjC,oBAAAhqB,UAAAwqB,YAAA,SAAA0B,gBAAAC;QACN,KAAAD,mBAAAtrB,GAAAoY,QAAAkT,iBAAA;UACE3rB,QAAAyG,KAAA;UACA;;QAKAklB,eAAAE,qBAAA;QAIFF,eAAArU,WAAA9X,KAAA8X;QACAqU,eAAAG,OAAA,KAAAtsB,KAAA8X;QACAqU,eAAA/B,QAAA,KAAApqB,KAAAoqB;QACA+B,eAAAC,QAAAA;QACAD,eAAAI,WAAA;QAGAJ,eAAAK,YAAA;QACAL,eAAAM,UAAA;QACAN,eAAAO,eAAA;QACAP,eAAAQ,aAAA;QAGAR,eAAA5oB,aAAA1C,GAAA/B,MAAA,KAAA,KAAA,KAAA;QACAqtB,eAAAS,WAAA/rB,GAAA/B,MAAA,KAAA,KAAA,IAAA;QACAqtB,eAAAU,gBAAAhsB,GAAA/B,MAAA,IAAA,IAAA,IAAA;QACAqtB,eAAAW,cAAAjsB,GAAA/B,MAAA,IAAA,IAAA,IAAA;QAGAqtB,eAAAY,eAAA;QACAZ,eAAAa,iBAAA;QAGAb,eAAAc,UAAApsB,GAAAwZ,GAAA,GAAA;QACA8R,eAAAe,kBAAA;QACAf,eAAAgB,cAAA;QACAhB,eAAAiB,WAAA;QAGAjB,eAAAkB,YAAAxsB,GAAAwZ,GAAA,GAAA;QACA8R,eAAAmB,SAAAzsB,GAAAwZ,GAAA,GAAA;QACA8R,eAAAoB,eAAA1sB,GAAA6X,eAAA8U,aAAAC;QAGAtB,eAAAuB,YAAA;QACAvB,eAAAwB,UAAA;QACAxB,eAAAyB,eAAA;QACAzB,eAAA0B,aAAA;QACA1B,eAAA2B,gBAAA;;MAMF7D,oBAAAhqB,UAAA8tB,OAAA;QACE/tB,KAAAwqB,YAAA;QACAxqB,KAAAkqB,YAAArpB,GAAAoY,QAAAjZ,KAAAkqB,aACElqB,KAAAkqB,SAAA8D;QAEFhuB,KAAAmqB,aAAAtpB,GAAAoY,QAAAjZ,KAAAmqB,cACEnqB,KAAAmqB,UAAA6D;;MAxLJxhB,WAAA,EADCxG,SAAAnF,GAAA6X,mBACyCuR,oBAAAhqB,WAAA,iBAAA;MAG1CuM,WAAA,EADCxG,SAAAnF,GAAA6X,mBAC0CuR,oBAAAhqB,WAAA,kBAAA;MAG3CuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,IAAA,GAAA;YACmBma,oBAAAhqB,WAAA,cAAA;MAGpBuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,IAAA,GAAA;YACsBma,oBAAAhqB,WAAA,iBAAA;MAGvBuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,GAAA,KAAA;YACuBma,oBAAAhqB,WAAA,kBAAA;MAGxBuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,GAAA,KAAA;YACuBma,oBAAAhqB,WAAA,mBAAA;MAGxBuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAgP;QAAAC,OAAA,EAAA,GAAA,KAAA;YAC0Bma,oBAAAhqB,WAAA,sBAAA;MApBhBgqB,sBAAAzd,WAAA,EADZzG,aACYkkB;MA6Lb,OAAAA;KA7LA,CAAAppB,GAAA6L;IAAa/M,QAAAsqB,sBAAAA;IA+LbtqB,QAAA8K,UAAAwf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICtMQ,IAAAlkB,UAAAlF,GAAAiF,WAAAC;IA4BR,IAAAkoB,mBAAA,SAAA/nB;MAAsCC,UAAA8nB,kBAAA/nB;MAAtC,SAAA+nB;;;MAEEA,iBAAAhuB,UAAA+C,QAAA;QACE,IAAAkrB,OAAAC,OAAAC;QACA,IAAA5mB,OAAAxH,KAAAwH;QACA,IAAA6mB,cAAA7mB,KAAAM,aAAA;QACA,KAAAumB,gBAAAH,MAA2B;QAE3BG,YAAAC,cAAAJ,KAAAtvB;QACAyvB,YAAAE,eAAAL,KAAAlD,QAAAkD,KAAAtvB;QACAyvB,YAAAG,gBAAAN,KAAAzvB;QACA4vB,YAAAI,aAAAP,KAAAhD,SAAAgD,KAAAzvB;;MAXSwvB,mBAAAzhB,WAAA,EADZzG,aACYkoB;MAab,OAAAA;KAbA,CAAAptB,GAAA6L;IAAa/M,QAAAsuB,mBAAAA;;;;;;;;;;;ICjBb,IAAA5M,yBAAA;MAIE,SAAAA,uBAAAqN;aAAoB,MAAAA,eAAAA,aAAA;QAAA1uB,KAAA0uB,aAAAA;;MAOpBrN,uBAAAphB,UAAA6iB,YAAA,SAAAkC;QACE,OAAAhmB,KAAA2vB,IAAA3J,OAAA,GAAA,KAAAhlB,KAAA0uB;;MAEJ,OAAArN;KAdA;IAAa1hB,QAAA0hB,yBAAAA;;;;;;;;;;;;;;;;;;;;ICPA1hB,QAAAioB,QAAA;MACXC,YAAA;MACAE,iBAAA;MACAC,kBAAA;MACAQ,YAAA;MACAN,cAAA;;;;;;;;;;;;ICJF,IAAAroB,eAAA/B,QAAA;IAEA,IAAA8wB,iBAAA;MAEE,SAAAA,eAAA7uB,OAAAihB,QAAA7b,KAAAid;aAIU,MAAAA,gBAAAA,cAAA;QAHApiB,KAAAD,QAAAA;QACAC,KAAAghB,SAAAA;QACAhhB,KAAAmF,MAAAA;QACAnF,KAAAoiB,cAAAA;QALFpiB,KAAA6uB,eAAA;;MAcRD,eAAA3uB,UAAA6uB,cAAA;QACE,IAAA9uB,KAAAghB,OAAAhd,YAEE;QAGF,IAAAhE,KAAA6uB,eAAA7uB,KAAAoiB,aAAA;UAEEpiB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAA+S;UAEApW,KAAA6uB;UAEA7uB,KAAA+uB;eAGA/uB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAgT;;MAQJuY,eAAA3uB,UAAA8uB,UAAA;;;QACE,IAAA5wB,MAAA6B,KAAAD,MAAA5B;QACA,IAAAK,QAAA;QAGA,KAAA,IAAAC,IAAA,GAAAA,IAAAN,IAAAO,MAAAD,KACE,KAAA,IAAAG,IAAA,GAAAA,IAAAT,IAAAU,MAAAD,KACEJ,MAAAW,KAAAa,KAAAD,MAAAsC,OAAA,IAAAxB,GAAAC,KAAAlC,GAAAH;QAKJ,KAAA,IAAA4I,IAAA7I,MAAAU,SAAA,GAAAmI,IAAA,GAAAA,KAAA;UACE,IAAAkc,IAAAvkB,KAAAC,MAAAD,KAAAmc,YAAA9T,IAAA;UACA7E,KAAA,EAAAhE,MAAA+kB,IAAA/kB,MAAA6I,MAAA7I,MAAA6I,KAAA7E,GAAA,IAAAhE,MAAA+kB,KAAA/gB,GAAA;;QAIF,IAAA6O,MAAA;QACA,KAAA,IAAAzS,IAAA,GAAAA,IAAAT,IAAAU,MAAAD,KACE,KAAA,IAAAH,IAAA,GAAAA,IAAAN,IAAAO,MAAAD,KACEuB,KAAAD,MAAA2E,QAAA,IAAA7D,GAAAC,KAAAlC,GAAAH,IAAA,UAAAwJ,KAAAzJ,MAAA6S,gBAAA,MAAApJ,KAAAA,KAAA;QAKJjI,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAiT;;MAMFsY,eAAA3uB,UAAAmQ,QAAA;QACEpQ,KAAA6uB,eAAA;;MAEJ,OAAAD;KAzEA;IAAajvB,QAAAivB,iBAAAA;;;;;;;;;;;;;ICNb,IAAA/uB,eAAA/B,QAAA;IAMA,IAAA0jB,kBAAA;MAOE,SAAAA,gBAAArc;;QAAA,IAAArD,QAAA9B;QAAoBA,KAAAmF,MAAAA;QAFZnF,KAAAmlB,WAAA;QAIN,IAAAljB,OAAAO,KAAA,IACEA,GAAA3C,aAAAwD,WAAAwT,eAAA,cACArU,GAAA3C,aAAAwD,WAAAyT,cAAA;QACAtU,GAAA3C,aAAAwD,WAAAiS,YAAA,aACA9S,GAAA3C,aAAAwD,WAAAmT,YAAA;QACAhU,GAAA3C,aAAAwD,WAAAqT,oBAAA,cACAlU,GAAA3C,aAAAwD,WAAAuT,sBAAA;QACApU,GAAA3C,aAAAwD,WAAA+O,oBAAA,cACA5P,GAAA3C,aAAAwD,WAAA2G,mBAAA;QACAxH,GAAA3C,aAAAwD,WAAAyS,yBAAA,kBACAtT,GAAA3C,aAAAwD,WAAAsS,WAAA;QACAnT,GAAA3C,aAAAwD,WAAAuS,YAAA,aACApT,GAAA3C,aAAAwD,WAAAmS,YAAA;QACAhT,GAAA3C,aAAAwD,WAAAoS,aAAA,YACDjT;QAGD8B,OAAAyC,KAAA9E,KAAAiC,QAAA,SAAAkhB;UACE,IAAAR,UAAA;YAAA,OAAApD,gBAAA1I,KAAA7W,IAAAmjB;;UACAtjB,MAAAqD,IAAA4E,GAAAqb,KAAAR;UACA9iB,MAAAqjB,SAAAC,OAAAR;;;MAKJpD,gBAAAvhB,UAAAiZ,UAAA;QAAA,IAAApX,QAAA9B;QACEsE,OAAAyC,KAAA/G,KAAAmlB,UAAAjhB,QAAA,SAAAkhB;UACEtjB,MAAAqD,IAAA2F,IAAAsa,KAAAtjB,MAAAqjB,SAAAC;;QAEFplB,KAAAmlB,WAAA;;MAIa3D,gBAAA1I,OAAA,SAAA5J;QACb,IAAA8f,SAAAxN,gBAAAyN,MAAA/f;QACA,IAAA8f,QAAA;UACEnuB,GAAAquB,YAAAC,WAAAH,QAAA;UACA;;QAEFnuB,GAAAgI,UAAAC,KAAA,YAAAoG,MAAArO,GAAAuuB,WAAA,SAAApmB,KAAAqmB;UACE,IAAArmB,QAAAqmB,MAAkB;UAClB7N,gBAAAyN,MAAA/f,QAAAmgB;UACAxuB,GAAAquB,YAAAC,WAAAE,MAAA;;;MAjDW7N,gBAAAyN,QAAA;MAoDjB,OAAAzN;KAtDA;IAAa7hB,QAAA6hB,kBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICPP,IAAAhf,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAON,IAAAspB,kBAAA,SAAAppB;MAA6CC,UAAAmpB,iBAAAppB;MAA7C,SAAAopB;QAAA,IAAAxtB,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAEE8B,MAAA4I,iBAAA7J,GAAA8J,MAAAC;QAGA9I,MAAA+I,mBAAA;QAEQ/I,MAAAytB,gBAAA1uB,GAAA8J,MAAAoe;QACAjnB,MAAA0tB,kBAAA;QACA1tB,MAAA2tB,gBAAA;QACA3tB,MAAA4tB,SAAA;;;MAERJ,gBAAArvB,UAAA+N,SAAA;QACEhO,KAAA0vB,SAAA1vB,KAAAwH,KAAAM,aAAAjH,GAAA+H;QACA,IAAA5I,KAAA0vB,QAAA;UAEE1vB,KAAAuvB,gBAAAvvB,KAAAwH,KAAA1I,MAAA+gB;UACA7f,KAAAwvB,kBAAAxvB,KAAAwH,KAAAmH;;;MAOG2gB,gBAAArvB,UAAA0vB,kBAAA;QACL3vB,KAAAyvB,gBACEzvB,KAAA6L,mBAEA7L,KAAAyL;;MAOG6jB,gBAAArvB,UAAAwL,eAAA;QACL,KAAAzL,KAAA0vB,QAAkB;QAElB1vB,KAAAyvB,gBAAA;QACAzvB,KAAAwH,KAAA1I,QAAAkB,KAAA0K;QACA1K,KAAAwH,KAAAmH,UAAA3O,KAAA6K;;MAMKykB,gBAAArvB,UAAA4L,iBAAA;QACL,KAAA7L,KAAA0vB,QAAkB;QAElB1vB,KAAAyvB,gBAAA;QACAzvB,KAAAwH,KAAA1I,QAAAkB,KAAAuvB;QACAvvB,KAAAwH,KAAAmH,UAAA3O,KAAAwvB;;MAMKF,gBAAArvB,UAAA2vB,qBAAA;QACL,OAAA5vB,KAAAyvB;;MAMKH,gBAAArvB,UAAA4vB,oBAAA,SAAA/wB;QACLkB,KAAA0K,iBAAA5L;QACAkB,KAAAyvB,iBAAAzvB,KAAA0vB,WACE1vB,KAAAwH,KAAA1I,QAAAA;;MAOGwwB,gBAAArvB,UAAA6vB,sBAAA,SAAAnhB;QACL3O,KAAA6K,mBAAA8D;QACA3O,KAAAyvB,iBAAAzvB,KAAA0vB,WACE1vB,KAAAwH,KAAAmH,UAAAA;;MAOG2gB,gBAAArvB,UAAA8vB,uBAAA;QACL,IAAA/vB,KAAA0vB,QAAA;UACE1vB,KAAAuvB,gBAAAvvB,KAAAwH,KAAA1I,MAAA+gB;UACA7f,KAAAwvB,kBAAAxvB,KAAAwH,KAAAmH;;;MAOG2gB,gBAAArvB,UAAA+vB,kBAAA;QACLhwB,KAAA6L;QACA7L,KAAA+vB;;MAGFT,gBAAArvB,UAAAsM,YAAA;QAEEvM,KAAA6L;;MAnGFW,WAAA,EADCxG,SAAAnF,GAAA8J,UAC0C2kB,gBAAArvB,WAAA,uBAAA;MAG3CuM,WAAA,EADCxG,SAAA;QAAA4J,MAAA/O,GAAAovB;QAAAngB,OAAA,EAAA,GAAA,KAAA;YAC8Bwf,gBAAArvB,WAAA,yBAAA;MALZqvB,kBAAA9iB,WAAA,EADpBzG,aACoBupB;MAuGrB,OAAAA;KAvGA,CAAAzuB,GAAA6L;IAAqB/M,QAAA8K,UAAA6kB;;;;;;;;;;;;;;;;;;;;;ICLrB,IAAAtxB,SAAAF,QAAA;IAEA,IAAA+B,eAAA/B,QAAA;IAUA,IAAAkP,mBAAA;MAIE,SAAAA,iBAAAxE,IAAAzI,OAAAgN,SAAA5H,KAAA+qB,KAAAvpB,SAAAtG;QAEUL,KAAAD,QAAAA;QACAC,KAAA+M,UAAAA;QACA/M,KAAAmF,MAAAA;QACAnF,KAAAkwB,MAAAA;QAEAlwB,KAAAK,OAAAA;QAERL,KAAAwI,KAAAA;QACAxI,KAAA2G,UAAAA;;MAGFqG,iBAAA/M,UAAAkS,cAAA;QACE,OAAAnS,KAAA2G,UAAA;;MAGFqG,iBAAA/M,UAAA+C,QAAA;QAAA,IAAAlB,QAAA9B;QACE,IAAAmwB,UAAA,SAAA/vB;UACE0B,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAA6G,kBAAAkmB;UACAtuB,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAA2R,eAAAmb;UACA,IAAAruB,MAAA6E,WAAA,GAAuB;UACvB,IAAApF,IAAAnB;UACA,IAAAD,OAAA2B,MAAA/B,MAAAsC,OAAAd;UACA,KAAApB,QAAAA,KAAAE,SAAArC,OAAAsC,SAAAoB,QAA4C;UAK5CI,MAAAouB,IAAA3d,QAAAzQ,MAAA0G;UACA,IAAA6nB,YAAA1e,SAAAA,SAAA,IAAAxR,OAAA;YAAAE,MAAAyB,MAAAzB;;UACAyB,MAAA/B,MAAA2E,QAAAnD,GAAA8uB;UACA,IAAA9T,OAAAza,MAAAiL,QAAAxL;UACA,SAAAgb,aAAA,MAAAA,YAAA,IAAAA,KAAAnW,MAAAiqB;UACAvuB,MAAAqD,IAAA/B,KAAAvD,aAAAwD,WAAAsT,iBAAA;YACEtW,MAAAyB,MAAAzB;YACAwX,UAAAtW;;;QAIJ,IAAA6uB,WAAA;UACEtuB,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAA2R,eAAAmb;UACAruB,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAA6G,kBAAAkmB;;QAGFpwB,KAAAmF,IAAA4E,GAAAlK,aAAAwD,WAAA2R,eAAAmb;QACAnwB,KAAAmF,IAAA4E,GAAAlK,aAAAwD,WAAA6G,kBAAAkmB;;MAEJ,OAAApjB;KApDA;IAAarN,QAAAqN,mBAAAA;;;;;;;;;;;;;;ICdb,IAAAnP,aAAAC,QAAA;IAEA,IAAAE,SAAAF,QAAA;IAMA,IAAAooB,mBAAA;MAIE,SAAAA,iBAAA/nB;QAAoB6B,KAAA7B,MAAAA;QAElB6B,KAAA5B,MAAAD,IAAAE,UAAAR,WAAAM,IAAAE,WAAAW,KAAAmc;;MAQF+K,iBAAAjmB,UAAAkmB,OAAA,SAAAmK;aAAK,MAAAA,aAAAA,WAAAtwB,KAAA5B;QACH,IAAAmyB,UAAAvwB,KAAA7B,IAAAwV;QAEA,IAAA4c,SAAA;UAEE,IAAAC,aAAA;UAEAA,cAAAD,QAAA5xB;UACA,IAAA2xB,WAAAE,YAA2B,OAAAxyB,OAAAsC,SAAAC;UAE3BiwB,cAAAD,QAAA3c;UACA,IAAA0c,WAAAE,YAA2B,OAAAxyB,OAAAsC,SAAAS;UAE3ByvB,cAAAD,QAAA1c;UACA,IAAAyc,WAAAE,YAA2B,OAAAxyB,OAAAsC,SAAAU;UAE3B,OAAAhD,OAAAsC,SAAAmB;;QAGA,IAAA6uB,WAAA,IAAoB,OAAAtyB,OAAAsC,SAAAC;QACpB,IAAA+vB,WAAA,IAAoB,OAAAtyB,OAAAsC,SAAAS;QACpB,IAAAuvB,WAAA,KAAqB,OAAAtyB,OAAAsC,SAAAU;QACrB,OAAAhD,OAAAsC,SAAAmB;;MAGN,OAAAykB;KAvCA;IAAavmB,QAAAumB,mBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICLb,IAAArmB,eAAA/B,QAAA;IAKA,IAAA2yB,cAAA;MACE,SAAAA,YAAA1wB,OAAAuc,GAAA/T,GAAApD;QACUnF,KAAAD,QAAAA;QACAC,KAAAsc,IAAAA;QACAtc,KAAAuI,IAAAA;QACAvI,KAAAmF,MAAAA;;MAGJsrB,YAAAxwB,UAAAmF,UAAA;QAAW,OAAAC,UAAArF,WAAA,GAAAsF,SAAA;;;YACf,KAAAtF,KAAAD,MAAAyB,SAAAxB,KAAAsc,OAAAtc,KAAAD,MAAAyB,SAAAxB,KAAAuI,IACE,MAAA,IAAA5G,MAAA;YAEI+uB,KAAA1wB,KAAAD,MAAAsC,OAAArC,KAAAsc;YACAqU,KAAA3wB,KAAAD,MAAAsC,OAAArC,KAAAuI;YACNvI,KAAAD,MAAA2E,QAAA1E,KAAAsc,GAAAqU;YACA3wB,KAAAD,MAAA2E,QAAA1E,KAAAuI,GAAAmoB;YAEA1wB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAmT,UAAAxW,KAAAsc,GAAAtc,KAAAuI;;;;;MAEJ,OAAAkoB;KAnBA;IAAa9wB,QAAA8wB,cAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICLb,IAAAG,gBAAA9yB,QAAA;IACA,IAAAkH,gBAAAlH,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IAkBA,IAAAgP,kBAAA;MAGE,SAAAA,gBAAA/M,OAAAoF,KAAAwB,SASUkqB;aAAA,MAAAA,gBAAAA,cAAA;QARA7wB,KAAAD,QAAAA;QACAC,KAAAmF,MAAAA;QAOAnF,KAAA6wB,cAAAA;QAXV7wB,KAAAwI,KAAA;QAaExI,KAAA2G,UAAAA;;MAGFmG,gBAAA7M,UAAAkS,cAAA;QACE,OAAAnS,KAAA2G,UAAA;;MAGFmG,gBAAA7M,UAAA+C,QAAA;QAAA,IAAAlB,QAAA9B;QACE,IAAAA,KAAA2G,WAAA,GAAA;UAEE3G,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAA6G;UACA;;QAGF,IAAA4mB,QAAA;QAEA,IAAAC,iBAAA;UACEjvB,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAA2R,eAAAgc;UACAlvB,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAA2R,eAAAic;UACAnvB,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAAyT,YAAAxL;UACAxJ,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAA6G,kBAAA6mB;UACAD,QAAA;;QAGF,IAAAxlB,SAAA;UACExJ,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAA2R,eAAAic;UACAnvB,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAAyT,YAAAxL;UACAxJ,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAA6G,kBAAA6mB;UACAD,QAAA;UACAhvB,MAAAqD,IAAA/B,KAAAvD,aAAAwD,WAAA6G;UAEAgnB;;QAGF,IAAAD,WAAA,SAAAE;UAAA,OAAA9rB,UAAAvD,YAAA,QAAA,GAAA;;;;;gBACE,IAAA9B,KAAA2G,WAAA,MAAAmqB,OAAiC,OAAA,EAAA;gBAC3BvoB,IAAA4oB;gBAEN,IAAA5oB,EAAA3J,MAAAkyB,MAAAlyB,KAAA2J,EAAA9J,MAAAqyB,MAAAryB,GAAA;kBACE6M;kBACA,OAAA,EAAA;;gBAEFtL,KAAAmF,IAAA2F,IAAAjL,aAAAwD,WAAA2R,eAAAic;gBACAjxB,KAAAmF,IAAA2F,IAAAjL,aAAAwD,WAAAyT,YAAAxL;gBACAtL,KAAAmF,IAAA2F,IAAAjL,aAAAwD,WAAA6G,kBAAA6mB;gBACA/wB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAyS,uBAAA;kBACEtN,IAAAxI,KAAAwI;kBACAmV,OAAA;kBACAvd,KAAAmI;;gBAIImoB,KAAA1wB,KAAAD,MAAAsC,OAAAyuB;gBACAH,KAAA3wB,KAAAD,MAAAsC,OAAAkG;gBAGN,OAAA,EAAA,GAAA,IAAAqoB,cAAAH,YAAAzwB,KAAAD,OAAA+wB,OAAAvoB,GAAAvI,KAAAmF,KAAAC;;;gBAAA5C,GAAAiD;gBAEA,IAAAzF,KAAA6wB,aAAA;kBACQ7P,SAAA,IAAAhc,cAAAlF,YAAAE,KAAAD;kBACN,KAAAihB,OAAAhd,YAAA;oBAEE,IAAA0sB,MAAAC,IAAA;sBACE3wB,KAAAD,MAAA2E,QAAAosB,OAAAJ;sBACA1wB,KAAAD,MAAA2E,QAAA6D,GAAAooB;;oBAEF3wB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAkT;oBACA,OAAA,EAAA;;;gBAIJvW,KAAA2G;gBACA3G,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAA2G,iBAAAhK,KAAAwI;;;;;;QAGF,IAAAwoB,UAAA,SAAAI;UACEtvB,MAAAqD,IAAA2F,IAAAjL,aAAAwD,WAAA2R,eAAAgc;UACAF,QAAAM;UACAtvB,MAAAqD,IAAA/B,KAAAvD,aAAAwD,WAAAyS,uBAAA;YACEtN,IAAA1G,MAAA0G;YACAmV,OAAA;YACAvd,KAAA0wB;;UAEFhvB,MAAAqD,IAAA4E,GAAAlK,aAAAwD,WAAA2R,eAAAic;UAEAnvB,MAAAqD,IAAA4E,GAAAlK,aAAAwD,WAAAyT,YAAAxL;;QAGF,IAAA4lB,QAAA;UACEpvB,MAAAqD,IAAA4E,GAAAlK,aAAAwD,WAAA2R,eAAAgc;UACAlvB,MAAAqD,IAAA4E,GAAAlK,aAAAwD,WAAA6G,kBAAA6mB;;QAIFG;;MAEJ,OAAApkB;KA9GA;IAAanN,QAAAmN,kBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICvBP,IAAAtK,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAEN,IAAAhI,SAAAF,QAAA;IACA,IAAA8e,iBAAA9e,QAAA;IAQA,IAAAuzB,uBAAA,SAAAnrB;MAA0CC,UAAAkrB,sBAAAnrB;MAA1C,SAAAmrB;QAAA,IAAAvvB,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAUE8B,MAAAzB,OAAArC,OAAAsC,SAAAoB;QAMAI,MAAAwvB,UAAA;QAOAxvB,MAAAyvB,aAAA;;;MAvBWC,yBAAAH;MA2BXA,qBAAApxB,UAAA+N,SAAA;QACEhO,KAAAuxB,cACE3U,eAAAtF,aAAAC,UAAAvX,KAAAK,MAAAL,KAAAuxB;;;MA3BoBF,qBAAAI,SAAA5wB,GAAA6wB;MAQxBllB,WAAA,EALCxG,SAAA;QACC4J,MAAA4hB,uBAAAC,SACED,uBAAAC,OAAAzzB,OAAAsC,YACAtC,OAAAsC;YAE6B+wB,qBAAApxB,WAAA,aAAA;MAMjCuM,WAAA,EADCxG,SAAAnF,GAAA4L,WACgC4kB,qBAAApxB,WAAA,gBAAA;MAOjCuM,WAAA,EADCxG,SAAAnF,GAAA4L,WACmC4kB,qBAAApxB,WAAA,mBAAA;MAvBzBoxB,uBAAAG,yBAAAhlB,WAAA,EADZzG,aACYsrB;MAgCb,OAAAA;KAhCA,CAAAxwB,GAAA6L;IAAa/M,QAAA0xB,uBAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICXP,IAAA7uB,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAEN,IAAA+K,iBAAAjT,QAAA;IACA,IAAA8B,aAAA9B,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IACA,IAAAsd,wBAAAtd,QAAA;IAIA,IAAA6zB,sBAAA,SAAAzrB;MAAiDC,UAAAwrB,qBAAAzrB;MAAjD,SAAAyrB;QAAA,IAAA7vB,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAEE8B,MAAA2Z,aAAA;;;MAIAkW,oBAAA1xB,UAAA+N,SAAA;QAAA,IAAAlM,QAAA9B;QACEA,KAAA2b,YAAA3b,KAAA8H,aAAAsT,sBAAA3Q;QACAjK,QAAA0I,IAAA,8BAAAlJ,KAAA2b;QACA,IAAA,MAAA3b,KAAAyb,WAAAuP,SAAA,MAAAhrB,KAAAyb,WAAAyP,QAAA;UACE,IAAA/sB,MAAA4S,eAAAgD;UACA/T,KAAAyb,WAAAuP,QAAA7sB,IAAAU,OAAAV,IAAAqV;UACAxT,KAAAyb,WAAAyP,SAAA/sB,IAAAO,OAAAP,IAAAsV;;QAIFzT,KAAAyb,WAAA1R,GAAAlJ,GAAAkK,KAAAC,UAAAC,WAAA,SAAA2mB;UAGI,IAAAC,WAAAD,EAAAE;UACA,IAAAC,QAAAjwB,MAAA2Z,WAAAuW,qBAAAH;UAEA,IAAAje,MAAA5U,KAAAC,OAAA8yB,MAAAnzB,IAAAkD,MAAA2Z,WAAAuP,QAAA,KAAAja,eAAAgD,kBAAAP;UAGA,IAAA7U,MAAAK,KAAAC,OAAA6C,MAAA2Z,WAAAyP,SAAA,KAAA6G,MAAAtzB,IAAA,OAEIsS,eAAAgD,kBAAAN;UAEJ3R,MAAAmwB,UAAAre,KAAAjV;WACFqB;;MAKJ2xB,oBAAA1xB,UAAAgyB,YAAA,SAAAre,KAAAjV;;QACE,IAAA4d,OAAA,UAAA/Z,KAAAxC,KAAA2b,UAAAE,UAAAld,cAAA,MAAA6D,UAAA,IAAAA,GAAAoR;QACA,KAAA2I,SAAAA,KAAAiL,iBAAA;UACEhnB,QAAA6R,MAAA,gCAAA,SAAAkK,aAAA,MAAAA,YAAA,IAAAA,KAAA,gBAAA,sBAAA,SAAAA,aAAA,MAAAA,YAAA,IAAAA,KAAA,uBAAA,UAAA3I,MAAA,MAAAjV,MAAA;UAMAiB,WAAAuD,SAAAC,KAAAvD,aAAAwD,WAAAyT,YAAA,IAAAjW,GAAAC,KAAA8S,KAAAjV;UACA;;QAEF6B,QAAA6R,MAAA,mCAAAuB,MAAA,MAAAjV,MAAA;QACAiB,WAAAuD,SAAAC,KAAAvD,aAAAwD,WAAA2R,eAAA,IAAAnU,GAAAC,KAAA8S,KAAAjV;;MA9CF6N,WAAA,EADCxG,SAAAnF,GAAAkK,SAC0B4mB,oBAAA1xB,WAAA,mBAAA;MAFR0xB,sBAAAnlB,WAAA,EADpBzG,aACoB4rB;MAkDrB,OAAAA;KAlDA,CAAA9wB,GAAA6L;IAAqB/M,QAAA8K,UAAAknB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICTb,IAAA5rB,UAAAlF,GAAAiF,WAAAC;IAER,IAAAnG,aAAA9B,QAAA;IACA,IAAA+B,eAAA/B,QAAA;IACA,IAAAsd,wBAAAtd,QAAA;IAGA,IAAAo0B,oBAAA,SAAAhsB;MAA+CC,UAAA+rB,mBAAAhsB;MAA/C,SAAAgsB;;;MAGEA,kBAAAjyB,UAAA+N,SAAA;QACEhO,KAAA2b,YAAA3b,KAAA8H,aAAAsT,sBAAA3Q;QACA7K,WAAAuD,SAAA4G,GAAAlK,aAAAwD,WAAAwT,aAAA7W,KAAAmyB,eAAAnyB;;MAGMkyB,kBAAAjyB,UAAAkyB,gBAAA,SAAA/xB;;QACN,IAAAmc,OAAA,UAAA/Z,KAAAxC,KAAA2b,UAAAE,UAAAzb,IAAA3B,YAAA,MAAA+D,UAAA,IAAAA,GAAApC,IAAAxB;QACA,SAAA2d,aAAA,MAAAA,YAAA,IAAAA,KAAA6V;;MAViBF,oBAAA1lB,WAAA,EADpBzG,aACoBmsB;MAYrB,OAAAA;KAZA,CAAArxB,GAAA6L;IAAqB/M,QAAA8K,UAAAynB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICPf,IAAA1vB,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAGN,IAAAhI,SAAAF,QAAA;IACA,IAAA0zB,yBAAA1zB,QAAA;IACA,IAAAuZ,gBAAAvZ,QAAA;IAOA,IAAAu0B,WAAA,SAAAnsB;MAAsCC,UAAAksB,UAAAnsB;MAAtC,SAAAmsB;QAAA,IAAAvwB,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAGE8B,MAAAmY,aAAA;QAIAnY,MAAAwwB,iBAAA;QASAxwB,MAAAywB,gBAAA,IAAA7xB,MAAA1C,OAAAsC,SAAAmB,aAAA,GAAA4C,KAAA;QAGQvC,MAAA0wB,gBAAA;QAGA1wB,MAAAyvB,aAAA;QAMDzvB,MAAAyb,WAAA1c,GAAAwZ,GAAA,GAAA;QAGCvY,MAAA2wB,YAAA;QAEA3wB,MAAA4wB,mBAAA;;;MAGRL,SAAApyB,UAAAunB,gBAAA;QACE,QAAAxnB,KAAAyyB,cAAAzyB,KAAA0yB;;MAIFL,SAAApyB,UAAA0Z,YAAA;QACE3Z,KAAAyyB,YAAA;;MAIFJ,SAAApyB,UAAAya,UAAA;QACE1a,KAAAyyB,YAAA;;MAQFJ,SAAApyB,UAAAmG,QAAA,SAAAjG;QACEH,KAAAG,OAAAA;QAGA,IAAAqX;QACA,IAAArX,KAAAE,SAAArC,OAAAsC,SAAAoB,QAAA;UACE,IAAA2P,MAAArR,KAAA2yB,WAAAxyB,KAAArB;UACA0Y,SAAAxX,KAAAsyB,eAAAjhB;eAEAmG,SAAAxX,KAAAuyB,cAAApyB,KAAAE;QAEF,KAAAmX,QAAa;QAGb,IAAAxX,KAAAwyB,eAAA;UAEE,IAAA/Y,QAAAzZ,KAAAwyB;UACA,sBAAA/Y,MAAAP,WACEO,MAAAP;UAEFlZ,KAAAwyB,gBAAA;;QAIF,IAAAhrB,OAAA3G,GAAA4G,YAAA+P;QACAhQ,KAAA2Q,SAAAnY,KAAAia;QACAja,KAAAwyB,gBAAAhrB;QAGA,IAAArJ,MAAAqJ,KAAAM,aAAA0pB,uBAAAH;QACA,IAAAlzB,KAAA;UACE6B,KAAAuxB,aAAApzB,IAAAozB;UACA,IAAApzB,IAAAmzB,SAAA;YACE,IAAAsB,KAAA/xB,GAAA4G,YAAAtJ,IAAAmzB;YACAsB,GAAAza,SAAAnY,KAAAwH;;eAGFxH,KAAAuxB,aAAA;;MAOJc,SAAApyB,UAAA4yB,gBAAA;;QACE,IAAA7yB,KAAAuxB,YAAA;UACE,IAAAqB,KAAA/xB,GAAA4G,YAAAzH,KAAAuxB;UAEA,IAAApZ,SAAAnY,KAAAwH,KAAA2Q,WAEG,UAAAlQ,MAAAzF,KAAA3B,GAAAuX,UAAAC,kBAAA,MAAApQ,UAAA,IAAAA,GAAAmE,KAAA5J;UACHowB,GAAAza,SAAAA,UAAAnY,KAAAwH;UACAorB,GAAAhrB,YAAA5H,KAAAwH,KAAAqQ;UAEA,IAAAjG,WAAAghB,GAAA9qB,aAAAuP,cAAAkB;UACA,SAAA3G,iBAAA,MAAAA,gBAAA,IAAAA,SAAAkH;UAEA9Y,KAAAuxB,aAAA;;;MAMJc,SAAApyB,UAAAmyB,gBAAA;QAAA,IAAAtwB,QAAA9B;QACEA,KAAA0yB,mBAAA;QACA,IAAA1Y,SAAAha,KAAAwH;QAEA,IAAAsrB,gBAAAjyB,GAAAwZ,GAAA,GAAA;QAEA,IAAAZ,QAAAO;QAIA,sBAAAP,MAAA1N,kBAAgD0N,MAAA1N;QAChD,sBAAA0N,MAAA/K,YAA0C+K,MAAA/K,SAAA,GAAA;QAG1CsL,OAAAS,UAEG5Z,GAAA0Z,SAAA1Z,GAAA2Z,QAAA,KAAA,KAAA3Z,GAAA2Z,QAAA,IAAA,IAAA3Z,GAAAkZ,SAAA;UAIGC,OAAAI,eAAA0Y;UACAhxB,MAAA4wB,mBAAA;;;MAOAL,SAAApyB,UAAA0yB,aAAA,SAAA7zB;QACN,IAAAi0B,QAAA,EAAA,OAAA,QAAA,SAAA,UAAA;QACA,IAAA1hB,MAAA0hB,MAAAzhB,QAAAxS;QACA,OAAAuS,OAAA,IAAAA,MAAA;;MAlJF7E,WAAA,EADCxG,SAAAnF,GAAAkK,SAC0BsnB,SAAApyB,WAAA,mBAAA;MAI3BuM,WAAA,EADCxG,SAAA,EAAAnF,GAAA4L,aACgC4lB,SAAApyB,WAAA,uBAAA;MASjCuM,WAAA,EADCxG,SAAA,EAAAnF,GAAA4L,aAC2E4lB,SAAApyB,WAAA,sBAAA;MAhBzDoyB,WAAA7lB,WAAA,EADpBzG,aACoBssB;MAuJrB,OAAAA;KAvJA,CAAAxxB,GAAA6L;IAAqB/M,QAAA8K,UAAA4nB;;;;;;;;;;;;;;;ICArB,IAAA/xB;KAAA,SAAAA;MAEEA,SAAAA,SAAA,YAAA,KAAA;MAEAA,SAAAA,SAAA,cAAA,KAAA;MAEAA,SAAAA,SAAA,cAAA,KAAA;MAEAA,SAAAA,SAAA,eAAA,KAAA;MAEAA,SAAAA,SAAA,gBAAA,KAAA;MAVF,CAWAA,WAAAX,QAAAW,aAAAX,QAAAW,WAAA;IAiBA,IAAAlB,cAAA;MAAA,SAAAA;MASgBA,YAAAC,eAAA,SAAAP;QACZ,OAAA;UACE0J,MAAAxI,KAAAgzB;UACAl0B,OAAAA;UACAuB,MAAAC,SAAAoB;;;MAXWtC,YAAA4zB,SAAA;MAcjB,OAAA5zB;KAhBA;IAAaO,QAAAP,cAAAA;;;;;;;;;;;ICvCb,IAAAS,eAAA/B,QAAA;IACA,IAAAwjB,cAAA;MAWE,SAAAA,YAAA2R,cAAA9tB;QAEUnF,KAAAmF,MAAAA;QAERnF,KAAAizB,eAAAA;QACAjzB,KAAAkzB,YAAAD;;MASF3R,YAAArhB,UAAA2iB,UAAA;QACE5iB,KAAAkzB;QACAlzB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAmS,UAAAxV,KAAAkzB;QACA,MAAAlzB,KAAAkzB,aACElzB,KAAAmF,IAAA/B,KAAAvD,aAAAwD,WAAAqS;;MAOJ4L,YAAArhB,UAAAyiB,eAAA;QACE,OAAA1iB,KAAAkzB;;MAMF5R,YAAArhB,UAAAmQ,QAAA;QACEpQ,KAAAkzB,YAAAlzB,KAAAizB;;MAEJ,OAAA3R;KA9CA;IAAa3hB,QAAA2hB,cAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICFP,IAAA9e,KAAA3B,GAAAiF,YAAAC,UAAAvD,GAAAuD,SAAAC,WAAAxD,GAAAwD;IAMN,IAAAuS,cAAA,SAAArS;MAAiCC,UAAAoS,aAAArS;MAAjC,SAAAqS;QAAA,IAAAzW,QAAA,SAAAoE,UAAAA,OAAAE,MAAApG,MAAAqG,cAAArG;QAEE8B,MAAA0W,kBAAA;QAGA1W,MAAA6W,aAAA;QAGA7W,MAAAqxB,SAAA;;;MAKA5a,YAAAtY,UAAA6Y,OAAA;QAAA,IAAAhX,QAAA9B;QACE,IAAAozB,WAAA;QAEW,IAAAhsB,UAAA,SAAAisB;UACT,KAAAA,IAAkB,OAAA;UAGjBA,GAAAhH,qBACC;UACF+G,SAAAj0B,KAAA,IAAAmG,QAAA,SAAA6N;YAEI,IAAA6G,SAAA,sBAAAqZ,GAAArc,OAEIqc,KAGAA,GAAA7rB;YACJwS,OAAAhD,KAAA,YAAA7D;YACAkgB,GAAA3I;;;QAfN,KAAA,IAAAnoB,KAAA,GAAAC,KAAAxC,KAAAwY,iBAAAjW,KAAAC,GAAAtD,QAAAqD,MAAA;UAAK,IAAA8wB,KAAA7wB,GAAAD;UAAM6E,QAAAisB;;QAoBA,IAAA/L,UAAA,SAAAgM;UACT,KAAAA,MAAoB,OAAA;UACpBF,SAAAj0B,KAAA,IAAAmG,QAAA,SAAA6N;YAEImgB,KAAAtc,KAAA,YAAA7D;YACAmgB,KAAAxa;;;QALN,KAAA,IAAA7Q,KAAA,GAAAU,KAAA3I,KAAA2Y,YAAA1Q,KAAAU,GAAAzJ,QAAA+I,MAAA;UAAK,IAAAqrB,OAAA3qB,GAAAV;UAAMqf,QAAAgM;;QAUA,IAAAlL,UAAA,SAAA3lB;UACT,KAAAA,OAAqB,OAAA;UACrB,IAAA8wB,WAAA9wB;UAIA,IAAA,sBAAA8wB,SAAAza,MAAA;YACE,IAAA/U,SAAAwvB,SAAAza;YACAsa,SAAAj0B,KAAAmG,QAAA6N,QAAApP;iBACK,sBAAAwvB,SAAAvc,QACLoc,SAAAj0B,KAAA,IAAAmG,QAAA,SAAA6N;YAEIogB,SAAAvc,KAAA,YAAA7D;;;QAZR,KAAA,IAAA+E,KAAA,GAAAsb,KAAAxzB,KAAAmzB,QAAAjb,KAAAsb,GAAAt0B,QAAAgZ,MAAA;UAAK,IAAAzV,QAAA+wB,GAAAtb;UAAMkQ,QAAA3lB;;QAkBX,IAAA,MAAA2wB,SAAAl0B,QAAA;UACEc,KAAAwH,KAAA0R;UACA,OAAA5T,QAAA6N;;QAGF,OAAA7N,QAAA2gB,IAAAmN,UAAAra,KAAA;UACEjX,MAAA0F,KAAA0R;;;MApEJ1M,WAAA,EADCxG,SAAA,EAAAnF,GAAA6X,qBACyCH,YAAAtY,WAAA,wBAAA;MAG1CuM,WAAA,EADCxG,SAAA,EAAAnF,GAAA+X,gBAC+BL,YAAAtY,WAAA,mBAAA;MAGhCuM,WAAA,EADCxG,SAAA,EAAAnF,GAAA6L,gBAC2B6L,YAAAtY,WAAA,eAAA;MARjBsY,cAAA/L,WAAA,EADZzG,aACYwS;MAyEb,OAAAA;KAzEA,CAAA1X,GAAA6L;IAAa/M,QAAA4Y,cAAAA;IA2Eb5Y,QAAA8K,UAAA8N;;;;;;;ICrEA1X,GAAA4yB,WAGI5yB,GAAA4yB,OAAAC,8BAAA","sourcesContent":["// Utility for generating a random board with a \"dead-start\" guard.\n// The generator ensures at least one pair of orthogonally adjacent tiles\n// share the same color so the player always has an opening move.\n\nimport * as seedrandom from \"seedrandom\";\nimport { Board } from \"./Board\";\nimport { TileFactory, TileColor, Tile } from \"./Tile\";\nimport { BoardConfig } from \"../../config/ConfigLoader\";\n\n/**\n * Creates fully populated boards filled with normal tiles.\n * Randomness can be seeded for deterministic results.\n */\nexport class BoardGenerator {\n  /**\n   * Generates a board according to provided configuration.\n   *\n   * - For each cell picks a random color from `cfg.colors`.\n   * - Ensures there is at least one horizontal or vertical pair of\n   *   adjacent tiles with the same color. This prevents a \"dead start\"\n   *   when the player would have no available moves.\n   * - If such a pair is not found the board is regenerated.\n   *   Up to 10 attempts are made before the last board is returned.\n   *\n   * @param cfg Board configuration controlling size and available colors.\n   */\n  public generate(cfg: BoardConfig): Board {\n    // Initialize deterministic or default RNG using seedrandom\n    const rng = cfg.rngSeed ? seedrandom(cfg.rngSeed) : seedrandom();\n\n    // Try up to 10 times to avoid dead-start boards\n    let last: (Tile | null)[][] = [];\n    for (let attempt = 0; attempt < 10; attempt++) {\n      // Build a 2D matrix of tiles\n      const tiles: (Tile | null)[][] = [];\n      for (let y = 0; y < cfg.rows; y++) {\n        const row: (Tile | null)[] = [];\n        for (let x = 0; x < cfg.cols; x++) {\n          // Pick a random color from the list\n          const color = cfg.colors[\n            Math.floor(rng() * cfg.colors.length)\n          ] as TileColor;\n          row.push(TileFactory.createNormal(color));\n        }\n        tiles.push(row);\n      }\n\n      // Check for at least one adjacent pair of the same color\n      if (BoardGenerator.adjacentSameColor(tiles)) {\n        return new Board(cfg, tiles);\n      }\n      // Save last attempt to return if all retries fail\n      last = tiles;\n      // Otherwise loop and generate a new board\n    }\n\n    // After 10 unsuccessful attempts return the last generated board\n    // even if it does not contain a valid move.\n    // This edge case should be extremely unlikely with reasonable board sizes.\n    return new Board(cfg, last);\n  }\n\n  /**\n   * Scans the grid for horizontally or vertically adjacent tiles\n   * that share the same color.\n   *\n   * @param tiles Matrix of tiles to analyze.\n   * @returns True if at least one matching pair is found.\n   */\n  private static adjacentSameColor(tiles: (Tile | null)[][]): boolean {\n    for (let y = 0; y < tiles.length; y++) {\n      for (let x = 0; x < tiles[y].length; x++) {\n        const current = tiles[y][x];\n        if (!current) continue;\n\n        // Compare to right neighbour\n        if (x + 1 < tiles[y].length) {\n          const right = tiles[y][x + 1];\n          if (right && right.color === current.color) {\n            return true;\n          }\n        }\n        // Compare to bottom neighbour\n        if (y + 1 < tiles.length) {\n          const bottom = tiles[y + 1][x];\n          if (bottom && bottom.color === current.color) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n}\n","import { EventBus } from \"../EventBus\";\nimport { EventNames } from \"../events/EventNames\";\nimport { Board } from \"./Board\";\nimport { Tile, TileKind } from \"./Tile\";\nimport { BoardConfig } from \"../../config/ConfigLoader\";\n\n/**\n * Provides algorithms for analyzing the board state.\n */\nexport class BoardSolver {\n  constructor(private board: Board) {}\n\n  /**\n   * Expands removal area when a super tile is part of a group.\n   * Each branch covers a specific {@link TileKind}.\n   * A Set is not used here because the caller performs deduplication.\n   */\n  expandGroupForSuper(tile: Tile, pos: cc.Vec2): cc.Vec2[] {\n    const cfg = (this.board as unknown as { cfg: BoardConfig }).cfg;\n    switch (tile.kind) {\n      case TileKind.SuperRow:\n        console.info(\n          `Activated SuperRow at (${pos.x},${pos.y}): removing row ${pos.y}`,\n        );\n        // All cells of the same row are affected. Duplicates are avoided\n        // by the caller using a Set for the final group.\n        return Array.from(\n          { length: cfg.cols },\n          (_, x) => new cc.Vec2(x, pos.y),\n        );\n      case TileKind.SuperCol:\n        console.info(\n          `Activated SuperCol at (${pos.x},${pos.y}): removing column ${pos.x}`,\n        );\n        // Entire column is removed regardless of color.\n        return Array.from(\n          { length: cfg.rows },\n          (_, y) => new cc.Vec2(pos.x, y),\n        );\n      case TileKind.SuperBomb: {\n        const radius = 1;\n        console.info(\n          `Activated SuperBomb at (${pos.x},${pos.y}): removing radius ${radius}`,\n        );\n        const cells: cc.Vec2[] = [];\n        for (let dx = -radius; dx <= radius; dx++) {\n          for (let dy = -radius; dy <= radius; dy++) {\n            if (Math.max(Math.abs(dx), Math.abs(dy)) <= radius) {\n              const p = new cc.Vec2(pos.x + dx, pos.y + dy);\n              if (this.board.inBounds(p)) cells.push(p);\n            }\n          }\n        }\n        return cells;\n      }\n      case TileKind.SuperClear: {\n        console.info(\n          `Activated SuperClear at (${pos.x},${pos.y}): removing entire board`,\n        );\n        // Every tile on the board will be removed.\n        const cells: cc.Vec2[] = [];\n        for (let y = 0; y < cfg.rows; y++) {\n          for (let x = 0; x < cfg.cols; x++) {\n            cells.push(new cc.Vec2(x, y));\n          }\n        }\n        return cells;\n      }\n      default:\n        if (tile.kind !== TileKind.Normal) {\n          throw new Error(`Unhandled super tile kind: ${tile.kind}`);\n        }\n        // Normal tiles do not expand the group.\n        return [pos];\n    }\n  }\n\n  /**\n   * Recursively expands a given group by activating any super tiles within.\n   *\n   * The algorithm mirrors the super-tile expansion portion of {@link findGroup}\n   * but works on an arbitrary set of coordinates. This allows callers that\n   * construct groups manually (e.g. row/column clears or bomb blasts) to reuse\n   * the same chain-reaction logic.\n   *\n   * @param group Initial coordinates to expand\n   * @returns New array including all tiles affected by triggered super tiles\n   */\n  expandBySupers(group: cc.Vec2[]): cc.Vec2[] {\n    const resultSet = new Set<string>(group.map((p) => `${p.x},${p.y}`));\n    const queue = group.filter((p) => {\n      const t = this.board.tileAt(p);\n      return t !== null && t.kind !== TileKind.Normal;\n    });\n\n    while (queue.length > 0) {\n      const p = queue.pop() as cc.Vec2;\n      const tile = this.board.tileAt(p);\n      if (!tile) continue;\n      for (const extra of this.expandGroupForSuper(tile, p)) {\n        const k = `${extra.x},${extra.y}`;\n        if (!resultSet.has(k)) {\n          resultSet.add(k);\n          const t = this.board.tileAt(extra);\n          if (t && t.kind !== TileKind.Normal) {\n            queue.push(extra);\n          }\n        }\n      }\n    }\n\n    return Array.from(resultSet).map((k) => {\n      const [x, y] = k.split(\",\").map(Number);\n      return new cc.Vec2(x, y);\n    });\n  }\n\n  /**\n   * Finds all coordinates of tiles connected to the starting point\n   * in four directions that share the same color.\n   *\n   * Uses a flood-fill algorithm with an explicit stack to avoid\n   * potential stack overflows from deep recursion.\n   *\n   * @param start Starting board coordinates\n   * @returns Array of coordinates belonging to the found group\n   */\n  findGroup(start: cc.Vec2): cc.Vec2[] {\n    // Return empty when starting point is invalid or empty\n    if (!this.board.inBounds(start)) {\n      return [];\n    }\n    const startTile = this.board.tileAt(start);\n    if (!startTile) {\n      return [];\n    }\n    // If the player taps a super tile directly, it should activate\n    // immediately without collecting adjacent tiles of the same color.\n    if (startTile.kind !== TileKind.Normal) {\n      const result = this.expandBySupers([start]);\n      EventBus.emit(EventNames.GroupFound, result);\n      return result;\n    }\n\n    const startColor = startTile.color;\n\n    // First, collect all connected tiles of the same color.\n    const colorVisited = new Set<string>();\n    const colorStack: cc.Vec2[] = [start];\n    const baseGroup: cc.Vec2[] = [];\n\n    while (colorStack.length > 0) {\n      const p = colorStack.pop() as cc.Vec2;\n      const key = `${p.x},${p.y}`;\n      if (colorVisited.has(key)) continue;\n      colorVisited.add(key);\n\n      const tile = this.board.tileAt(p);\n      if (!tile || tile.color !== startColor || tile.kind !== TileKind.Normal)\n        continue;\n\n      baseGroup.push(p);\n      // Diagonal tiles are ignored to match game rules.\n      for (const n of this.board.neighbors4(p)) {\n        const nKey = `${n.x},${n.y}`;\n        if (!colorVisited.has(nKey)) {\n          colorStack.push(n);\n        }\n      }\n    }\n\n    const result = this.expandBySupers(baseGroup);\n\n    // Notify listeners that a group has been found\n    EventBus.emit(EventNames.GroupFound, result);\n    return result;\n  }\n\n  /**\n   * Determines whether any valid moves exist on the board.\n   * A move is considered available when two orthogonally\n   * adjacent tiles share the same color.\n   */\n  hasMoves(): boolean {\n    let found = false;\n    // Iterate over all tiles on the board\n    this.board.forEach((p, tile) => {\n      if (found) return; // early exit when at least one move is found\n      // Check 4-directional neighbours for a tile of the same color\n      for (const n of this.board.neighbors4(p)) {\n        const other = this.board.tileAt(n);\n        if (other && other.color === tile.color) {\n          found = true;\n          break;\n        }\n      }\n    });\n    return found;\n  }\n}\n","import { BoardConfig } from \"../../config/ConfigLoader\";\nimport { Tile, TileColor } from \"./Tile\";\n\n/**\n * Two-dimensional game board storing tiles with utility methods.\n */\nexport class Board {\n  /** Configuration describing board dimensions. */\n  private readonly cfg: BoardConfig;\n  /** Matrix of tiles stored by [row][col]. */\n  private readonly grid: (Tile | null)[][];\n\n  /**\n   * Creates a board. If an initial matrix of tiles is not provided, the board\n   * is filled with null values according to the configuration size.\n   * @param cfg Board configuration with rows and columns\n   * @param tiles Optional existing matrix of tiles\n   */\n  constructor(cfg: BoardConfig, tiles?: (Tile | null)[][]) {\n    this.cfg = cfg;\n    this.grid = [];\n    for (let y = 0; y < cfg.rows; y++) {\n      if (tiles && tiles[y]) {\n        // copy provided row and normalize its length\n        const row: (Tile | null)[] = [];\n        for (let x = 0; x < cfg.cols; x++) {\n          row[x] = tiles[y][x] ?? null;\n        }\n        this.grid[y] = row;\n      } else {\n        // create an empty row\n        this.grid[y] = Array(cfg.cols).fill(null);\n      }\n    }\n  }\n\n  get config(): BoardConfig {\n    return this.cfg;\n  }\n\n  /** Number of rows in the board. */\n  public get rows(): number {\n    return this.cfg.rows;\n  }\n\n  /** Number of columns in the board. */\n  public get cols(): number {\n    return this.cfg.cols;\n  }\n\n  /**\n   * Checks whether a point lies within board boundaries.\n   * Coordinates are zero-based and inclusive on the lower bound but exclusive\n   * on the upper bound.\n   * @param p Point to test\n   * @returns True if the point is inside the board\n   */\n  public inBounds(p: cc.Vec2): boolean {\n    return p.x >= 0 && p.y >= 0 && p.x < this.cfg.cols && p.y < this.cfg.rows;\n  }\n\n  /**\n   * Returns the tile located at the given point.\n   * @param p Board coordinates\n   * @returns Tile object or null if the position is empty or out of bounds\n   */\n  public tileAt(p: cc.Vec2): Tile | null {\n    return this.inBounds(p) ? this.grid[p.y][p.x] : null;\n  }\n\n  /**\n   * Returns the color of the tile at the specified point.\n   * @param p Board coordinates\n   * @returns Color of tile or null when no tile is present or point is invalid\n   */\n  public colorAt(p: cc.Vec2): TileColor | null {\n    const tile = this.tileAt(p);\n    return tile ? tile.color : null;\n  }\n\n  /**\n   * Places a tile at the specified position.\n   * Throws an error when coordinates lie outside of the board.\n   * @param p Board coordinates\n   * @param t Tile to place or null to clear the cell\n   */\n  public setTile(p: cc.Vec2, t: Tile | null): void {\n    if (!this.inBounds(p)) {\n      throw new Error(`setTile out of bounds: (${p.x}, ${p.y})`);\n    }\n    this.grid[p.y][p.x] = t;\n  }\n\n  /**\n   * Returns coordinates of orthogonal neighbours of the given point.\n   * Order: up, right, down, left. Points outside the board are omitted.\n   * @param p Central point\n   * @returns Array of neighbouring coordinates\n   */\n  public neighbors4(p: cc.Vec2): cc.Vec2[] {\n    const result: cc.Vec2[] = [];\n    const candidates = [\n      new cc.Vec2(p.x, p.y - 1),\n      new cc.Vec2(p.x + 1, p.y),\n      new cc.Vec2(p.x, p.y + 1),\n      new cc.Vec2(p.x - 1, p.y),\n    ];\n    for (const c of candidates) {\n      if (this.inBounds(c)) {\n        result.push(c);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Iterates over all cells of the board invoking callback for non-null tiles.\n   * @param callback Function called with coordinates and tile\n   */\n  public forEach(callback: (p: cc.Vec2, t: Tile) => void): void {\n    for (let y = 0; y < this.cfg.rows; y++) {\n      for (let x = 0; x < this.cfg.cols; x++) {\n        const tile = this.grid[y][x];\n        if (tile) {\n          callback(new cc.Vec2(x, y), tile);\n        }\n      }\n    }\n  }\n}\n","import { Board } from \"../Board\";\nimport { InfrastructureEventBus } from \"../../../infrastructure/InfrastructureEventBus\";\nimport { ICommand } from \"./ICommand\";\nimport { MoveExecutor } from \"../MoveExecutor\";\nimport { BoardSolver } from \"../BoardSolver\";\n\n/**\n * Collapses all tiles within radius R from the center.\n */\nexport class BombCommand implements ICommand {\n  constructor(\n    private board: Board,\n    private center: cc.Vec2,\n    private radius: number,\n    private bus: InfrastructureEventBus,\n  ) {}\n\n  async execute(): Promise<void> {\n    // Collect coordinates around the center, including the center cell itself.\n    // Iterate over the square [-R, R] and use the condition\n    // max(|dx|, |dy|) <= R, which corresponds to the Chebyshev radius.\n    // Ignore points that are out of board bounds.\n    const group: cc.Vec2[] = [];\n    for (let dx = -this.radius; dx <= this.radius; dx++) {\n      for (let dy = -this.radius; dy <= this.radius; dy++) {\n        if (Math.max(Math.abs(dx), Math.abs(dy)) <= this.radius) {\n          const p = new cc.Vec2(this.center.x + dx, this.center.y + dy);\n          if (this.board.inBounds(p)) group.push(p);\n        }\n      }\n    }\n\n    // Expand the group to trigger the effects of any super tiles.\n    const expanded = new BoardSolver(this.board).expandBySupers(group);\n\n    // Execute the standard pipeline: remove → fall → fill.\n    // Use MoveExecutor to ensure that other tiles fall and empty positions\n    // are filled with new tiles.\n    await new MoveExecutor(this.board, this.bus).execute(expanded);\n  }\n}\n","import { EventBus } from \"../../core/EventBus\";\nimport { EventNames } from \"../../core/events/EventNames\";\nimport { boosterService } from \"../../core/boosters/BoosterSetup\";\nimport { BoosterRegistry } from \"../../core/boosters/BoosterRegistry\";\nimport SpriteHighlight from \"../utils/SpriteHighlight\";\nimport { boosterSelectionService } from \"../services/BoosterSelectionService\";\n\nconst { ccclass, property } = cc._decorator;\n\ninterface BoosterSlot {\n  node: cc.Node;\n  button: cc.Button | null;\n  icon: cc.Sprite | null;\n  counterLabel: cc.Label | null;\n  highlight: SpriteHighlight | null;\n  boosterId: string;\n  charges: number;\n  isActive: boolean;\n}\n\n/**\n * Controller for the booster panel.\n * Manages the display and interaction of booster slots.\n */\n@ccclass()\nexport default class BoosterPanelController extends cc.Component {\n  @property(cc.Node)\n  boosterList: cc.Node = null;\n\n  @property(cc.Prefab)\n  boosterSlotPrefab: cc.Prefab = null;\n\n  @property(cc.Node)\n  boosterLabel: cc.Node = null;\n\n  private boosterSlots: BoosterSlot[] = [];\n\n  start(): void {\n    this.setupEventListeners();\n    const charges = boosterSelectionService.getConfirmedCharges();\n    this.createSlots(charges);\n\n    if (Object.keys(charges).length === 0) {\n      this.boosterLabel.active = false;\n    } else {\n      this.boosterLabel.active = true;\n    }\n  }\n\n  private createSlots(charges: Record<string, number>): void {\n    if (!this.boosterList || !this.boosterSlotPrefab) {\n      console.warn(\"Missing boosterList or boosterSlotPrefab\");\n      return;\n    }\n\n    // Clear existing slots\n    this.boosterList.removeAllChildren();\n    this.boosterSlots = [];\n\n    const entries = Object.entries(charges).filter(([, c]) => c > 0);\n\n    for (let i = 0; i < entries.length; i++) {\n      const [boosterId, count] = entries[i];\n      const node = cc.instantiate(this.boosterSlotPrefab);\n      this.boosterList.addChild(node);\n      node.setPosition(0, 0, 0);\n\n      const button = node.getComponent(cc.Button);\n      const counterLabel =\n        node\n          .getChildByName(\"BoosterCounter\")\n          ?.getChildByName(\"CounterLabel\")\n          ?.getComponent(cc.Label) || null;\n\n      const def = BoosterRegistry.find((b) => b.id === boosterId);\n      if (!def) return;\n\n      const icon =\n        node.getChildByName(\"BoosterIcon\")?.getComponent(cc.Sprite) || null;\n      if (icon) {\n        cc.resources.load(def.icon, cc.SpriteFrame, (err, spriteFrame) => {\n          if (!err && spriteFrame && icon) {\n            icon.spriteFrame = spriteFrame as cc.SpriteFrame;\n          }\n        });\n      }\n      console.log(\"icon\", icon);\n\n      const slot: BoosterSlot = {\n        node,\n        button,\n        icon,\n        counterLabel,\n        highlight: null,\n        boosterId,\n        charges: count,\n        isActive: false,\n      };\n\n      this.addHighlightToSlot(slot);\n      this.setupSlotClickHandler(slot);\n      this.setBoosterIcon(slot, boosterId);\n\n      if (slot.counterLabel) {\n        slot.counterLabel.string = String(count);\n      }\n\n      slot.node.active = true;\n      this.boosterSlots.push(slot);\n    }\n\n    // Force update the layout\n    const layout = this.boosterList.getComponent(cc.Layout);\n    if (layout) {\n      layout.updateLayout();\n    }\n  }\n\n  private setupEventListeners(): void {\n    EventBus.on(EventNames.BoosterConsumed, this.onBoosterConsumed, this);\n    EventBus.on(EventNames.BoosterCancelled, this.onBoosterCancelled, this);\n    EventBus.on(EventNames.BoostersSelected, this.onBoostersSelected, this);\n    EventBus.on(EventNames.GameRestart, this.onGameRestart, this);\n  }\n\n  private setBoosterIcon(slot: BoosterSlot, boosterId: string): void {\n    if (!slot.icon) return;\n    const def = BoosterRegistry.find((b) => b.id === boosterId);\n    if (!def) return;\n    cc.resources.load(def.icon, cc.SpriteFrame, (err, spriteFrame) => {\n      if (!err && spriteFrame && slot.icon) {\n        slot.icon.spriteFrame = spriteFrame as cc.SpriteFrame;\n      }\n    });\n  }\n\n  private addHighlightToSlot(slot: BoosterSlot): void {\n    const highlight = slot.node.addComponent(SpriteHighlight);\n    highlight.highlightColor = cc.Color.YELLOW;\n    highlight.highlightOpacity = 200;\n    slot.highlight = highlight;\n  }\n\n  private setupSlotClickHandler(slot: BoosterSlot): void {\n    if (!slot.button) return;\n    slot.button.node.off(cc.Node.EventType.TOUCH_END);\n    slot.button.node.on(cc.Node.EventType.TOUCH_END, () => {\n      this.handleSlotClick(slot);\n    });\n  }\n\n  private handleSlotClick(clickedSlot: BoosterSlot): void {\n    if (!clickedSlot.boosterId) return;\n    if (clickedSlot.isActive) {\n      this.clearActiveSlot();\n      boosterService?.cancel();\n      return;\n    }\n    this.setActiveSlot(clickedSlot);\n  }\n\n  private setActiveSlot(slot: BoosterSlot): void {\n    this.clearActiveSlot();\n    boosterService?.activate(slot.boosterId);\n    slot.isActive = true;\n    slot.highlight?.setHighlight();\n    this.startPulse(slot.node);\n  }\n\n  private clearActiveSlot(): void {\n    const activeSlot = this.boosterSlots.find((s) => s.isActive);\n    if (activeSlot) {\n      activeSlot.isActive = false;\n      activeSlot.highlight?.clearHighlight();\n      this.stopPulse(activeSlot.node);\n    }\n  }\n\n  private startPulse(node: cc.Node): void {\n    node.stopAllActions();\n    const pulse = () => {\n      cc.tween(node)\n        .to(0.5, { scale: 1.1 })\n        .to(0.5, { scale: 1 })\n        .call(pulse)\n        .start();\n    };\n    pulse();\n  }\n\n  private stopPulse(node: cc.Node): void {\n    node.stopAllActions();\n    node.scale = 1;\n  }\n\n  private onBoosterConsumed(boosterId: string): void {\n    const slot = this.boosterSlots.find((s) => s.boosterId === boosterId);\n    if (slot) {\n      slot.charges = boosterService?.getCharges(boosterId) ?? 0;\n      if (slot.counterLabel) {\n        slot.counterLabel.string = String(slot.charges);\n      }\n      if (slot.charges <= 0) {\n        this.hideBoosterSlot(slot);\n      }\n    }\n\n    // Deactivate any active booster after it has been consumed\n    this.clearActiveSlot();\n  }\n\n  private onBoosterCancelled(): void {\n    this.clearActiveSlot();\n  }\n\n  private onBoostersSelected(charges: Record<string, number>): void {\n    this.createSlots(charges);\n\n    if (Object.keys(charges).length === 0) {\n      this.boosterLabel.active = false;\n    } else {\n      this.boosterLabel.active = true;\n    }\n  }\n\n  private onGameRestart(): void {\n    boosterService?.cancel();\n    this.clearActiveSlot();\n    this.createSlots({});\n  }\n\n  private hideBoosterSlot(slot: BoosterSlot): void {\n    slot.node.active = false;\n    slot.isActive = false;\n    slot.highlight?.clearHighlight();\n    this.stopPulse(slot.node);\n  }\n\n  onDestroy(): void {\n    EventBus.off(EventNames.BoosterConsumed, this.onBoosterConsumed, this);\n    EventBus.off(EventNames.BoosterCancelled, this.onBoosterCancelled, this);\n    EventBus.off(EventNames.BoostersSelected, this.onBoostersSelected, this);\n    EventBus.off(EventNames.GameRestart, this.onGameRestart, this);\n  }\n}\n","import { Board } from \"../board/Board\";\nimport TileView from \"../../ui/views/TileView\";\nimport { InfrastructureEventBus } from \"../../infrastructure/InfrastructureEventBus\";\nimport { BoosterService } from \"./BoosterService\";\nimport { Booster } from \"./Booster\";\nimport { TeleportBooster } from \"./TeleportBooster\";\nimport { SuperTileBooster } from \"./SuperTileBooster\";\nimport { TileKind } from \"../board/Tile\";\n\nexport interface BoosterFactoryParams {\n  board: Board;\n  getView: (p: cc.Vec2) => TileView | undefined;\n  bus: InfrastructureEventBus;\n  boosterService: BoosterService;\n  charges: number;\n}\n\nexport interface BoosterDefinition {\n  id: string;\n  /** Path to sprite used to represent booster in UI */\n  icon: string;\n  factory: (params: BoosterFactoryParams) => Booster;\n}\n\nexport const BoosterRegistry: BoosterDefinition[] = [\n  {\n    id: \"teleport\",\n    icon: \"images/boosters/icon_booster_teleport\",\n    factory: ({ board, bus, charges }) =>\n      new TeleportBooster(board, bus, charges),\n  },\n  {\n    id: \"bomb\",\n    icon: \"images/boosters/icon_booster_bomb\",\n    factory: ({ board, getView, bus, boosterService, charges }) =>\n      new SuperTileBooster(\n        \"bomb\",\n        board,\n        getView,\n        bus,\n        boosterService,\n        charges,\n        TileKind.SuperBomb,\n      ),\n  },\n  {\n    id: \"superRow\",\n    icon: \"images/boosters/icon_booster_superRow\",\n    factory: ({ board, getView, bus, boosterService, charges }) =>\n      new SuperTileBooster(\n        \"superRow\",\n        board,\n        getView,\n        bus,\n        boosterService,\n        charges,\n        TileKind.SuperRow,\n      ),\n  },\n  {\n    id: \"superCol\",\n    icon: \"images/boosters/icon_booster_superCol\",\n    factory: ({ board, getView, bus, boosterService, charges }) =>\n      new SuperTileBooster(\n        \"superCol\",\n        board,\n        getView,\n        bus,\n        boosterService,\n        charges,\n        TileKind.SuperCol,\n      ),\n  },\n];\n","const { ccclass, property } = cc._decorator;\n\n/**\n * Контроллер анимации для BoosterSelectPopup.\n * Оживляет появление элементов с последовательными анимациями.\n */\n@ccclass()\nexport default class BoosterSelectAnimationController extends cc.Component {\n  @property(cc.Node)\n  gameNameLabel: cc.Node = null;\n\n  @property(cc.Node)\n  selectBoosterLabel: cc.Node = null;\n\n  @property(cc.Node)\n  boosterSelectBackground: cc.Node = null;\n\n  @property([cc.Node])\n  boosterSlots: cc.Node[] = [];\n\n  @property(cc.Node)\n  playButton: cc.Node = null;\n\n  // Настройки анимации\n  @property({ type: cc.Float, range: [0.1, 1.0, 0.1] })\n  labelDelay: number = 0.2;\n\n  @property({ type: cc.Float, range: [0.1, 1.0, 0.1] })\n  backgroundDelay: number = 0.4;\n\n  @property({ type: cc.Float, range: [0.1, 1.0, 0.1] })\n  slotsDelay: number = 0.6;\n\n  @property({ type: cc.Float, range: [0.1, 1.0, 0.1] })\n  playButtonDelay: number = 1.2;\n\n  @property({ type: cc.Float, range: [0.1, 0.5, 0.1] })\n  bounceDuration: number = 0.3;\n\n  @property({ type: cc.Float, range: [0.1, 0.5, 0.1] })\n  scaleDuration: number = 0.4;\n\n  @property({ type: cc.Float, range: [0.1, 0.5, 0.1] })\n  rotationDuration: number = 0.3;\n\n  private originalScales: Map<cc.Node, number> = new Map();\n  private originalRotations: Map<cc.Node, cc.Vec3> = new Map();\n\n  onLoad() {\n    this.storeOriginalTransforms();\n    this.hideAllElements();\n  }\n\n  start() {\n    this.checkReferences();\n    this.playEntranceAnimation();\n  }\n\n  /**\n   * Сохраняет оригинальные трансформации элементов\n   */\n  private storeOriginalTransforms(): void {\n    const elements = [\n      this.gameNameLabel,\n      this.selectBoosterLabel,\n      this.boosterSelectBackground,\n      ...this.boosterSlots,\n      this.playButton,\n    ];\n\n    elements.forEach((element) => {\n      if (element) {\n        this.originalScales.set(element, element.scale);\n        this.originalRotations.set(element, element.eulerAngles);\n      } else {\n        console.warn(\"Element is null in storeOriginalTransforms\");\n      }\n    });\n  }\n\n  /**\n   * Скрывает все элементы перед анимацией\n   */\n  private hideAllElements(): void {\n    const elements = [\n      this.gameNameLabel,\n      this.selectBoosterLabel,\n      this.boosterSelectBackground,\n      ...this.boosterSlots,\n      this.playButton,\n    ];\n\n    elements.forEach((element) => {\n      if (element) {\n        element.setScale(0, 0, 0);\n        element.opacity = 0;\n        // НЕ скрываем элемент полностью, только делаем невидимым\n        // element.active = false;\n      } else {\n        console.warn(\"Element is null in hideAllElements\");\n      }\n    });\n  }\n\n  /**\n   * Запускает полную анимацию появления\n   */\n  public playEntranceAnimation(): void {\n    // Анимация лейблов\n    this.scheduleOnce(() => {\n      this.animateLabel(this.gameNameLabel);\n    }, 0);\n\n    this.scheduleOnce(() => {\n      this.animateLabel(this.selectBoosterLabel);\n    }, this.labelDelay);\n\n    // Анимация фона\n    this.scheduleOnce(() => {\n      this.animateBackground();\n    }, this.backgroundDelay);\n\n    // Анимация слотов\n    this.scheduleOnce(() => {\n      this.animateSlots();\n    }, this.slotsDelay);\n\n    // Анимация кнопки\n    this.scheduleOnce(() => {\n      this.animatePlayButton();\n    }, this.playButtonDelay);\n  }\n\n  /**\n   * Анимация лейбла с баунс эффектом\n   */\n  private animateLabel(label: cc.Node): void {\n    if (!label) {\n      console.warn(\"Label is null in animateLabel\");\n      return;\n    }\n\n    console.log(`Animating label: ${label.name}`);\n\n    // Показываем элемент\n    label.active = true;\n    label.opacity = 255;\n    label.setScale(0, 0, 0);\n\n    // Анимация появления с баунс\n    cc.tween(label)\n      .to(this.bounceDuration, { scale: 1 }, { easing: \"backOut\" })\n      .to(this.bounceDuration * 0.5, { scale: 1 }, { easing: \"backOut\" })\n      .start();\n  }\n\n  /**\n   * Анимация фона\n   */\n  private animateBackground(): void {\n    if (!this.boosterSelectBackground) {\n      console.warn(\"BoosterSelectBackground is null\");\n      return;\n    }\n\n    this.boosterSelectBackground.active = true;\n    this.boosterSelectBackground.opacity = 255;\n    this.boosterSelectBackground.setScale(0, 0, 0);\n\n    cc.tween(this.boosterSelectBackground)\n      .to(this.bounceDuration, { scale: 1 }, { easing: \"backOut\" })\n      .to(this.bounceDuration * 0.5, { scale: 1 }, { easing: \"backOut\" })\n      .start();\n  }\n\n  /**\n   * Анимация слотов с ростом и поворотом\n   */\n  private animateSlots(): void {\n    this.boosterSlots.forEach((slot, index) => {\n      if (!slot) {\n        console.warn(`Slot ${index} is null`);\n        return;\n      }\n\n      const delay = index * 0.1; // Небольшая задержка между слотами\n\n      this.scheduleOnce(() => {\n        this.animateSlot(slot);\n      }, delay);\n    });\n  }\n\n  /**\n   * Анимация отдельного слота\n   */\n  private animateSlot(slot: cc.Node): void {\n    if (!slot) return;\n\n    const originalScale = this.originalScales.get(slot) || 1;\n\n    // Начальное состояние\n    slot.active = true;\n    slot.opacity = 255;\n    slot.setScale(originalScale * 0.3);\n\n    // Анимация роста\n    cc.tween(slot)\n      .to(\n        this.scaleDuration,\n        {\n          scale: originalScale,\n        },\n        { easing: \"backOut\" },\n      )\n      .start();\n  }\n\n  /**\n   * Анимация кнопки Play с баунс эффектом\n   */\n  private animatePlayButton(): void {\n    if (!this.playButton) {\n      console.warn(\"PlayButton is null\");\n      return;\n    }\n\n    this.playButton.active = true;\n    this.playButton.opacity = 255;\n    this.playButton.setScale(0, 0, 0);\n\n    cc.tween(this.playButton)\n      .to(this.bounceDuration, { scale: 1.2 }, { easing: \"backOut\" })\n      .to(this.bounceDuration * 0.5, { scale: 1 }, { easing: \"backOut\" })\n      .start();\n  }\n\n  /**\n   * Перезапускает анимацию\n   */\n  public replayAnimation(): void {\n    this.hideAllElements();\n    this.playEntranceAnimation();\n  }\n\n  /**\n   * Быстрое появление всех элементов (без анимации)\n   */\n  public showAllImmediately(): void {\n    console.log(\"Showing all elements immediately\");\n\n    const elements = [\n      this.gameNameLabel,\n      this.selectBoosterLabel,\n      this.boosterSelectBackground,\n      ...this.boosterSlots,\n      this.playButton,\n    ];\n\n    elements.forEach((element) => {\n      if (element) {\n        element.opacity = 255;\n        const originalScale = this.originalScales.get(element) || 1;\n        const originalRotation = this.originalRotations.get(element);\n        element.setScale(originalScale);\n        element.eulerAngles = originalRotation;\n      } else {\n        console.warn(\"Element is null in showAllImmediately\");\n      }\n    });\n  }\n\n  private checkReferences(): void {\n    if (!this.gameNameLabel) {\n      console.error(\n        \"GameNameLabel is null in BoosterSelectAnimationController\",\n      );\n    }\n    if (!this.selectBoosterLabel) {\n      console.error(\n        \"SelectBoosterLabel is null in BoosterSelectAnimationController\",\n      );\n    }\n    if (!this.boosterSelectBackground) {\n      console.error(\n        \"BoosterSelectBackground is null in BoosterSelectAnimationController\",\n      );\n    }\n    if (this.boosterSlots.length === 0) {\n      console.error(\n        \"BoosterSlots array is empty in BoosterSelectAnimationController\",\n      );\n    }\n    if (!this.playButton) {\n      console.error(\"PlayButton is null in BoosterSelectAnimationController\");\n    }\n  }\n}\n","import BoosterSelectAnimationController from \"./BoosterSelectAnimationController\";\nimport { BoosterRegistry } from \"../../core/boosters/BoosterRegistry\";\nimport { boosterSelectionService } from \"../services/BoosterSelectionService\";\nimport SpriteHighlight from \"../utils/SpriteHighlight\";\n\nconst { ccclass, property } = cc._decorator;\n\ninterface BoosterSlot {\n  node: cc.Node;\n  boosterId: string;\n  highlight: SpriteHighlight;\n  icon: cc.Sprite | null;\n}\n\n/**\n * Popup UI that lets the player choose up to two boosters before entering the\n * game. Slots are instantiated from prefab and highlight when selected.\n */\n@ccclass()\nexport default class BoosterSelectPopup extends cc.Component {\n  @property(cc.Node)\n  boosterSlotGrid: cc.Node = null;\n\n  @property(cc.Prefab)\n  boosterSlotPrefab: cc.Prefab = null;\n\n  private slots: BoosterSlot[] = [];\n  private animationController: BoosterSelectAnimationController = null;\n\n  onLoad(): void {\n    this.animationController = this.getComponent(\n      BoosterSelectAnimationController,\n    );\n    boosterSelectionService.reset();\n    this.createSlots();\n  }\n\n  onEnable(): void {\n    boosterSelectionService.reset();\n    this.updateHighlights();\n    this.animationController?.replayAnimation();\n  }\n\n  start(): void {\n    const playButton = this.node.getChildByName(\"PlayButton\");\n    playButton?.on(cc.Node.EventType.TOUCH_END, () => this.startGame());\n  }\n\n  private createSlots(): void {\n    if (!this.boosterSlotGrid || !this.boosterSlotPrefab) {\n      console.warn(\"Missing boosterSlotGrid or boosterSlotPrefab\");\n      return;\n    }\n    this.slots = [];\n\n    for (let i = 0; i < BoosterRegistry.length; i++) {\n      const def = BoosterRegistry[i];\n      const node = cc.instantiate(this.boosterSlotPrefab);\n      this.boosterSlotGrid.addChild(node);\n      node.setPosition(0, 0, 0);\n\n      const icon =\n        node.getChildByName(\"BoosterIcon\")?.getComponent(cc.Sprite) || null;\n      if (icon) {\n        cc.resources.load(def.icon, cc.SpriteFrame, (err, spriteFrame) => {\n          if (!err && spriteFrame && icon) {\n            icon.spriteFrame = spriteFrame as cc.SpriteFrame;\n          }\n        });\n      }\n\n      const highlightedNode = node.getChildByName(\"BoosterSlotBg\");\n      const highlight = highlightedNode.addComponent(SpriteHighlight);\n      highlight.highlightColor = cc.Color.YELLOW;\n      highlight.highlightOpacity = 200;\n\n      const slot: BoosterSlot = {\n        node,\n        boosterId: def.id,\n        highlight,\n        icon: null,\n      };\n\n      node.on(cc.Node.EventType.TOUCH_END, () => this.onSlotClick(slot));\n\n      node.active = true;\n\n      this.slots.push(slot);\n    }\n\n    // Принудительно обновляем Layout\n    const layout = this.boosterSlotGrid.getComponent(cc.Layout);\n    if (layout) {\n      layout.updateLayout();\n    }\n\n    if (this.animationController) {\n      this.animationController.boosterSlots = this.slots.map((s) => s.node);\n    }\n  }\n\n  private onSlotClick(slot: BoosterSlot): void {\n    boosterSelectionService.toggle(slot.boosterId);\n    this.updateHighlights();\n  }\n\n  private updateHighlights(): void {\n    const selected = new Set(boosterSelectionService.getSelected());\n    this.slots.forEach((s) => {\n      if (selected.has(s.boosterId)) {\n        s.highlight.setHighlight();\n      } else {\n        s.highlight.clearHighlight();\n      }\n    });\n  }\n\n  private confirm(): void {\n    console.log(\"BoosterSelectPopup confirm() called\");\n    boosterSelectionService.confirm(); // ← Событие эмитится здесь\n    (this.node as unknown as { active: boolean }).active = false;\n  }\n\n  private startGame(): void {\n    this.confirm();\n  }\n\n  public replayAnimation(): void {\n    if (this.animationController) {\n      this.animationController.replayAnimation();\n    }\n  }\n\n  public showImmediately(): void {\n    if (this.animationController) {\n      this.animationController.showAllImmediately();\n    }\n  }\n}\n","import { EventBus } from \"../../core/EventBus\";\nimport { EventNames } from \"../../core/events/EventNames\";\nimport {\n  loadBoosterLimits,\n  BoosterLimitConfig,\n} from \"../../config/ConfigLoader\";\n\n/**\n * Service that stores which boosters were chosen on the pre-game popup.\n * Player can select up to `maxTypes` boosters. Selecting more will unselect\n * the oldest choice.\n */\nexport class BoosterSelectionService {\n  private static _instance: BoosterSelectionService | null = null;\n\n  static get instance(): BoosterSelectionService {\n    if (!this._instance) {\n      this._instance = new BoosterSelectionService();\n    }\n    return this._instance;\n  }\n\n  private limits: BoosterLimitConfig;\n  private selected: string[] = [];\n  private confirmedCharges: Record<string, number> = {};\n\n  private constructor() {\n    this.limits = loadBoosterLimits();\n  }\n\n  /**\n   * Toggles selection for booster `id`.\n   * If selection exceeds the maximum allowed types, the oldest selection is\n   * removed.\n   * @returns current list of selected booster ids\n   */\n  toggle(id: string): string[] {\n    const idx = this.selected.indexOf(id);\n    if (idx !== -1) {\n      this.selected.splice(idx, 1);\n    } else {\n      if (this.selected.length >= this.limits.maxTypes) {\n        this.selected.shift();\n      }\n      this.selected.push(id);\n    }\n    return this.getSelected();\n  }\n\n  getSelected(): string[] {\n    return [...this.selected];\n  }\n\n  /**\n   * Emits event with selected boosters and their charges.\n   * Each selected booster starts with the maximum amount allowed by config\n   * (defaults to 10).\n   */\n  confirm(): void {\n    const charges: Record<string, number> = {};\n    this.selected.forEach((id) => {\n      const max = this.limits.maxPerType[id] ?? 10;\n      charges[id] = max;\n    });\n    this.confirmedCharges = charges;\n    EventBus.emit(EventNames.BoostersSelected, charges);\n  }\n\n  reset(): void {\n    this.selected = [];\n    this.confirmedCharges = {};\n  }\n\n  getConfirmedCharges(): Record<string, number> {\n    return { ...this.confirmedCharges };\n  }\n}\n\nexport const boosterSelectionService = BoosterSelectionService.instance;\n","import { InfrastructureEventBus } from \"../../infrastructure/InfrastructureEventBus\";\nimport type { Booster } from \"./Booster\";\nimport { EventNames } from \"../events/EventNames\";\nimport type { GameState } from \"../game/GameStateMachine\";\n\n/**\n * Stores all available boosters,\n * handles their activation and publishes events.\n */\nexport class BoosterService {\n  /** Collection of registered boosters by their id. */\n  private boosters: Record<string, Booster> = {};\n  /** Identifier of the currently active booster, if any. */\n  private activeId: string | null = null;\n\n  constructor(\n    private bus: InfrastructureEventBus,\n    /** Provides the current FSM state to guard activation. */\n    private getState: () => GameState,\n  ) {}\n\n  /**\n   * Registers a new booster.\n   * @param boost Instance of the booster to add\n   */\n  register(boost: Booster): void {\n    // Add/overwrite booster by its id\n    this.boosters[boost.id] = boost;\n  }\n\n  /**\n   * Tries to activate a booster by its identifier.\n   * Calls canActivate and, if successful, start and publishes the event.\n   * @param id Identifier of the booster\n   */\n  activate(id: string): void {\n    const boost = this.boosters[id];\n    if (!boost) {\n      // Unknown booster — do nothing\n      return;\n    }\n\n    // If another booster is active, cancel it first\n    if (this.activeId && this.activeId !== id) {\n      this.cancel();\n    }\n\n    // Allow activation only in the WaitingInput state\n    if (this.getState() !== \"WaitingInput\") {\n      return;\n    }\n\n    // Check if activation is possible in the current state\n    if (!boost.canActivate()) {\n      return;\n    }\n\n    // Switch the game to the mode of selecting cells (or cells)\n    boost.start();\n    this.activeId = id;\n    // Notify subscribers about the activation of a specific booster\n    this.bus.emit(EventNames.BoosterActivated, id);\n    console.debug(\n      \"Listeners for BoosterActivated:\",\n      this.bus.getListenerCount(EventNames.BoosterActivated),\n    );\n  }\n\n  /**\n   * Reduces the charges counter and publishes the BoosterConsumed event.\n   * @param id Identifier of the booster\n   */\n  consume(id: string): void {\n    const boost = this.boosters[id];\n    if (!boost) {\n      // If the booster is not found, simply exit\n      return;\n    }\n    if (boost.charges <= 0) {\n      // Nothing to consume, the booster is depleted\n      return;\n    }\n    // Decrease the number of charges\n    boost.charges--;\n    if (this.activeId === id) {\n      this.activeId = null;\n    }\n    // Notify that the charge has been consumed\n    this.bus.emit(EventNames.BoosterConsumed, id);\n  }\n\n  /**\n   * Cancels the activation mode and publishes the BoosterCancelled event.\n   */\n  cancel(): void {\n    if (this.activeId !== null) {\n      this.activeId = null;\n    }\n    // Notify listeners that the activation has been cancelled\n    this.bus.emit(EventNames.BoosterCancelled);\n  }\n\n  /**\n   * Returns the current number of charges for the booster.\n   * @param id Identifier of the booster\n   * @returns Number of remaining charges or 0 if the booster is not found\n   */\n  getCharges(id: string): number {\n    const boost = this.boosters[id];\n    return boost ? boost.charges : 0;\n  }\n}\n","import { EventBus } from \"../EventBus\";\nimport { BoosterService } from \"./BoosterService\";\nimport { Board } from \"../board/Board\";\nimport TileView from \"../../ui/views/TileView\";\nimport type { GameState } from \"../game/GameStateMachine\";\nimport { BoosterRegistry } from \"./BoosterRegistry\";\n\nexport let boosterService: BoosterService | undefined;\n\n/**\n * Initializes BoosterService and registers all super-tile boosters.\n * Should be called during game bootstrap once board and views are ready.\n */\nexport function initBoosterService(\n  board: Board,\n  viewProvider: () => TileView[][],\n  getState: () => GameState,\n  charges: Record<string, number>,\n): void {\n  boosterService = new BoosterService(EventBus, getState);\n  const getView = (p: cc.Vec2): TileView | undefined => {\n    const views = viewProvider();\n    return views[p.y]?.[p.x];\n  };\n  BoosterRegistry.forEach((def) => {\n    const boost = def.factory({\n      board,\n      getView,\n      bus: EventBus,\n      boosterService,\n      charges: charges[def.id] ?? 0,\n    });\n    boosterService.register(boost);\n  });\n}\n","import { BoosterRegistry } from \"../core/boosters/BoosterRegistry\";\n\n// Кеш для загруженной конфигурации\nlet gameConfigCache: {\n  board: BoardConfig;\n  boosterLimits: BoosterLimitConfig;\n} | null = null;\n\n/**\n * Загружает общую конфигурацию игры с кешированием\n */\nfunction loadGameConfig(): {\n  board: BoardConfig;\n  boosterLimits: BoosterLimitConfig;\n} {\n  // Возвращаем кеш, если он уже загружен\n  if (gameConfigCache) {\n    return gameConfigCache;\n  }\n\n  // TODO: Добавить загрузку из JSON файла\n  // В Cocos Creator 2D можно использовать:\n  // - cc.resources.load с колбэком (асинхронно)\n  // - cc.loader.loadRes (если доступен)\n  // - require() (если настроен webpack)\n\n  // Пока используем значения по умолчанию\n  gameConfigCache = {\n    board: DefaultBoard,\n    boosterLimits: DefaultBoosterLimits,\n  };\n\n  return gameConfigCache;\n}\n\n/**\n * Очищает кеш конфигурации (для тестирования или перезагрузки)\n */\nexport function clearConfigCache(): void {\n  gameConfigCache = null;\n}\n\n/**\n * Асинхронно загружает конфигурацию из JSON файла\n * Можно использовать для обновления конфигурации во время выполнения\n */\nexport function loadGameConfigAsync(): Promise<{\n  board: BoardConfig;\n  boosterLimits: BoosterLimitConfig;\n}> {\n  return new Promise((resolve) => {\n    cc.resources.load(\"config/gameConfig\", cc.JsonAsset, (err, asset) => {\n      if (!err && asset) {\n        const config = asset.json as {\n          board: BoardConfig;\n          boosterLimits: BoosterLimitConfig;\n        };\n\n        const result = {\n          board: { ...DefaultBoard, ...config.board },\n          boosterLimits: { ...DefaultBoosterLimits, ...config.boosterLimits },\n        };\n\n        // Обновляем кеш\n        gameConfigCache = result;\n        resolve(result);\n      } else {\n        // Fallback на значения по умолчанию\n        const result = {\n          board: DefaultBoard,\n          boosterLimits: DefaultBoosterLimits,\n        };\n        gameConfigCache = result;\n        resolve(result);\n      }\n    });\n  });\n}\n\n/**\n * BoardConfig описывает параметры игрового поля: количество колонок и строк,\n * размер тайла, список возможных цветов и порог создания супер-тайла.\n */\nexport interface SuperTileChances {\n  row: number;\n  col: number;\n  bomb: number;\n  clear: number;\n}\n\nexport interface BoardConfig {\n  cols: number; // сколько колонок на поле\n  rows: number; // сколько строк на поле\n  tileWidth: number; // ширина одного тайла в пикселях\n  tileHeight: number; // высота одного тайла в пикселях\n  colors: string[]; // допустимые цвета тайлов\n  superThreshold: number; // размер группы для супер-тайла\n  rngSeed?: string; // необязательно: фиксированный seed\n  superChances?: SuperTileChances; // шансы появления супер-тайлов\n}\n\n/** Значения по умолчанию для поля */\nexport const DefaultBoard: BoardConfig = {\n  cols: 9, // классическая ширина\n  rows: 10, // и высота\n  tileWidth: 100, // под размеры подготовленных спрайтов\n  tileHeight: 100,\n  colors: [\"red\", \"blue\", \"green\", \"yellow\", \"purple\"],\n  superThreshold: 5,\n  superChances: {\n    row: 0.5, // 50% шанс SuperRow\n    col: 0.3, // 30% шанс SuperCol\n    bomb: 0.15, // 15% шанс SuperBomb\n    clear: 0.05, // 5% шанс SuperClear\n  },\n};\n\n/**\n * Загружает конфигурацию игрового поля.\n */\nexport function loadBoardConfig(): BoardConfig {\n  const config = loadGameConfig();\n  return config.board;\n}\n\n/** Настройки выбора бустеров при старте. */\nexport interface BoosterLimitConfig {\n  /** Максимальное число различных типов бустеров, которые можно взять. */\n  maxTypes: number;\n  /** Лимиты по каждому типу бустера. */\n  maxPerType: Record<string, number>;\n}\n\n/** Значения по умолчанию для выбора бустеров. */\nexport const DefaultBoosterLimits: BoosterLimitConfig = {\n  maxTypes: 2,\n  maxPerType: Object.fromEntries(BoosterRegistry.map((b) => [b.id, 10])),\n};\n\n/** Загружает настройки лимитов бустеров. */\nexport function loadBoosterLimits(): BoosterLimitConfig {\n  const config = loadGameConfig();\n  const base = { ...config.boosterLimits };\n\n  // Пытаемся загрузить из localStorage, если доступен\n  try {\n    const storage: Partial<Storage> | undefined =\n      (typeof window !== \"undefined\" && window.localStorage) ||\n      (globalThis as unknown as { localStorage?: Partial<Storage> })\n        .localStorage;\n    if (storage && typeof storage.getItem === \"function\") {\n      const raw = storage.getItem(\"boosterLimits\");\n      if (raw) {\n        const data = JSON.parse(raw) as Partial<BoosterLimitConfig>;\n        if (typeof data.maxTypes === \"number\") {\n          base.maxTypes = data.maxTypes;\n        }\n        if (data.maxPerType) {\n          Object.entries(data.maxPerType).forEach(([id, val]) => {\n            if (base.maxPerType[id] !== undefined) {\n              base.maxPerType[id] = val as number;\n            }\n          });\n        }\n      }\n    }\n  } catch (error) {\n    console.warn(\"Failed to load booster limits from localStorage:\", error);\n  }\n\n  return base;\n}\n","// Global event bus now based on cc.EventTarget with diagnostics\nimport { InfrastructureEventBus } from \"../infrastructure/InfrastructureEventBus\";\n\n/**\n * Global EventBus instance used in all parts of the game.\n */\nexport const EventBus = new InfrastructureEventBus();\n","/**\n * Single source of truth for event names.\n * We use string constants because cc.EventTarget expects string names.\n */\nexport const EventNames = {\n  GameStart: \"GameStart\",\n  GameRestart: \"GameRestart\",\n  GroupSelected: \"GroupSelected\",\n  TilesRemoved: \"TilesRemoved\",\n  MoveCompleted: \"MoveCompleted\",\n  FillStarted: \"FillStarted\",\n  FillDone: \"FillDone\",\n  FallStarted: \"FallStarted\",\n  FallDone: \"FallDone\",\n  TurnsInit: \"TurnsInit\",\n  TurnUsed: \"TurnUsed\",\n  TurnEnded: \"TurnEnded\",\n  OutOfTurns: \"OutOfTurns\",\n  GameWon: \"GameWon\",\n  GameLost: \"GameLost\",\n  BoosterActivated: \"BoosterActivated\",\n  BoosterConsumed: \"BoosterConsumed\",\n  BoosterCancelled: \"BoosterCancelled\",\n  BoostersSelected: \"BoostersSelected\",\n  BoosterConfirmed: \"BoosterConfirmed\",\n  BoosterTargetSelected: \"BoosterTargetSelected\",\n  StateChanged: \"StateChanged\",\n  GamePaused: \"GamePaused\",\n  GameResumed: \"GameResumed\",\n  AnimationStarted: \"AnimationStarted\",\n  AnimationEnded: \"AnimationEnded\",\n  AutoShuffle: \"AutoShuffle\",\n  ShuffleLimitExceeded: \"ShuffleLimitExceeded\",\n  ShuffleDone: \"ShuffleDone\",\n  GroupFound: \"GroupFound\",\n  SwapCancelled: \"SwapCancelled\",\n  SwapDone: \"SwapDone\",\n  RemoveStarted: \"RemoveStarted\",\n  SuperTileCreated: \"SuperTileCreated\",\n  SuperTilePlaced: \"SuperTilePlaced\",\n  SuperTileActivated: \"SuperTileActivated\",\n  /** Player pressed a tile (always). */\n  TilePressed: \"TilePressed\",\n  /** Tap is not considered a move (group < 2). */\n  InvalidTap: \"InvalidTap\",\n} as const;\n","/**\n * EventBus — обёртка над cc.EventTarget\n * для публикации/подписки на события внутри игры.\n */\nexport class ExtendedEventTarget extends cc.EventTarget {\n  // Можно добавить вспомогательный метод once,\n  // так как его нет в cc.EventTarget по умолчанию.\n  once(event: string, listener: (...args: unknown[]) => void): void {\n    const callback = (...args: unknown[]) => {\n      this.off(event, callback);\n      listener(...args);\n    };\n    this.on(event, callback);\n  }\n}\n","import { TileKind } from \"../board/Tile\";\nimport { VfxInstance } from \"./VfxInstance\";\n\n/**\n * Utility responsible for coordinating playback of visual effects for\n * super-tiles. It instantiates the appropriate prefab and resolves when the\n * effect finishes playing.\n */\nexport class FXController {\n  /** Registered prefabs for super-tile visual effects. */\n  private static readonly prefabs: Partial<Record<TileKind, cc.Prefab>> = {};\n\n  /** Layer that instantiated effects will be parented to. */\n  private static layer: cc.Node | null = null;\n\n  /** Fallback durations (ms) for each super tile effect. */\n  private static readonly durations: Partial<Record<TileKind, number>> = {\n    [TileKind.SuperBomb]: 400,\n    [TileKind.SuperRow]: 450,\n    [TileKind.SuperCol]: 450,\n  };\n\n  /**\n   * Stores the prefab used for a particular super-tile. Typically invoked\n   * automatically from a component on the super-tile prefab.\n   */\n  static setPrefab(kind: TileKind, prefab: cc.Prefab): void {\n    FXController.prefabs[kind] = prefab;\n  }\n\n  /** Sets the parent node for instantiated VFX. */\n  static setLayer(node: cc.Node): void {\n    FXController.layer = node;\n  }\n\n  /**\n   * Instantiates the VFX prefab for the provided kind, parents it to the\n   * current scene and waits for its {@link VfxInstance} to finish playing.\n   * The instantiated node is destroyed by the instance when playback ends.\n   */\n  static async waitForVfx(kind: TileKind, position?: cc.Vec2): Promise<void> {\n    const prefab = FXController.prefabs[kind];\n    const duration = FXController.durations[kind];\n    if (!prefab) {\n      if (duration) {\n        await new Promise((r) => setTimeout(r, duration));\n      }\n      return;\n    }\n    const node = cc.instantiate(prefab);\n    const parent = FXController.layer || cc.director.getScene?.();\n    parent?.addChild(node);\n    if (position) {\n      node.setPosition(position);\n    }\n    node.zIndex = 9999;\n    const instance =\n      node.getComponent(VfxInstance) || node.addComponent(VfxInstance);\n    if (instance.particleSystems.length === 0) {\n      instance.particleSystems = node.getComponentsInChildren(\n        cc.ParticleSystem,\n      );\n    }\n    if (instance.animations.length === 0) {\n      instance.animations = node.getComponentsInChildren(cc.Animation);\n    }\n    let finished = false;\n    const play = instance.play().then(() => {\n      finished = true;\n    });\n    if (duration) {\n      await Promise.race([\n        play,\n        new Promise<void>((r) => setTimeout(r, duration)),\n      ]);\n      if (!finished && cc.isValid?.(node)) {\n        node.destroy();\n      }\n    } else {\n      await play;\n    }\n  }\n}\n","import TileView from \"../views/TileView\";\n\nexport function runFallAnimation(\n  node: cc.Node,\n  end: cc.Vec2,\n  delay: number = 0,\n  onComplete?: () => void,\n): void {\n  const dist = Math.abs(node.y - end.y);\n  const dur = dist / 1400;\n  const maybe = node as unknown as { stopAllActions?: () => void };\n  if (typeof maybe.stopAllActions === \"function\") maybe.stopAllActions();\n\n  const tileView = node.getComponent(TileView);\n  tileView?.startFall();\n\n  const actions: unknown[] = [];\n  if (delay > 0) actions.push(cc.delayTime(delay));\n  actions.push(cc.moveTo(dur, end.x, end.y));\n\n  if (dist > 0) {\n    actions.push(\n      cc.callFunc(() => {\n        const tileView = node.getComponent(TileView);\n        const target = tileView?.visualRoot ?? node;\n        const prev = target.getAnchorPoint();\n        target.setAnchorPoint(cc.v2(0.5, 0));\n        const bump = cc.sequence(\n          cc.scaleTo(0.1, 1, 0.8),\n          cc.scaleTo(0.1, 1, 1),\n          cc.callFunc(() => target.setAnchorPoint(prev)),\n        );\n        target.runAction(bump);\n      }),\n    );\n  }\n\n  if (onComplete) {\n    actions.push(\n      cc.callFunc(() => {\n        onComplete();\n      }),\n    );\n  }\n  actions.push(\n    cc.callFunc(() => {\n      tileView?.endFall();\n    }),\n  );\n  // cc.sequence expects variadic arguments but TypeScript complains when\n  // spreading an array of `any`. Use apply to avoid the tuple requirement.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  node.runAction((cc.sequence as any).apply(cc, actions));\n}\n","import { Board } from \"../Board\";\nimport { InfrastructureEventBus } from \"../../../infrastructure/InfrastructureEventBus\";\nimport { ICommand } from \"./ICommand\";\nimport { Tile } from \"../Tile\";\nimport { BoardConfig } from \"../../../config/ConfigLoader\";\nimport { EventNames } from \"../../events/EventNames\";\n\n/**\n * Shifts tiles down in specified columns to remove gaps.\n * Emits 'FallStarted' and 'FallDone'. The 'FallDone' event carries\n * the list of coordinates that became empty at the top of columns\n * after falling which should be filled by the next command.\n */\nexport class FallCommand implements ICommand {\n  constructor(\n    private board: Board,\n    private bus: InfrastructureEventBus,\n    private columns: number[],\n  ) {}\n\n  private get cfg(): BoardConfig {\n    // Access board configuration for dimensions without exposing private field\n    return (this.board as unknown as { cfg: BoardConfig }).cfg;\n  }\n\n  async execute(): Promise<void> {\n    if (this.columns.length === 0) {\n      throw new Error(\"FallCommand: no columns specified\");\n    }\n\n    this.bus.emit(EventNames.FallStarted, this.columns);\n\n    const emptySlots: cc.Vec2[] = [];\n    const rows = this.cfg.rows;\n\n    for (const x of this.columns) {\n      const kept: Tile[] = [];\n      // Collect existing tiles from bottom to top\n      for (let y = rows - 1; y >= 0; y--) {\n        const t = this.board.tileAt(new cc.Vec2(x, y));\n        if (t) {\n          kept.push(t);\n        }\n      }\n      // Place tiles starting from bottom\n      let y = rows - 1;\n      for (const t of kept) {\n        this.board.setTile(new cc.Vec2(x, y), t);\n        y--;\n      }\n      // Clear remaining cells and record them as empty\n      for (; y >= 0; y--) {\n        const p = new cc.Vec2(x, y);\n        this.board.setTile(p, null);\n        emptySlots.push(p);\n      }\n    }\n\n    this.bus.emit(EventNames.FallDone, emptySlots);\n  }\n}\n","import { Board } from \"../Board\";\nimport { InfrastructureEventBus } from \"../../../infrastructure/InfrastructureEventBus\";\nimport { ICommand } from \"./ICommand\";\nimport { TileFactory, TileColor } from \"../Tile\";\nimport { BoardConfig } from \"../../../config/ConfigLoader\";\nimport { EventNames } from \"../../events/EventNames\";\n\n/**\n * Generates new tiles in provided empty slots.\n * Emits 'FillStarted' and 'FillDone'. No payload is passed with 'FillDone'.\n */\nexport class FillCommand implements ICommand {\n  constructor(\n    private board: Board,\n    private bus: InfrastructureEventBus,\n    private slots: cc.Vec2[],\n  ) {}\n\n  private get cfg(): BoardConfig {\n    // Retrieve board configuration through type casting to avoid exposing field\n    return (this.board as unknown as { cfg: BoardConfig }).cfg;\n  }\n\n  async execute(): Promise<void> {\n    if (this.slots.length === 0) {\n      throw new Error(\"FillCommand: no slots provided\");\n    }\n\n    this.bus.emit(EventNames.FillStarted, this.slots);\n\n    for (const p of this.slots) {\n      if (!this.board.inBounds(p)) continue;\n      const color = this.randomColor();\n      this.board.setTile(p, TileFactory.createNormal(color));\n    }\n\n    this.bus.emit(EventNames.FillDone);\n  }\n\n  private randomColor(): TileColor {\n    const colors = this.cfg.colors;\n    const idx = Math.floor(Math.random() * colors.length);\n    return colors[idx] as TileColor;\n  }\n}\n","const { ccclass, property } = cc._decorator;\n\nimport { EventBus as bus } from \"../../core/EventBus\";\nimport { EventNames } from \"../../core/events/EventNames\";\nimport GameBoardController from \"./GameBoardController\";\nimport TileView from \"../views/TileView\";\nimport type { Board } from \"../../core/board/Board\";\nimport { runFallAnimation } from \"../utils/FallAnimator\";\nimport { computeTilePosition } from \"../utils/PositionUtils\";\n\n@ccclass()\nexport default class FillController extends cc.Component {\n  /** Base TileNode prefab for new tiles. */\n  @property(cc.Prefab)\n  tileNodePrefab: cc.Prefab = null;\n\n  @property(cc.Node)\n  tilesLayer: cc.Node = null;\n\n  private board!: Board;\n  private tileViews!: TileView[][];\n  /** Slots that are being filled awaiting FillDone */\n  private pending: cc.Vec2[] = [];\n\n  onLoad(): void {\n    const boardCtrl = this.getComponent(GameBoardController)!;\n    this.board = boardCtrl.getBoard();\n    this.tilesLayer = this.node.getChildByName(\"TilesLayer\")!;\n    this.tileViews = boardCtrl.tileViews;\n    bus.on(EventNames.FillStarted, this.onFillStarted, this);\n    bus.on(EventNames.FillDone, this.onFillDone, this);\n  }\n\n  /**\n   * Spawns visual tiles for new board pieces created by FillCommand.\n   * Core.FillCommand updates the model before emitting FillStarted so the\n   * board already contains new tiles when this handler runs.\n   */\n  private onFillStarted(slots: cc.Vec2[]): void {\n    this.tileViews = this.getComponent(GameBoardController)!.tileViews;\n    this.pending = slots;\n\n    const byCol: { [key: number]: cc.Vec2[] } = {};\n    for (let i = 0; i < slots.length; i++) {\n      const p = slots[i];\n      if (!byCol[p.x]) byCol[p.x] = [];\n      byCol[p.x].push(p);\n    }\n\n    const delayStep = 0.1;\n\n    for (const colStr of Object.keys(byCol)) {\n      const list = byCol[parseInt(colStr, 10)];\n      list.sort((a, b) => b.y - a.y); // bottom first\n      for (let index = 0; index < list.length; index++) {\n        const p = list[index];\n        const view = cc\n          .instantiate(this.tileNodePrefab)\n          .getComponent(TileView) as TileView;\n\n        view.node.parent = this.tilesLayer;\n        view.node.active = true;\n        view.node.opacity = 255;\n\n        const start = computeTilePosition(p.x, -1, this.board);\n        view.node.setPosition(start);\n        const end = computeTilePosition(p.x, p.y, this.board);\n        runFallAnimation(view.node, end, index * delayStep);\n\n        view.node.zIndex = this.board.rows - p.y - 1;\n        this.tileViews[p.y][p.x] = view;\n      }\n    }\n  }\n\n  private onFillDone(): void {\n    for (let i = 0; i < this.pending.length; i++) {\n      const p = this.pending[i];\n      const view = this.tileViews[p.y][p.x];\n      if (view) {\n        view.apply(this.board.tileAt(p)!);\n      }\n    }\n    this.pending = [];\n  }\n\n  /**\n   * Updates references after board regeneration.\n   */\n  public reset(board: Board, tileViews: TileView[][]): void {\n    this.board = board;\n    this.tileViews = tileViews;\n    this.pending = [];\n  }\n}\n","const { ccclass, property } = cc._decorator;\n\nimport { Board } from \"../../core/board/Board\";\nimport { BoardGenerator } from \"../../core/board/BoardGenerator\";\nimport { loadBoardConfig } from \"../../config/ConfigLoader\";\nimport TileView from \"../views/TileView\";\nimport MoveFlowController from \"./MoveFlowController\";\nimport FillController from \"./FillController\";\nimport { computeTilePosition } from \"../utils/PositionUtils\";\nimport { EventBus as bus } from \"../../core/EventBus\";\nimport { EventNames } from \"../../core/events/EventNames\";\nimport { FXController } from \"../../core/fx/FXController\";\n\n@ccclass()\nexport default class GameBoardController extends cc.Component {\n  /** Base TileNode prefab. */\n  @property(cc.Prefab)\n  tileNodePrefab: cc.Prefab = null;\n  /** Parent node for all tile instances. */\n  @property(cc.Node)\n  tilesLayer: cc.Node = null;\n\n  /** Board model generated on load. */\n  private board!: Board;\n\n  getBoard(): Board {\n    return this.board;\n  }\n  /** Matrix of view components mirroring board state. */\n  tileViews: TileView[][] = [];\n\n  /** Selected tile highlight for teleport booster. */\n  private teleportSelected: TileView | null = null;\n\n  /**\n   * Generates the game board when this controller loads.\n   *\n   * 1. Loads the board configuration from storage.\n   * 2. Uses {@link BoardGenerator} to create a board model.\n   * 3. Spawns tile prefabs for every cell and stores their views.\n   */\n  onLoad(): void {\n    // 1) Load the board configuration\n    const cfg = loadBoardConfig();\n    // 2) Generate the board\n    this.board = new BoardGenerator().generate(cfg);\n    // 3) Spawn tiles for each cell\n    this.spawnAllTiles();\n    FXController.setLayer(this.tilesLayer);\n    // Attach animation controllers on the same node\n    const flow = this.node.addComponent(MoveFlowController);\n    flow.tilesLayer = this.tilesLayer;\n    const fill = this.node.addComponent(FillController);\n    fill.tileNodePrefab = this.tileNodePrefab;\n    fill.tilesLayer = this.tilesLayer;\n    bus.on(EventNames.BoosterConfirmed, this.onBoosterConfirmed, this);\n    bus.on(\n      EventNames.BoosterTargetSelected,\n      this.onBoosterTargetSelected,\n      this,\n    );\n    bus.on(EventNames.BoosterCancelled, this.clearTeleportHighlight, this);\n    bus.on(EventNames.SwapDone, this.onSwapDone, this);\n    // 4) Create a debug grid\n    // this.createDebugGrid();\n  }\n\n  /**\n   * Instantiates tile prefabs for each board cell and saves TileView references.\n   */\n  private spawnAllTiles(): void {\n    for (let r = 0; r < this.board.rows; r++) {\n      this.tileViews[r] = [];\n      for (let c = 0; c < this.board.cols; c++) {\n        const tileData = this.board.tileAt(new cc.Vec2(c, r))!;\n        const node = cc.instantiate(this.tileNodePrefab);\n        node.parent = this.tilesLayer;\n        // set anchorPoint to (0, 1) for origin (0, 1)\n        node.setAnchorPoint(cc.v2(0, 1));\n        // position exactly as in Core\n        node.setPosition(computeTilePosition(c, r, this.board));\n        // set z-index: each next layer is below\n        node.zIndex = this.board.rows - r - 1;\n        // save TileView for updates\n        const view = node.getComponent(TileView) as TileView;\n        view.apply(tileData);\n        view.boardPos = cc.v2(c, r);\n        this.tileViews[r][c] = view;\n      }\n    }\n  }\n\n  /**\n   * Regenerates the board model and recreates all tile views.\n   * Allows replaying without reloading the scene.\n   */\n  public resetBoard(): void {\n    // Generate fresh board data\n    const cfg = loadBoardConfig();\n    const newBoard = new BoardGenerator().generate(cfg);\n\n    for (let y = 0; y < cfg.rows; y++) {\n      for (let x = 0; x < cfg.cols; x++) {\n        const tile = newBoard.tileAt(new cc.Vec2(x, y));\n        this.board.setTile(new cc.Vec2(x, y), tile);\n      }\n    }\n\n    // Remove old visuals and spawn new ones\n    this.tilesLayer.removeAllChildren();\n    this.tileViews = [];\n    this.spawnAllTiles();\n\n    // Update dependent controllers with new references\n    const flow = this.getComponent(MoveFlowController);\n    flow?.reset(this.board, this.tileViews);\n    const fill = this.getComponent(FillController);\n    fill?.reset(this.board, this.tileViews);\n    this.teleportSelected = null;\n  }\n\n  /**\n   * Spawns a single tile view at the given board position and stores it.\n   */\n  spawn(pos: cc.Vec2): TileView {\n    const tileData = this.board.tileAt(pos)!;\n    const node = cc.instantiate(this.tileNodePrefab);\n    node.parent = this.tilesLayer;\n    node.setAnchorPoint(cc.v2(0, 1));\n    node.setPosition(computeTilePosition(pos.x, pos.y, this.board));\n    node.zIndex = this.board.rows - pos.y - 1;\n    const view = node.getComponent(TileView) as TileView;\n    view.apply(tileData);\n    view.boardPos = cc.v2(pos.x, pos.y);\n    this.tileViews[pos.y][pos.x] = view;\n    return view;\n  }\n\n  private onBoosterConfirmed({ position }: { position: cc.Vec2 }): void {\n    // VFX playback is triggered during the remove flow to avoid duplicates,\n    // so booster confirmation no longer activates the super tile immediately.\n    void position; // parameter kept for event signature\n  }\n\n  private onBoosterTargetSelected({\n    id,\n    stage,\n    pos,\n  }: {\n    id: string;\n    stage: string;\n    pos: cc.Vec2;\n  }): void {\n    if (id !== \"teleport\") return;\n    if (stage === \"first\") {\n      this.clearTeleportHighlight();\n      const view = this.tileViews[pos.y]?.[pos.x];\n      if (view) {\n        view.node.setScale(1.2, 1.2);\n        this.teleportSelected = view;\n      }\n    } else {\n      // second selection or completion clears highlight\n      this.clearTeleportHighlight();\n    }\n  }\n\n  private clearTeleportHighlight(): void {\n    if (this.teleportSelected) {\n      this.teleportSelected.node.setScale(1, 1);\n      this.teleportSelected = null;\n    }\n  }\n\n  private onSwapDone(a: cc.Vec2, b: cc.Vec2): void {\n    const viewA = this.tileViews[a.y]?.[a.x];\n    const viewB = this.tileViews[b.y]?.[b.x];\n    if (!viewA || !viewB) return;\n    const nodeA = viewA.node;\n    const nodeB = viewB.node;\n    cc.tween(nodeA)\n      .to(0.1, { scale: 0 })\n      .call(() => viewA.apply(this.board.tileAt(a)!))\n      .to(0.1, { scale: 1 })\n      .start();\n    cc.tween(nodeB)\n      .to(0.1, { scale: 0 })\n      .call(() => viewB.apply(this.board.tileAt(b)!))\n      .to(0.1, { scale: 1 })\n      .start();\n  }\n\n  /**\n   * Creates debug grid to visualize cell boundaries.\n   */\n  private createDebugGrid(): void {\n    const cfg = loadBoardConfig();\n\n    // Создаем контейнер для сетки\n    const gridContainer = new cc.Node(\"DebugGrid\");\n    gridContainer.parent = this.tilesLayer;\n    gridContainer.zIndex = 1000; // Поверх всех тайлов\n\n    // Рисуем вертикальные линии\n    for (let c = 0; c <= this.board.cols; c++) {\n      const line = new cc.Node(\"VLine\");\n      line.parent = gridContainer;\n\n      const graphics = line.addComponent(cc.Graphics);\n      graphics.lineWidth = 2;\n      graphics.strokeColor = cc.Color.RED;\n\n      const startX = (c - this.board.cols / 2) * cfg.tileWidth;\n      const startY = (this.board.rows / 2) * cfg.tileHeight;\n      const endY = (-this.board.rows / 2) * cfg.tileHeight;\n\n      graphics.moveTo(startX, startY);\n      graphics.lineTo(startX, endY);\n      graphics.stroke();\n    }\n\n    // Draw horizontal lines\n    for (let r = 0; r <= this.board.rows; r++) {\n      const line = new cc.Node(\"HLine\");\n      line.parent = gridContainer;\n\n      const graphics = line.addComponent(cc.Graphics);\n      graphics.lineWidth = 2;\n      graphics.strokeColor = cc.Color.BLUE;\n\n      const startY = (this.board.rows / 2 - r) * cfg.tileHeight;\n      const startX = (-this.board.cols / 2) * cfg.tileWidth;\n      const endX = (this.board.cols / 2) * cfg.tileWidth;\n\n      graphics.moveTo(startX, startY);\n      graphics.lineTo(endX, startY);\n      graphics.stroke();\n    }\n\n    // Add cell coordinates\n    for (let r = 0; r < this.board.rows; r++) {\n      for (let c = 0; c < this.board.cols; c++) {\n        const label = new cc.Node(\"CellLabel\");\n        label.parent = gridContainer;\n\n        const text = label.addComponent(cc.Label);\n        text.string = `${c},${r}`;\n        text.fontSize = 16;\n        text.node.color = cc.Color.YELLOW;\n\n        const pos = computeTilePosition(c, r, this.board);\n        label.setPosition(\n          pos.x + cfg.tileWidth / 2,\n          pos.y - cfg.tileHeight / 2,\n        );\n      }\n    }\n  }\n}\n","import { EventBus } from \"../../core/EventBus\";\nimport { EventNames } from \"../../core/events/EventNames\";\nconst { ccclass, property } = cc._decorator;\n\n/**\n * Handles showing the result popup when a game ends.\n * ResultLine falls from above the screen with bounce effect,\n * then RestartButton appears with bounce animation.\n */\n@ccclass(\"\")\nexport class PopupController extends cc.Component {\n  /** ResultLine node that falls from above */\n  @property(cc.Node)\n  resultLine: cc.Node = null;\n\n  /** Title label displaying Victory or Defeat text. */\n  @property(cc.Label)\n  lblTitle: cc.Label = null;\n\n  /** Label showing the final score amount. */\n  @property(cc.Label)\n  lblFinalScore: cc.Label = null;\n\n  /** Restart button node. */\n  @property(cc.Button)\n  btnRestart: cc.Button = null;\n\n  /** Original position of ResultLine for animation */\n  private originalResultLinePosition: cc.Vec3 = cc.Vec3.ZERO;\n\n  /** Cached handlers so we can unsubscribe without removing others' listeners. */\n  private onWin = (score: number): void => this.show(true, score);\n  private onLose = (score: number): void => this.show(false, score);\n\n  onLoad(): void {\n    // Save the original position of ResultLine\n    if (this.resultLine) {\n      this.originalResultLinePosition = this.resultLine.position.clone();\n      this.resultLine.active = false;\n    }\n\n    // Hide the RestartButton initially\n    if (this.btnRestart) {\n      this.btnRestart.node.active = false;\n    }\n  }\n\n  onEnable(): void {\n    EventBus.on(EventNames.GameWon, this.onWin, this);\n    EventBus.on(EventNames.GameLost, this.onLose, this);\n  }\n\n  onDisable(): void {\n    EventBus.off(EventNames.GameWon, this.onWin);\n    EventBus.off(EventNames.GameLost, this.onLose);\n  }\n\n  /**\n   * Populates UI fields and plays falling animation for ResultLine,\n   * then shows RestartButton with bounce effect.\n   * @param win Whether the game was won\n   * @param score Final player score\n   */\n  show(win: boolean, score: number): void {\n    if (this.lblTitle) {\n      this.lblTitle.string = win ? \"Победа!\" : \"Поражение...\";\n      this.lblTitle.node.color = win ? cc.Color.YELLOW : cc.Color.RED;\n    }\n\n    if (this.lblFinalScore) {\n      this.lblFinalScore.string = String(score);\n    }\n\n    // Hide the RestartButton before the animation\n    if (this.btnRestart) {\n      this.btnRestart.node.active = false;\n    }\n\n    // Start the animation of the ResultLine falling\n    this.animateResultLineFall();\n  }\n\n  private animateResultLineFall(): void {\n    if (!this.resultLine) return;\n\n    // Set the ResultLine above the screen\n    const startPosition = this.originalResultLinePosition.clone();\n    startPosition.y += 1000; // Above the screen\n    this.resultLine.active = true;\n    this.resultLine.setPosition(startPosition);\n\n    // Анимация падения с инерцией\n    cc.tween(this.resultLine)\n      .to(\n        0.8,\n        { position: this.originalResultLinePosition },\n        { easing: \"backOut\" },\n      )\n      .call(() => {\n        // After falling, show the RestartButton\n        this.showRestartButton();\n      })\n      .start();\n  }\n\n  private showRestartButton(): void {\n    if (!this.btnRestart) return;\n\n    // Show the button\n    this.btnRestart.node.active = true;\n    this.btnRestart.node.scale = 0;\n\n    // Animation of appearance with bounce effect\n    cc.tween(this.btnRestart.node)\n      .to(0.4, { scale: 1 }, { easing: \"backOut\" })\n      .start();\n\n    // Configure the click handler\n    this.btnRestart.node.once(\"click\", () => {\n      console.log(\"Restart\");\n\n      // Animate the hiding of elements\n      this.hideElementsWithAnimation(() => {\n        EventBus.emit(EventNames.GameRestart);\n      });\n\n      // cc.director.loadScene(\"MenuScene\");\n    });\n  }\n\n  private hideElementsWithAnimation(callback: () => void): void {\n    // First, animate the hiding of the RestartButton\n    if (this.btnRestart) {\n      cc.tween(this.btnRestart.node)\n        .to(0.3, { scale: 0 }, { easing: \"backIn\" })\n        .call(() => {\n          this.btnRestart.node.active = false;\n        })\n        .start();\n    }\n\n    // Then animate the ResultLine flying up\n    if (this.resultLine) {\n      const endPosition = this.originalResultLinePosition.clone();\n      endPosition.y += 1000; // It flies up\n\n      cc.tween(this.resultLine)\n        .to(0.6, { position: endPosition }, { easing: \"backIn\" })\n        .call(() => {\n          this.resultLine.active = false;\n          callback();\n        })\n        .start();\n    }\n  }\n}\n","import { EventBus } from \"./core/EventBus\";\nimport { GameStateMachine, GameState } from \"./core/game/GameStateMachine\";\nimport { BoardSolver } from \"./core/board/BoardSolver\";\nimport { MoveExecutor } from \"./core/board/MoveExecutor\";\nimport { ScoreStrategyQuadratic } from \"./core/rules/ScoreStrategyQuadratic\";\nimport { TurnManager } from \"./core/rules/TurnManager\";\nimport GameBoardController from \"./ui/controllers/GameBoardController\";\nimport { MoveSequenceLogger } from \"./core/diagnostics/MoveSequenceLogger\";\nimport { initBoosterService } from \"./core/boosters/BoosterSetup\";\nimport { EventNames } from \"./core/events/EventNames\";\nimport BoosterSelectPopup from \"./ui/controllers/BoosterSelectPopup\";\nimport { boosterSelectionService } from \"./ui/services/BoosterSelectionService\";\nimport { SoundController } from \"./core/fx/SoundController\";\n\nconst { ccclass } = cc._decorator;\n\n@ccclass()\nexport default class GameScene extends cc.Component {\n  private fsm: GameStateMachine | null = null;\n  private boardCtrl!: GameBoardController;\n  private solver!: BoardSolver;\n  private executor!: MoveExecutor;\n  private scoreStrategy!: ScoreStrategyQuadratic;\n  private turns!: TurnManager;\n  private currentState: GameState = \"WaitingInput\";\n  private sounds!: SoundController;\n\n  private onStateChange = (s: GameState): void => {\n    this.currentState = s;\n  };\n\n  private onBoostersSelected = (charges: Record<string, number>): void => {\n    const board = this.boardCtrl.getBoard();\n    initBoosterService(\n      board,\n      () => this.boardCtrl.tileViews,\n      () => this.currentState,\n      charges,\n    );\n    if (!this.fsm) {\n      this.fsm = new GameStateMachine(\n        EventBus,\n        board,\n        this.solver,\n        this.executor,\n        this.scoreStrategy,\n        this.turns,\n        800,\n        3,\n      );\n      this.fsm.start();\n    } else {\n      this.fsm.reset();\n    }\n  };\n\n  private onGameRestart = (): void => {\n    this.boardCtrl.resetBoard();\n    this.fsm?.reset();\n  };\n\n  start(): void {\n    this.boardCtrl = this.getComponentInChildren(GameBoardController);\n    if (!this.boardCtrl) {\n      console.error(\"GameBoardController not found\");\n      return;\n    }\n\n    const board = this.boardCtrl.getBoard();\n    this.solver = new BoardSolver(board);\n    this.executor = new MoveExecutor(board, EventBus);\n    this.scoreStrategy = new ScoreStrategyQuadratic(1);\n    this.turns = new TurnManager(20, EventBus);\n\n    // Initialize sound effects controller\n    this.sounds = new SoundController(EventBus);\n\n    // Diagnostic helper that tracks event sequence for each move.\n    new MoveSequenceLogger(EventBus, board);\n\n    EventBus.on(EventNames.StateChanged, this.onStateChange);\n    EventBus.on(EventNames.BoostersSelected, this.onBoostersSelected);\n    EventBus.on(EventNames.GameRestart, this.onGameRestart);\n\n    // Ensure booster selection popup is visible\n    const selector = this.getComponentInChildren(BoosterSelectPopup);\n    if (selector) {\n      (selector.node as unknown as { active: boolean }).active = true;\n    } else {\n      // If no selector exists, auto-select zero boosters to proceed\n      boosterSelectionService.reset();\n      boosterSelectionService.confirm();\n    }\n  }\n\n  onDestroy(): void {\n    EventBus.off(EventNames.StateChanged, this.onStateChange);\n    EventBus.off(EventNames.BoostersSelected, this.onBoostersSelected);\n    EventBus.off(EventNames.GameRestart, this.onGameRestart);\n    this.sounds.destroy();\n  }\n}\n","import { EventBus } from \"../../core/EventBus\";\nimport { EventNames } from \"../../core/events/EventNames\";\n\nconst { ccclass, property } = cc._decorator;\n\n/**\n * Controller for managing the game state\n * Manages switching between screens\n */\n@ccclass()\nexport default class GameStateController extends cc.Component {\n  @property(cc.Node)\n  boosterSelectPopup: cc.Node = null;\n\n  @property(cc.Node)\n  gameBoard: cc.Node = null;\n\n  start(): void {\n    console.log(\"GameStateController start() called\");\n    this.setupEventListeners();\n    this.setInitialState();\n  }\n\n  /**\n   * Sets the initial state\n   */\n  private setInitialState(): void {\n    if (this.boosterSelectPopup) {\n      this.boosterSelectPopup.active = true;\n    } else {\n      console.warn(\"BoosterSelectPopup not assigned in GameStateController\");\n    }\n\n    if (this.gameBoard) {\n      this.gameBoard.active = false;\n    } else {\n      console.warn(\"GameBoard not assigned in GameStateController\");\n    }\n  }\n\n  /**\n   * Sets event listeners\n   */\n  private setupEventListeners(): void {\n    // Listen to the game start event\n    EventBus.on(EventNames.BoostersSelected, this.onGameStart, this);\n    EventBus.on(EventNames.GameRestart, this.onGameRestart, this);\n  }\n\n  /**\n   * Game start handler\n   */\n  private onGameStart(charges: Record<string, number>): void {\n    console.log(\"GameStateController: Starting game with charges:\", charges);\n    this.switchToGameBoard();\n  }\n\n  private onGameRestart(): void {\n    this.switchToBoosterSelection();\n  }\n\n  /**\n   * Switches back to the booster selection screen\n   */\n  public switchToBoosterSelection(): void {\n    if (this.boosterSelectPopup) {\n      this.boosterSelectPopup.active = true;\n    }\n\n    if (this.gameBoard) {\n      this.gameBoard.active = false;\n    }\n  }\n\n  /**\n   * Switches to the game board\n   */\n  public switchToGameBoard(): void {\n    if (this.boosterSelectPopup) {\n      this.boosterSelectPopup.active = false;\n    }\n\n    if (this.gameBoard) {\n      this.gameBoard.active = true;\n    }\n  }\n\n  onDestroy(): void {\n    EventBus.off(EventNames.BoostersSelected, this.onGameStart, this);\n    EventBus.off(EventNames.GameRestart, this.onGameRestart, this);\n  }\n}\n","export type GameState =\n  | \"WaitingInput\"\n  | \"ExecutingMove\"\n  | \"TilesFalling\"\n  | \"Filling\"\n  | \"CheckEnd\"\n  | \"Shuffle\"\n  | \"BoosterInput\"\n  | \"Win\"\n  | \"Lose\";\n\nimport { InfrastructureEventBus } from \"../../infrastructure/InfrastructureEventBus\";\nimport { Board } from \"../board/Board\";\nimport { BoardSolver } from \"../board/BoardSolver\";\nimport { MoveExecutor } from \"../board/MoveExecutor\";\nimport { ScoreStrategy } from \"../rules/ScoreStrategy\";\nimport { TurnManager } from \"../rules/TurnManager\";\nimport { BoardConfig } from \"../../config/ConfigLoader\";\nimport { EventNames } from \"../events/EventNames\";\nimport { TileKind } from \"../board/Tile\";\n\n/**\n * Finite state machine orchestrating a single game session.\n * All state changes are propagated through the provided event bus.\n */\nexport class GameStateMachine {\n  /** Current FSM state. */\n  private state: GameState = \"WaitingInput\";\n  /** Accumulated player score. */\n  private score = 0;\n  /** How many times the board was shuffled. */\n  private shuffles = 0;\n\n  constructor(\n    private bus: InfrastructureEventBus,\n    private board: Board,\n    private solver: BoardSolver,\n    private executor: MoveExecutor,\n    private scoreStrategy: ScoreStrategy,\n    private turnManager: TurnManager,\n    private targetScore: number,\n    private maxShuffles: number = 3,\n  ) {}\n\n  /**\n   * Subscribe to relevant events and enter the initial WaitingInput state.\n   */\n  start(): void {\n    this.bus.on(EventNames.GroupSelected, (p: cc.Vec2) =>\n      this.onGroupSelected(p),\n    );\n    this.bus.on(EventNames.BoosterActivated, () => this.onBoosterActivated());\n    this.bus.on(EventNames.BoosterConsumed, () => this.onBoosterConsumed());\n    this.bus.on(EventNames.BoosterCancelled, () => this.onBoosterCancelled());\n    this.bus.on(EventNames.MoveCompleted, () => this.onMoveCompleted());\n    console.debug(\n      \"Listeners for GroupSelected:\",\n      this.bus.getListenerCount(EventNames.GroupSelected),\n    );\n    // broadcast initial values so HUD can display them\n    const turns = this.turnManager.getRemaining();\n    this.bus.emit(EventNames.TurnsInit, {\n      turns,\n      score: this.score,\n      targetScore: this.targetScore,\n    });\n    // legacy events expected by older HUD/tests\n    this.bus.emit(EventNames.TurnUsed, turns);\n    this.bus.emit(EventNames.TurnEnded, { score: this.score });\n    this.changeState(\"WaitingInput\");\n    console.info(\"FSM started, current state: WaitingInput\");\n  }\n\n  /**\n   * Resets internal counters and emits initial events to start a new session.\n   * Keeps current board and event listeners intact.\n   */\n  reset(): void {\n    this.score = 0;\n    this.shuffles = 0;\n    this.turnManager.reset();\n\n    const turns = this.turnManager.getRemaining();\n    this.bus.emit(EventNames.TurnsInit, {\n      turns,\n      score: this.score,\n      targetScore: this.targetScore,\n    });\n    this.bus.emit(EventNames.TurnUsed, turns);\n    this.bus.emit(EventNames.TurnEnded, { score: this.score });\n\n    this.changeState(\"WaitingInput\");\n  }\n\n  /**\n   * Handles selection of a group by the player.\n   * Ignored unless the machine awaits input.\n   */\n  private onGroupSelected(start: cc.Vec2): void {\n    console.info(\"FSM received GroupSelected at\", start);\n    this.bus.emit(EventNames.TilePressed, start);\n    if (this.state !== \"WaitingInput\") {\n      console.info(\n        `Ignored GroupSelected because current state is ${this.state}`,\n      );\n      // Ignore input while another action is executing\n      return;\n    }\n\n    const tile = this.board.tileAt(start);\n    if (!tile) return;\n\n    // При повторном нажатии на уже установленный супер‑тайл запускается\n    // его эффект. Заряд бустера был списан в момент установки, поэтому\n    // активация выполняется без дополнительного расхода.\n    if (tile.kind !== TileKind.Normal) {\n      this.bus.emit(EventNames.BoosterConfirmed, {\n        kind: tile.kind,\n        position: start,\n      });\n      this.turnManager.useTurn();\n      this.changeState(\"ExecutingMove\");\n\n      switch (tile.kind) {\n        case TileKind.SuperBomb: {\n          const group: cc.Vec2[] = [];\n          for (let dx = -1; dx <= 1; dx++) {\n            for (let dy = -1; dy <= 1; dy++) {\n              if (Math.max(Math.abs(dx), Math.abs(dy)) <= 1) {\n                const p = new cc.Vec2(start.x + dx, start.y + dy);\n                if (this.board.inBounds(p)) group.push(p);\n              }\n            }\n          }\n          const expanded = this.solver.expandBySupers(group);\n          this.score += this.scoreStrategy.calculate(expanded.length);\n          void this.executor.execute(expanded);\n          break;\n        }\n        case TileKind.SuperRow: {\n          const group = Array.from(\n            { length: this.board.cols },\n            (_, x) => new cc.Vec2(x, start.y),\n          );\n          const expanded = this.solver.expandBySupers(group);\n          this.score += this.scoreStrategy.calculate(expanded.length);\n          void this.executor.execute(expanded);\n          break;\n        }\n        case TileKind.SuperCol: {\n          const group = Array.from(\n            { length: this.board.rows },\n            (_, y) => new cc.Vec2(start.x, y),\n          );\n          const expanded = this.solver.expandBySupers(group);\n          this.score += this.scoreStrategy.calculate(expanded.length);\n          void this.executor.execute(expanded);\n          break;\n        }\n        case TileKind.SuperClear: {\n          const group: cc.Vec2[] = [];\n          for (let x = 0; x < this.board.cols; x++) {\n            for (let y = 0; y < this.board.rows; y++) {\n              group.push(new cc.Vec2(x, y));\n            }\n          }\n          const expanded = this.solver.expandBySupers(group);\n          this.score += this.scoreStrategy.calculate(expanded.length);\n          void this.executor.execute(expanded);\n          break;\n        }\n        default:\n          break;\n      }\n      return;\n    }\n\n    // Determine group of connected tiles and calculate score\n    const group = this.solver.findGroup(start);\n    if (group.length < 2) {\n      console.info(`Tap ignored as move: single tile at ${start.x},${start.y}`);\n      this.bus.emit(EventNames.InvalidTap, start);\n      return;\n    }\n\n    console.info(`Tap accepted as move: group size ${group.length}`);\n\n    this.turnManager.useTurn();\n    this.score += this.scoreStrategy.calculate(group.length);\n    this.changeState(\"ExecutingMove\");\n\n    // Execute the move asynchronously; further states advance on MoveCompleted\n    void this.executor.execute(group);\n  }\n\n  /** Enters booster targeting mode when allowed. */\n  private onBoosterActivated(): void {\n    if (this.state === \"WaitingInput\") {\n      this.changeState(\"BoosterInput\");\n    }\n  }\n\n  /** Consumes a booster and proceeds to executing it. */\n  private onBoosterConsumed(): void {\n    if (this.state === \"BoosterInput\") {\n      this.changeState(\"WaitingInput\");\n    }\n  }\n\n  /** Cancels booster usage returning to normal input. */\n  private onBoosterCancelled(): void {\n    if (this.state === \"BoosterInput\") {\n      this.changeState(\"WaitingInput\");\n    }\n  }\n\n  /**\n   * Triggered when MoveExecutor signals completion of tile removal/fall/fill.\n   * Advances through remaining states and evaluates win/lose conditions.\n   */\n  private onMoveCompleted(): void {\n    if (this.state !== \"ExecutingMove\") return;\n    // Transition through remaining post-move phases\n    this.changeState(\"TilesFalling\");\n    this.changeState(\"Filling\");\n    this.changeState(\"CheckEnd\");\n    this.evaluateEnd();\n    // notify HUD about updated score\n    this.bus.emit(EventNames.TurnEnded, { score: this.score });\n  }\n\n  /**\n   * Checks end conditions and moves to the next appropriate state.\n   */\n  private evaluateEnd(): void {\n    const hasMoves = this.hasAvailableMoves();\n    const turns = this.turnManager.getRemaining();\n\n    if (this.score >= this.targetScore) {\n      this.changeState(\"Win\");\n      return;\n    }\n\n    if (!hasMoves && this.shuffles < this.maxShuffles) {\n      this.changeState(\"Shuffle\");\n      this.shuffleBoard();\n      this.shuffles++;\n      this.changeState(\"WaitingInput\");\n      return;\n    }\n\n    if (turns === 0 || (!hasMoves && this.shuffles >= this.maxShuffles)) {\n      this.changeState(\"Lose\");\n      return;\n    }\n\n    this.changeState(\"WaitingInput\");\n  }\n\n  /**\n   * Emits a new state via the event bus and stores it internally.\n   */\n  private changeState(newState: GameState): void {\n    this.state = newState;\n    this.bus.emit(EventNames.StateChanged, newState);\n    console.info(\"State changed to\", newState);\n    if (newState === \"Win\") {\n      this.bus.emit(EventNames.GameWon, this.score);\n    }\n    if (newState === \"Lose\") {\n      this.bus.emit(EventNames.GameLost, this.score);\n    }\n  }\n\n  /**\n   * Determines whether any moves remain on the board by searching for\n   * adjacent tiles sharing the same color.\n   */\n  private hasAvailableMoves(): boolean {\n    let found = false;\n\n    // Получаем все позиции и тайлы\n    const positions: cc.Vec2[] = [];\n    const tiles: ReturnType<typeof this.board.tileAt>[] = [];\n\n    // Собираем все позиции и тайлы\n    this.board.forEach((p, tile) => {\n      positions.push(p);\n      tiles.push(tile);\n    });\n\n    // Проверяем каждую позицию\n    for (let i = 0; i < positions.length; i++) {\n      if (found) break;\n      const p = positions[i];\n      const tile = tiles[i];\n\n      for (const n of this.board.neighbors4(p)) {\n        const other = this.board.tileAt(n);\n        if (other && other.color === tile.color) {\n          found = true;\n          break;\n        }\n      }\n    }\n\n    return found;\n  }\n\n  /** Randomly shuffles all tiles on the board in place. */\n  private shuffleBoard(): void {\n    const cfg = (this.board as unknown as { cfg: BoardConfig }).cfg;\n    const tiles: ReturnType<typeof this.board.tileAt>[] = [];\n    for (let y = 0; y < cfg.rows; y++) {\n      for (let x = 0; x < cfg.cols; x++) {\n        tiles.push(this.board.tileAt(new cc.Vec2(x, y)));\n      }\n    }\n    // Fisher–Yates shuffle\n    for (let i = tiles.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [tiles[i], tiles[j]] = [tiles[j], tiles[i]];\n    }\n    let idx = 0;\n    for (let y = 0; y < cfg.rows; y++) {\n      for (let x = 0; x < cfg.cols; x++) {\n        this.board.setTile(new cc.Vec2(x, y), tiles[idx++] ?? null);\n      }\n    }\n  }\n}\n","import { EventBus } from \"../../core/EventBus\";\nimport { EventNames } from \"../../core/events/EventNames\";\nconst { ccclass, property } = cc._decorator;\n\ninterface NodeUtils {\n  getChildByName(name: string): NodeUtils | null;\n  getComponent(name: string): unknown;\n  on(event: string, cb: () => void): void;\n  off?(event: string, cb?: () => void): void;\n  node?: NodeUtils & { color?: cc.Color; active?: boolean };\n}\n\n// Simple animation helpers built with cc.tween for runtime usage.\n\n/**\n * Controls the Heads Up Display of the GameScene.\n * Responsible for updating score/move counters and\n * dispatching events when HUD buttons are pressed.\n */\n@ccclass()\nexport class HudController extends cc.Component {\n  @property(cc.Label)\n  lblScore: cc.Label = null;\n  @property(cc.Label)\n  lblMoves: cc.Label = null;\n  @property(cc.Label)\n  lblState: cc.Label = null;\n\n  private btnPause: NodeUtils | null = null;\n\n  private turns: number = 0;\n  private score: number = 0;\n  private targetScore: number = 0;\n\n  onLoad(): void {\n    // Update moves counter when a turn is consumed\n    EventBus.on(EventNames.TurnUsed, this.onTurnUsed, this);\n\n    // Update score display after a turn ends\n    EventBus.on(EventNames.TurnEnded, this.onTurnEnded, this);\n\n    // Initialize HUD with initial values\n    EventBus.on(EventNames.TurnsInit, this.onTurnsInit, this);\n\n    console.log(\"HudController onLoad\");\n  }\n\n  /** Initializes component references and event listeners. */\n  start(): void {\n    const root = this.node as unknown as NodeUtils;\n\n    // Fallback lookup of label references when not assigned in editor\n    if (!this.lblState) {\n      const n = root.getChildByName(\"lblState\");\n      this.lblState = n?.getComponent(\"Label\") as unknown as cc.Label;\n    }\n    if (!this.lblScore) {\n      const n = root.getChildByName(\"lblScore\");\n      this.lblScore = n?.getComponent(\"Label\") as unknown as cc.Label;\n    }\n    if (!this.lblMoves) {\n      const n = root.getChildByName(\"lblMoves\");\n      this.lblMoves = n?.getComponent(\"Label\") as unknown as cc.Label;\n    }\n\n    this.btnPause = root\n      .getChildByName(\"btnPause\")\n      ?.getComponent(\"Button\") as NodeUtils | null;\n\n    this.btnPause?.node?.on(\"click\", this.onPauseClick.bind(this));\n\n    // Display current FSM state in the HUD\n    EventBus.on(EventNames.StateChanged, this.onStateChanged, this);\n  }\n\n  private onTurnsInit(data: {\n    turns: number;\n    score: number;\n    targetScore: number;\n  }): void {\n    this.turns = data.turns;\n    this.score = data.score;\n    this.targetScore = data.targetScore;\n\n    if (this.lblScore)\n      this.lblScore.string = `${this.score} / ${this.targetScore}`;\n    if (this.lblMoves) this.lblMoves.string = String(this.turns);\n  }\n\n  /**\n   * Handles turn used event - updates moves counter and shows shake animation.\n   */\n  private onTurnUsed(left: number): void {\n    if (this.lblMoves) this.lblMoves.string = String(left);\n    const moveNode = this.lblMoves?.node as unknown as cc.Node | undefined;\n    if (left <= 3 && moveNode) {\n      EventBus.emit(EventNames.AnimationStarted, \"moves-shake\");\n      cc.tween(moveNode)\n        .to(0.05, { position: new cc.Vec3(-5, 0, 0) })\n        .to(0.05, { position: new cc.Vec3(5, 0, 0) })\n        .to(0.05, { position: new cc.Vec3(0, 0, 0) })\n        .start();\n      setTimeout(\n        () => EventBus.emit(EventNames.AnimationEnded, \"moves-shake\"),\n        150,\n      );\n    }\n  }\n\n  /**\n   * Handles turn ended event - animates score update.\n   */\n  private onTurnEnded({ score }: { score: number }): void {\n    if (!this.lblScore) return;\n    const startVal = parseInt(this.lblScore.string, 10) || 0;\n    const data = { value: startVal };\n    EventBus.emit(EventNames.AnimationStarted, \"score-tween\");\n    // Tween over half a second using an ease-out curve for smooth feel\n    cc.tween(data).to(0.5, { value: score }, { easing: \"quadOut\" }).start();\n    const id = setInterval(() => {\n      if (this.lblScore) {\n        this.lblScore.string = `${Math.round(data.value)} / ${this.targetScore}`;\n      }\n    }, 16);\n    setTimeout(() => {\n      clearInterval(id);\n      if (this.lblScore)\n        this.lblScore.string = `${score} / ${this.targetScore}`;\n      EventBus.emit(EventNames.AnimationEnded, \"score-tween\");\n    }, 500);\n  }\n\n  /**\n   * Handles pause button click.\n   */\n  private onPauseClick(): void {\n    EventBus.emit(EventNames.GamePaused);\n  }\n\n  /**\n   * Handles state change - updates state label.\n   */\n  private onStateChanged(state: string): void {\n    if (this.lblState) this.lblState.string = state;\n  }\n}\n","export class InfrastructureEventBus {\n  private target = new cc.EventTarget();\n  private registry: Map<string, Set<(...args: unknown[]) => void>> = new Map();\n\n  on(\n    eventName: string,\n    handler: (...args: unknown[]) => void,\n    target?: unknown,\n    useCapture?: boolean,\n  ): void {\n    // Привязываем контекст если передан target\n    const boundHandler = target ? handler.bind(target) : handler;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.target.on(eventName, boundHandler, target, useCapture);\n    let set = this.registry.get(eventName);\n    if (!set) {\n      set = new Set();\n      this.registry.set(eventName, set);\n    }\n    set.add(boundHandler);\n  }\n\n  off(\n    eventName: string,\n    handler?: (...args: unknown[]) => void,\n    target?: unknown,\n  ): void {\n    // Привязываем контекст если передан target и handler\n    const boundHandler = target && handler ? handler.bind(target) : handler;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.target.off(eventName, boundHandler, target);\n    const set = this.registry.get(eventName);\n    if (set && boundHandler) {\n      set.delete(boundHandler);\n      if (set.size === 0) {\n        this.registry.delete(eventName);\n      }\n    } else if (set && !boundHandler) {\n      this.registry.delete(eventName);\n    }\n  }\n\n  once(\n    event: string,\n    listener: (...args: unknown[]) => void,\n    target?: unknown,\n  ): void {\n    const callback = (...args: unknown[]) => {\n      this.off(event, callback, target);\n      // Привязываем контекст для listener\n      const boundListener = target ? listener.bind(target) : listener;\n      boundListener(...args);\n    };\n    this.on(event, callback, target);\n  }\n\n  emit(eventName: string, ...args: unknown[]): void {\n    const count = this.getListenerCount(eventName);\n    if (count === 0) {\n      console.warn(\n        `EventBus: emitted event '${eventName}' has no listeners (possible typo or initialization issue)`,\n      );\n      // if (typeof CC_DEBUG !== \"undefined\" && CC_DEBUG) {\n      //   console.warn(new Error().stack);\n      // }\n    }\n    console.log(\"emit\", eventName, args);\n    this.target.emit(eventName, ...args);\n  }\n\n  getListenerCount(eventName: string): number {\n    return this.registry.get(eventName)?.size ?? 0;\n  }\n\n  clear(eventName?: string): void {\n    if (eventName) {\n      const set = this.registry.get(eventName);\n      if (set) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        set.forEach((h) => {\n          // console.log(\"off\", eventName, h);\n          this.target.off(eventName, h);\n        });\n      }\n      this.registry.delete(eventName);\n    } else {\n      this.registry.forEach((handlers, evt) => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        handlers.forEach((h) => {\n          // console.log(\"off\", evt, h);\n          this.target.off(evt, h);\n        });\n      });\n      this.registry.clear();\n    }\n  }\n}\n","import { Board } from \"./Board\";\nimport { InfrastructureEventBus } from \"../../infrastructure/InfrastructureEventBus\";\nimport { RemoveCommand } from \"./commands/RemoveCommand\";\nimport { FallCommand } from \"./commands/FallCommand\";\nimport { FillCommand } from \"./commands/FillCommand\";\nimport { TileFactory, TileKind } from \"./Tile\";\nimport { SuperTileFactory } from \"../boosters/SuperTileFactory\";\nimport { EventNames } from \"../events/EventNames\";\nimport { FXController } from \"../fx/FXController\";\n\n/**\n * Executes a full player move by removing a group, letting tiles fall\n * and filling empty spaces. Commands are executed sequentially and the\n * method resolves once all operations are complete.\n */\nexport class MoveExecutor {\n  constructor(\n    private board: Board,\n    private bus: InfrastructureEventBus,\n  ) {}\n\n  async execute(group: cc.Vec2[]): Promise<void> {\n    if (group.length === 0) {\n      throw new Error(\"MoveExecutor: group is empty\");\n    }\n\n    const cfg = this.board.config;\n    const start = group[0];\n    const startTile = this.board.tileAt(start);\n    const hasSuper = group.some((p) => {\n      const t = this.board.tileAt(p);\n      return t !== null && t.kind !== TileKind.Normal;\n    });\n\n    // Collect promises for super-tile VFX that may be triggered during removal.\n    // Listener stays active only for this execution and is detached afterwards\n    // to avoid capturing unrelated events when multiple moves chain.\n    const vfxPromises: Promise<void>[] = [];\n    const onSuperActivated = (kind: TileKind, pos: cc.Vec2) => {\n      const cfg = this.board.config;\n      const x =\n        (pos.x - this.board.cols / 2) * cfg.tileWidth + cfg.tileWidth / 2;\n      const y =\n        (this.board.rows / 2 - pos.y) * cfg.tileHeight - cfg.tileHeight / 2;\n      vfxPromises.push(FXController.waitForVfx(kind, cc.v2(x, y)));\n    };\n    this.bus.on(EventNames.SuperTileActivated, onSuperActivated);\n\n    // 1. Remove tiles and wait for completion. RemoveStarted is emitted inside\n    // RemoveCommand immediately, allowing UI to hide tiles before we await any\n    // visual effects.\n    const removeDone = this.wait(EventNames.TilesRemoved);\n    new RemoveCommand(this.board, this.bus, group).execute();\n    const [dirtyCols] = (await removeDone) as [number[]];\n\n    // Detach listener and wait for all super-tile effects to finish before\n    // starting gravity. This delays FallStarted while keeping RemoveStarted\n    // synchronous so explosions aren't covered by new tiles.\n    this.bus.off(EventNames.SuperTileActivated, onSuperActivated);\n    await Promise.all(vfxPromises);\n\n    // Если размер группы превышает порог, в исходной клетке\n    // появляется супер-тайл выбранного вида.\n    if (startTile && group.length >= cfg.superThreshold && !hasSuper) {\n      const kind = new SuperTileFactory(cfg).make();\n      const tile = TileFactory.createNormal(startTile.color);\n      tile.kind = kind;\n      this.board.setTile(start, tile);\n      this.bus.emit(EventNames.SuperTileCreated, start, tile);\n    }\n\n    // 2. Let tiles fall in affected columns\n    const fallDone = this.wait(EventNames.FallDone);\n    new FallCommand(this.board, this.bus, dirtyCols).execute();\n    const [emptySlots] = (await fallDone) as [cc.Vec2[]];\n\n    // 3. Fill empty spaces with new tiles\n    const fillDone = this.wait(EventNames.FillDone);\n    new FillCommand(this.board, this.bus, emptySlots).execute();\n    await fillDone;\n\n    // Signal completion of the whole move\n    this.bus.emit(EventNames.MoveCompleted);\n  }\n\n  /**\n   * Helper that returns a promise resolved when the given event fires.\n   */\n  private wait(event: string): Promise<unknown[]> {\n    return new Promise((resolve) => {\n      this.bus.once(event, (...args: unknown[]) => resolve(args));\n    });\n  }\n}\n","const { ccclass, property } = cc._decorator;\n\nimport { EventBus as bus } from \"../../core/EventBus\";\nimport { EventNames } from \"../../core/events/EventNames\";\nimport GameBoardController from \"./GameBoardController\";\nimport TileView from \"../views/TileView\";\nimport type { Board } from \"../../core/board/Board\";\nimport { runFallAnimation } from \"../utils/FallAnimator\";\nimport { computeTilePosition } from \"../utils/PositionUtils\";\nimport { TileKind } from \"../../core/board/Tile\";\nimport { shock } from \"../../config/ShockwaveConfig\";\n\n@ccclass()\nexport default class MoveFlowController extends cc.Component {\n  /** Parent node for new tile views */\n  @property(cc.Node)\n  tilesLayer: cc.Node = null;\n\n  /** Cached matrix of tile view components. Filled on load. */\n  private tileViews!: TileView[][];\n  /** Board model for reading final tile positions */\n  private board!: Board;\n  /** Reference to board controller so we can update its matrix */\n  private boardCtrl!: GameBoardController;\n  /** Coordinates scheduled for removal in current move */\n  private pendingRemoval: Set<string> = new Set();\n\n  onLoad(): void {\n    // Cache references to TileView matrix generated by GameBoardController\n    this.boardCtrl = this.node.getComponent(GameBoardController)!;\n    this.board = this.boardCtrl.getBoard();\n    this.tileViews = this.boardCtrl.tileViews;\n\n    // Listen for core events signalling board updates\n    bus.on(EventNames.RemoveStarted, this.onRemove, this);\n    bus.on(EventNames.FallDone, this.onFall, this);\n    bus.on(EventNames.FillDone, this.onFill, this);\n    bus.on(EventNames.SuperTileCreated, this.onSuperTileCreated, this);\n    bus.on(EventNames.SuperTileActivated, this.onSuperTileActivated, this);\n  }\n\n  /**\n   * Plays scale + fade animation on removed tile views.\n   * @param positions coordinates of tiles removed by the core\n   */\n  private onRemove(positions: cc.Vec2[]): void {\n    this.pendingRemoval = new Set(positions.map((p) => `${p.x},${p.y}`));\n    // Refresh local reference in case another controller replaced it\n    this.tileViews = this.boardCtrl.tileViews;\n    for (let i = 0; i < positions.length; i++) {\n      const p = positions[i];\n      const view = this.tileViews[p.y]?.[p.x];\n      if (!view) continue;\n      view.node.runAction(\n        cc.sequence(\n          cc.spawn(cc.scaleTo(0.15, 0), cc.fadeOut(0.15)),\n          cc.callFunc(() => view.node.destroy()),\n        ),\n      );\n      this.tileViews[p.y][p.x] = undefined as unknown as TileView;\n      this.boardCtrl.tileViews[p.y][p.x] = undefined as unknown as TileView;\n    }\n  }\n\n  /**\n   * Animates tiles falling after removal.\n   * @param dirtyCols column indices reported by the core's FallCommand\n   *                  that contained holes and were shifted down.\n   *                  Each tile view in these columns moves to its new Y.\n   */\n  private onFall(): void {\n    // Build mapping from tile model instances to their views\n    const map = new Map<unknown, TileView>();\n    for (let rowIndex = 0; rowIndex < this.tileViews.length; rowIndex++) {\n      const row = this.tileViews[rowIndex];\n      for (let colIndex = 0; colIndex < row.length; colIndex++) {\n        const v = row[colIndex];\n        if (!v) continue;\n        map.set(v.tile, v);\n      }\n    }\n\n    // Reconstruct matrix according to board state and move views\n    const updated: (TileView | undefined)[][] = [];\n    for (let r = 0; r < this.board.rows; r++) {\n      updated[r] = new Array(this.board.cols);\n    }\n\n    // Получаем все позиции и тайлы из board\n    const positions: cc.Vec2[] = [];\n    const tiles: unknown[] = [];\n\n    this.board.forEach((p, t) => {\n      positions.push(p);\n      tiles.push(t);\n    });\n\n    // Обрабатываем каждую позицию\n    for (let i = 0; i < positions.length; i++) {\n      const p = positions[i];\n      const t = tiles[i];\n      const view = map.get(t);\n\n      if (!view) {\n        continue;\n      }\n\n      const target = computeTilePosition(p.x, p.y, this.board);\n      const dist = Math.floor(Math.abs(view.node.y - target.y));\n\n      if (dist > 0) {\n        runFallAnimation(view.node, target);\n      }\n\n      view.node.zIndex = this.board.rows - p.y - 1;\n      view.boardPos = cc.v2(p.x, p.y);\n      updated[p.y][p.x] = view;\n    }\n\n    this.tileViews = updated as TileView[][];\n    this.boardCtrl.tileViews = this.tileViews;\n  }\n\n  /**\n   * Updates local references after new tiles were spawned.\n   */\n  private onFill(): void {\n    this.tileViews = this.boardCtrl.tileViews;\n  }\n\n  /**\n   * Spawns a view for a newly created super tile.\n   */\n  private onSuperTileCreated(pos: cc.Vec2): void {\n    const view = this.boardCtrl.spawn(pos);\n    view.apply(this.board.tileAt(pos)!);\n    this.tileViews = this.boardCtrl.tileViews;\n  }\n\n  /** Handles shockwave animations for activated super tiles. */\n  private onSuperTileActivated(kind: TileKind, pos: cc.Vec2): void {\n    switch (kind) {\n      case TileKind.SuperBomb:\n        this.applyBombShockwave(pos);\n        break;\n      case TileKind.SuperRow:\n        this.applyLineShockwave(pos, true);\n        break;\n      case TileKind.SuperCol:\n        this.applyLineShockwave(pos, false);\n        break;\n      default:\n        break;\n    }\n  }\n\n  /** Pushes surrounding tiles outwards when a SuperBomb explodes. */\n  private applyBombShockwave(center: cc.Vec2): void {\n    const centerPos = computeTilePosition(center.x, center.y, this.board);\n\n    for (let y = center.y - 2; y <= center.y + 2; y++) {\n      for (let x = center.x - 2; x <= center.x + 2; x++) {\n        const dist = Math.max(Math.abs(x - center.x), Math.abs(y - center.y));\n        if (dist < 1 || dist > 2) continue;\n        const key = `${x},${y}`;\n        if (this.pendingRemoval.has(key)) continue;\n\n        const view = this.tileViews[y]?.[x];\n        if (!view || !view.isInteractive()) continue;\n\n        const node = view.node;\n        const dx = node.x - centerPos.x;\n        const dy = node.y - centerPos.y;\n        const len = Math.sqrt(dx * dx + dy * dy) || 1;\n        const offset = cc.v2(\n          (dx / len) * shock.bombOffset,\n          (dy / len) * shock.bombOffset,\n        ); // 12px is enough to notice without overlap\n        // Use relative movement so we don't rely on absolute coordinates.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (cc.tween(node) as any)\n          .by(shock.bombDurationOut, { position: offset })\n          .by(\n            shock.bombDurationBack,\n            { position: cc.v2(-offset.x, -offset.y) },\n            { easing: \"quadOut\" },\n          )\n          .call(() => node.setPosition(Math.round(node.x), Math.round(node.y)))\n          .start();\n      }\n    }\n  }\n\n  /**\n   * Applies a perpendicular nudge to tiles adjacent to a rocket trail.\n   * @param isRow true for horizontal rockets, false for vertical\n   */\n  private applyLineShockwave(center: cc.Vec2, isRow: boolean): void {\n    const max = isRow ? this.board.cols : this.board.rows;\n    for (let i = 0; i < max; i++) {\n      const dx = isRow ? Math.abs(i - center.x) : 0;\n      const dy = isRow ? 0 : Math.abs(i - center.y);\n      const delay = (dx + dy) * shock.lineDuration; // rocket crosses one tile per lineDuration\n\n      const targets: cc.Vec2[] = [];\n      if (isRow) {\n        targets.push(cc.v2(i, center.y - 1), cc.v2(i, center.y + 1));\n      } else {\n        targets.push(cc.v2(center.x - 1, i), cc.v2(center.x + 1, i));\n      }\n\n      for (const t of targets) {\n        const key = `${t.x},${t.y}`;\n        if (!this.board.inBounds(t) || this.pendingRemoval.has(key)) continue;\n        const view = this.tileViews[t.y]?.[t.x];\n        if (!view || !view.isInteractive()) continue;\n\n        const node = view.node;\n        // Direction points away from the rocket path. For a horizontal rocket\n        // tiles above should move further up and tiles below further down.\n        // Same idea for vertical rockets: tiles left of the path move further\n        // left, tiles on the right move further right.\n        const sign = isRow\n          ? Math.sign(t.y - center.y)\n          : Math.sign(t.x - center.x);\n        const dir = isRow\n          ? cc.v2(0, -sign * shock.lineOffset) // 8px sideways nudge\n          : cc.v2(sign * shock.lineOffset, 0);\n        // Relative tween keeps original coordinate intact after return.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (cc.tween(node) as any)\n          .delay(delay)\n          .by(shock.lineDuration, { position: dir })\n          .by(\n            shock.lineDuration,\n            { position: cc.v2(-dir.x, -dir.y) },\n            { easing: \"quadOut\" },\n          )\n          .call(() => node.setPosition(Math.round(node.x), Math.round(node.y)))\n          .start();\n      }\n    }\n  }\n\n  /**\n   * Updates internal references after the board was reset.\n   */\n  public reset(board: Board, tileViews: TileView[][]): void {\n    this.board = board;\n    this.tileViews = tileViews;\n    this.boardCtrl = this.node.getComponent(GameBoardController)!;\n  }\n}\n","const { ccclass, property } = cc._decorator;\n\nimport { MoveSequenceLogger } from \"../../core/diagnostics/MoveSequenceLogger\";\n\n@ccclass()\nexport default class MoveSequenceBadge extends cc.Component {\n  @property(cc.Label)\n  label: cc.Label = null;\n\n  private logger!: MoveSequenceLogger;\n\n  onLoad(): void {\n    if (!this.label) {\n      this.label =\n        this.getComponent(cc.Label) || this.node.addComponent(cc.Label);\n    }\n    this.logger = MoveSequenceLogger.current as MoveSequenceLogger;\n    if (!this.logger) return;\n    this.logger.onStatusChange((s) => {\n      this.label.string = `Last move: ${s.step}`;\n      this.label.node.color = s.unsynced ? cc.Color.RED : cc.Color.WHITE;\n    });\n    const l = this.logger.getStatus();\n    this.label.string = `Last move: ${l.step}`;\n  }\n}\n","import { InfrastructureEventBus } from \"../../infrastructure/InfrastructureEventBus\";\nimport { Board } from \"../board/Board\";\nimport { EventNames } from \"../events/EventNames\";\n\nexport interface MoveSequenceStatus {\n  step: string;\n  unsynced: boolean;\n}\n\ntype StatusListener = (s: MoveSequenceStatus) => void;\n\nexport class MoveSequenceLogger {\n  static current: MoveSequenceLogger | null = null;\n\n  private removed = 0;\n  private added = 0;\n  private cycles = 0;\n  private fillTimer: ReturnType<typeof setTimeout> | null = null;\n  private status: MoveSequenceStatus = { step: \"init\", unsynced: false };\n  private listeners: StatusListener[] = [];\n\n  constructor(\n    private bus: InfrastructureEventBus,\n    private board: Board,\n  ) {\n    MoveSequenceLogger.current = this;\n    bus.on(EventNames.GroupSelected, this.onGroupSelected, this);\n    bus.on(EventNames.TilesRemoved, this.onTilesRemoved, this);\n    bus.on(EventNames.FallDone, () => this.update(\"fall done\"), this);\n    bus.on(EventNames.FillStarted, this.onFillStarted, this);\n    bus.on(EventNames.FillDone, this.onFillDone, this);\n    bus.on(EventNames.MoveCompleted, this.onMoveCompleted, this);\n  }\n\n  onStatusChange(cb: StatusListener): void {\n    this.listeners.push(cb);\n  }\n\n  getStatus(): MoveSequenceStatus {\n    return this.status;\n  }\n\n  private onGroupSelected(): void {\n    this.removed = 0;\n    this.added = 0;\n    this.cycles = 0;\n    this.update(\"group selected\", false);\n  }\n\n  private onTilesRemoved(positions: cc.Vec2[]): void {\n    this.removed += positions.length;\n    this.update(\"tiles removed\");\n  }\n\n  private onFillStarted(): void {\n    if (this.fillTimer) clearTimeout(this.fillTimer);\n    this.fillTimer = setTimeout(() => {\n      console.warn(\"MoveSequenceLogger: FillDone not received\", {\n        events: this.status.step,\n        board: this.dumpBoard(),\n      });\n      this.update(\"fill timeout\", true);\n      this.fillTimer = null;\n    }, 600);\n    this.update(\"fill started\");\n  }\n\n  private onFillDone(newTiles?: { pos: cc.Vec2; tile: unknown }[]): void {\n    if (this.fillTimer) {\n      clearTimeout(this.fillTimer);\n      this.fillTimer = null;\n    }\n    this.added += newTiles?.length ?? 0;\n    this.cycles++;\n    this.update(\"fill done\");\n  }\n\n  private onMoveCompleted(): void {\n    const chain = this.cycles > 1 ? \"yes\" : \"no\";\n    console.info(\n      `MoveSequence: removed ${this.removed}, added ${this.added}, chain ${chain}`,\n    );\n    this.update(\"move completed\");\n  }\n\n  private update(step: string, unsynced = false): void {\n    this.status = { step, unsynced };\n    this.listeners.forEach((l) => l(this.status));\n  }\n\n  private dumpBoard(): string {\n    const rows: string[] = [];\n    for (let y = 0; y < this.board.rows; y++) {\n      const cols: string[] = [];\n      for (let x = 0; x < this.board.cols; x++) {\n        const t = this.board.tileAt(new cc.Vec2(x, y));\n        cols.push(t ? (t.color as string)[0] : \"_\");\n      }\n      rows.push(cols.join(\"\"));\n    }\n    return rows.join(\"|\");\n  }\n}\n","import { loadBoardConfig } from \"../../config/ConfigLoader\";\nimport type { Board } from \"../../core/board/Board\";\n\n/**\n * Computes tile position from column and row indices.\n * Uses board size and configured tile size to match the core model.\n */\nexport function computeTilePosition(\n  col: number,\n  row: number,\n  board: Board,\n): cc.Vec2 {\n  const cfg = loadBoardConfig();\n  const x = (col - board.cols / 2) * cfg.tileWidth + cfg.tileWidth / 2;\n  const y = (board.rows / 2 - row) * cfg.tileHeight - cfg.tileHeight / 2;\n  return cc.v2(x, y);\n}\n","import { Board } from \"../Board\";\nimport { InfrastructureEventBus } from \"../../../infrastructure/InfrastructureEventBus\";\nimport { ICommand } from \"./ICommand\";\nimport { EventNames } from \"../../events/EventNames\";\nimport { TileKind } from \"../Tile\";\n\n/**\n * Removes tiles belonging to the provided group from the board.\n * Emits 'RemoveStarted' at the beginning and 'TilesRemoved' with affected\n * column indices when finished.\n */\nexport class RemoveCommand implements ICommand {\n  constructor(\n    private board: Board,\n    private bus: InfrastructureEventBus,\n    private group: cc.Vec2[],\n  ) {}\n\n  async execute(): Promise<void> {\n    if (this.group.length === 0) {\n      throw new Error(\"RemoveCommand: group is empty\");\n    }\n\n    // Notify listeners that removal has started\n    this.bus.emit(EventNames.RemoveStarted, this.group);\n\n    const cols = new Set<number>();\n    for (const p of this.group) {\n      // Ignore coordinates outside the board\n      if (!this.board.inBounds(p)) continue;\n      const tile = this.board.tileAt(p);\n      if (tile) {\n        // Emit activation event for any super tile so FX can play before gravity.\n        // Provide the board position so the VFX can appear where the tile was.\n        if (tile.kind !== TileKind.Normal) {\n          this.bus.emit(\n            EventNames.SuperTileActivated,\n            tile.kind,\n            new cc.Vec2(p.x, p.y),\n          );\n        }\n        this.board.setTile(p, null);\n        cols.add(p.x);\n      }\n    }\n\n    // Emit completion event with affected column numbers\n    this.bus.emit(EventNames.TilesRemoved, Array.from(cols));\n  }\n}\n","const { ccclass, property } = cc._decorator;\n\n/**\n * Controller for the rocket effect with two tails.\n * Manages two particles that fly in opposite directions.\n */\n@ccclass()\nexport class RocketVfxController extends cc.Component {\n  @property(cc.ParticleSystem)\n  leftTail: cc.ParticleSystem | null = null;\n\n  @property(cc.ParticleSystem)\n  rightTail: cc.ParticleSystem | null = null;\n\n  @property({ type: cc.Float, range: [0.5, 3.0, 0.1] })\n  speed: number = 1.5;\n\n  @property({ type: cc.Float, range: [0.5, 2.0, 0.1] })\n  duration: number = 1.0;\n\n  @property({ type: cc.Float, range: [0, 360, 5] })\n  leftAngle: number = 135; // Left-up\n\n  @property({ type: cc.Float, range: [0, 360, 5] })\n  rightAngle: number = 45; // Right-up\n\n  @property({ type: cc.Float, range: [0, 360, 5] })\n  movementAngle: number = 90; // Node movement angle (default up)\n\n  private isPlaying = false;\n\n  /**\n   * Starts the rocket effect with two tails.\n   * @returns Promise that resolves when the effect is finished\n   */\n  play(): Promise<void> {\n    return new Promise((resolve) => {\n      if (this.isPlaying) {\n        resolve();\n        return;\n      }\n\n      if (!this.node || !cc.isValid(this.node)) {\n        console.warn(\"Node is null or invalid\");\n        resolve();\n        return;\n      }\n\n      this.isPlaying = true;\n\n      // Configure and start the left tail\n      if (this.leftTail) {\n        this.setupTail(this.leftTail, this.leftAngle);\n        this.leftTail.resetSystem();\n      }\n\n      // Configure and start the right tail\n      if (this.rightTail) {\n        this.setupTail(this.rightTail, this.rightAngle);\n        this.rightTail.resetSystem();\n      }\n\n      // Animate the node movement beyond the screen\n      this.animateNodeMovement();\n\n      // Wait for the effect to finish\n      const finish = () => {\n        this.isPlaying = false;\n        if (this.node && cc.isValid(this.node)) {\n          this.node.destroy();\n        }\n        resolve();\n      };\n\n      // Subscribe to the completion of both tails\n      if (this.leftTail?.node && cc.isValid(this.leftTail.node)) {\n        this.leftTail.node.once(\"finished\", finish);\n      }\n      if (this.rightTail?.node && cc.isValid(this.rightTail.node)) {\n        this.rightTail.node.once(\"finished\", finish);\n      }\n\n      // Fallback: if the events don't work, finish through duration\n      setTimeout(() => {\n        if (this.isPlaying) {\n          finish();\n        }\n      }, this.duration * 1000);\n    });\n  }\n\n  /**\n   * Animates the node with particles in different directions.\n   */\n  private animateNodeMovement(): void {\n    // Get the screen size\n    const visibleSize = cc.view.getVisibleSize();\n    const screenWidth = visibleSize.width;\n    const screenHeight = visibleSize.height;\n    const distance = Math.max(screenWidth, screenHeight) * 1.5; // 1.5x screen size\n\n    // Animate the left tail\n    if (this.leftTail?.node && cc.isValid(this.leftTail.node)) {\n      const leftAngleRad = (this.leftAngle * Math.PI) / 180;\n      const leftDirectionX = Math.cos(leftAngleRad);\n      const leftDirectionY = Math.sin(leftAngleRad);\n\n      const leftEndX = this.leftTail.node.x + leftDirectionX * distance;\n      const leftEndY = this.leftTail.node.y + leftDirectionY * distance;\n\n      const leftMoveAction = cc.moveTo(this.duration, leftEndX, leftEndY);\n      this.leftTail.node.runAction(leftMoveAction);\n    }\n\n    // Animate the right tail\n    if (this.rightTail?.node && cc.isValid(this.rightTail.node)) {\n      const rightAngleRad = (this.rightAngle * Math.PI) / 180;\n      const rightDirectionX = Math.cos(rightAngleRad);\n      const rightDirectionY = Math.sin(rightAngleRad);\n\n      const rightEndX = this.rightTail.node.x + rightDirectionX * distance;\n      const rightEndY = this.rightTail.node.y + rightDirectionY * distance;\n\n      const rightMoveAction = cc.moveTo(this.duration, rightEndX, rightEndY);\n      this.rightTail.node.runAction(rightMoveAction);\n    }\n  }\n\n  /**\n   * Configures the rocket tail with a given angle.\n   */\n  private setupTail(particleSystem: cc.ParticleSystem, angle: number): void {\n    if (!particleSystem || !cc.isValid(particleSystem)) {\n      console.warn(\"ParticleSystem is null or invalid\");\n      return;\n    }\n\n    // Disable automatic removal\n    (\n      particleSystem as unknown as { autoRemoveOnFinish?: boolean }\n    ).autoRemoveOnFinish = false;\n\n    // Configure particle parameters\n    particleSystem.duration = this.duration;\n    particleSystem.life = this.duration * 0.8;\n    particleSystem.speed = this.speed * 30; // Even less particle speed because nodes move\n    particleSystem.angle = angle;\n    particleSystem.angleVar = 0; // Small deviation\n\n    // Configure size and color\n    particleSystem.startSize = 250;\n    particleSystem.endSize = 5;\n    particleSystem.startSizeVar = 5;\n    particleSystem.endSizeVar = 2;\n\n    // Configure colors (orange-red tail)\n    particleSystem.startColor = cc.color(255, 200, 100, 255);\n    particleSystem.endColor = cc.color(255, 100, 50, 0);\n    particleSystem.startColorVar = cc.color(50, 50, 50, 50);\n    particleSystem.endColorVar = cc.color(30, 30, 30, 30);\n\n    // Configure emission\n    particleSystem.emissionRate = 200;\n    particleSystem.totalParticles = 100;\n\n    // Configure physics - remove gravity for better tail effect\n    particleSystem.gravity = cc.v2(0, 0);\n    particleSystem.tangentialAccel = 0;\n    particleSystem.radialAccel = 0;\n    particleSystem.speedVar = 20;\n\n    // Position settings\n    particleSystem.sourcePos = cc.v2(0, 0);\n    particleSystem.posVar = cc.v2(2, 2);\n    particleSystem.positionType = cc.ParticleSystem.PositionType.RELATIVE; // Relative to the node\n\n    // Rotation settings\n    particleSystem.startSpin = 0;\n    particleSystem.endSpin = 0;\n    particleSystem.startSpinVar = 180;\n    particleSystem.endSpinVar = 180;\n    particleSystem.rotationIsDir = true;\n  }\n\n  /**\n   * Stops the effect.\n   */\n  stop(): void {\n    this.isPlaying = false;\n    if (this.leftTail && cc.isValid(this.leftTail)) {\n      this.leftTail.stopSystem();\n    }\n    if (this.rightTail && cc.isValid(this.rightTail)) {\n      this.rightTail.stopSystem();\n    }\n  }\n}\n\nexport default RocketVfxController;\n","const { ccclass } = cc._decorator;\n\ndeclare const screen: {\n  safeArea: { x: number; y: number; width: number; height: number };\n};\n\ninterface Adjustable {\n  paddingLeft: number;\n  paddingRight: number;\n  paddingBottom: number;\n  paddingTop: number;\n}\n\ninterface NodeWithUITransform {\n  getComponent(name: string): Adjustable | null;\n}\n\n/**\n * Adjusts the padding of the attached UI node to match the device safe area.\n * This ensures that on devices with notches or rounded corners the HUD\n * elements remain fully visible.\n *\n * Canvas automatically scales to 540x960 while preserving aspect ratio using\n * the Fit Width & Fit Height settings defined in the scene files. The safe\n * area offsets are then applied here at runtime so UI widgets avoid cutouts\n * on phones like iPhone X.\n */\n@ccclass()\nexport class SafeAreaAdjuster extends cc.Component {\n  /** Reads screen.safeArea and applies it to the node's UITransform. */\n  start(): void {\n    const area = screen.safeArea;\n    const node = this.node as unknown as NodeWithUITransform;\n    const uiTransform = node.getComponent(\"UITransform\");\n    if (!uiTransform || !area) return;\n\n    uiTransform.paddingLeft = area.x;\n    uiTransform.paddingRight = area.width - area.x;\n    uiTransform.paddingBottom = area.y;\n    uiTransform.paddingTop = area.height - area.y;\n  }\n}\n","import { ScoreStrategy } from \"./ScoreStrategy\";\n\n/**\n * Quadratic scoring strategy rewarding large groups.\n *\n * Points are calculated as `(size - 1)^2 * multiplier`. Subtracting one\n * makes single-tile groups worth zero points, encouraging players to clear\n * at least two tiles. Squaring the size rapidly increases reward for large\n * groups so players aim for big combos. The multiplier adjusts overall pace\n * of scoring.\n */\nexport class ScoreStrategyQuadratic implements ScoreStrategy {\n  /**\n   * @param multiplier Coefficient applied to the quadratic result. Defaults to 10.\n   */\n  constructor(private multiplier = 10) {}\n\n  /**\n   * Calculates score for the given group size.\n   * @param size Number of tiles in the removed group\n   * @returns Amount of points awarded\n   */\n  calculate(size: number): number {\n    return Math.pow(size - 1, 2) * this.multiplier;\n  }\n}\n","/**\n * Configuration for subtle shockwave offsets applied to neighbour tiles\n * when super tiles are activated. Values are in pixels/seconds.\n */\nexport const shock = {\n  bombOffset: 12,\n  bombDurationOut: 0.08,\n  bombDurationBack: 0.12,\n  lineOffset: 8,\n  lineDuration: 0.1,\n};\n","import { InfrastructureEventBus } from \"../../infrastructure/InfrastructureEventBus\";\nimport { Board } from \"./Board\";\nimport { BoardSolver } from \"./BoardSolver\";\nimport { Tile } from \"./Tile\";\nimport { BoardConfig } from \"../../config/ConfigLoader\";\nimport { EventNames } from \"../events/EventNames\";\n\nexport class ShuffleService {\n  private shuffleCount = 0;\n  constructor(\n    private board: Board,\n    private solver: BoardSolver,\n    private bus: InfrastructureEventBus,\n    private maxShuffles: number = 3,\n  ) {}\n\n  /**\n   * Checks if there are moves and if not:\n   * - if shuffleCount < maxShuffles:\n   *     emit 'AutoShuffle', call shuffle() and increment the counter;\n   * - otherwise emit 'ShuffleLimitExceeded'.\n   */\n  ensureMoves(): void {\n    if (this.solver.hasMoves()) {\n      // If there are moves, do nothing.\n      return;\n    }\n\n    if (this.shuffleCount < this.maxShuffles) {\n      // Notify that an automatic shuffle will happen.\n      this.bus.emit(EventNames.AutoShuffle);\n      // Increment the counter before the operation.\n      this.shuffleCount++;\n      // Shuffle the tiles on the board.\n      this.shuffle();\n    } else {\n      // Reached the limit, no more shuffling allowed.\n      this.bus.emit(EventNames.ShuffleLimitExceeded);\n    }\n  }\n\n  /**\n   * Shuffles all tiles on the board in random order.\n   * Emits 'ShuffleDone' after completion.\n   */\n  shuffle(): void {\n    const cfg = (this.board as unknown as { cfg: BoardConfig }).cfg;\n    const tiles: (Tile | null)[] = [];\n\n    // Read the current state of the board into a flat array.\n    for (let y = 0; y < cfg.rows; y++) {\n      for (let x = 0; x < cfg.cols; x++) {\n        tiles.push(this.board.tileAt(new cc.Vec2(x, y)));\n      }\n    }\n\n    // Fisher-Yates algorithm for uniform shuffling.\n    for (let i = tiles.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [tiles[i], tiles[j]] = [tiles[j], tiles[i]];\n    }\n\n    // Write tiles back to the board, iterating over columns.\n    let idx = 0;\n    for (let x = 0; x < cfg.cols; x++) {\n      for (let y = 0; y < cfg.rows; y++) {\n        this.board.setTile(new cc.Vec2(x, y), tiles[idx++] ?? null);\n      }\n    }\n\n    // Notify listeners that the shuffling is done.\n    this.bus.emit(EventNames.ShuffleDone);\n  }\n\n  /**\n   * Resets the counter of used shuffles.\n   */\n  reset(): void {\n    this.shuffleCount = 0;\n  }\n}\n","import { InfrastructureEventBus } from \"../../infrastructure/InfrastructureEventBus\";\nimport { EventNames } from \"../events/EventNames\";\n\n/**\n * Subscribes to game events and plays matching sound effects when available.\n * Missing sound files are ignored silently.\n */\nexport class SoundController {\n  /** Cache of loaded audio clips. */\n  private static clips: Record<string, cc.AudioClip> = {};\n\n  /** Registered handlers for cleanup. */\n  private handlers: Record<string, (...args: unknown[]) => void> = {};\n\n  constructor(private bus: InfrastructureEventBus) {\n    // Map event names to sound asset base names (without extension).\n    const map: Record<string, string> = {\n      [EventNames.TilePressed]: \"tile_click\",\n      [EventNames.InvalidTap]: \"invalid_tap\",\n      [EventNames.FallDone]: \"tile_fall\",\n      [EventNames.SwapDone]: \"tile_swap\",\n      [EventNames.SuperTileCreated]: \"super_tile\",\n      [EventNames.SuperTileActivated]: \"super_tile_activated\",\n      [EventNames.BoosterActivated]: \"tile_click\",\n      [EventNames.BoosterConsumed]: \"booster_use\",\n      [EventNames.BoosterTargetSelected]: \"booster_target\",\n      [EventNames.GameWon]: \"game_win\",\n      [EventNames.GameLost]: \"game_lost\",\n      [EventNames.TurnUsed]: \"turn_used\",\n      [EventNames.TurnEnded]: \"turn_end\",\n    };\n\n    // Subscribe to each event in the map\n    Object.keys(map).forEach((evt) => {\n      const handler = () => SoundController.play(map[evt]);\n      this.bus.on(evt, handler);\n      this.handlers[evt] = handler;\n    });\n  }\n\n  /** Remove listeners when controller is destroyed. */\n  destroy(): void {\n    Object.keys(this.handlers).forEach((evt) => {\n      this.bus.off(evt, this.handlers[evt]);\n    });\n    this.handlers = {};\n  }\n\n  /** Load and play a clip by name, caching for subsequent use. */\n  private static play(name: string): void {\n    const cached = SoundController.clips[name];\n    if (cached) {\n      cc.audioEngine.playEffect(cached, false);\n      return;\n    }\n    cc.resources.load(`sounds/${name}`, cc.AudioClip, (err, clip) => {\n      if (err || !clip) return;\n      SoundController.clips[name] = clip;\n      cc.audioEngine.playEffect(clip, false);\n    });\n  }\n}\n","const { ccclass, property } = cc._decorator;\n\n/**\n * Utility for highlighting a sprite with a tint.\n * Applies a color tint to the sprite to create a highlight effect.\n */\n@ccclass()\nexport default class SpriteHighlight extends cc.Component {\n  @property(cc.Color)\n  highlightColor: cc.Color = cc.Color.YELLOW;\n\n  @property({ type: cc.Integer, range: [0, 255, 1] })\n  highlightOpacity: number = 255;\n\n  private originalColor: cc.Color = cc.Color.WHITE;\n  private originalOpacity: number = 255;\n  private isHighlighted: boolean = false;\n  private sprite: cc.Sprite = null;\n\n  onLoad() {\n    this.sprite = this.node.getComponent(cc.Sprite);\n    if (this.sprite) {\n      // Save the original values\n      this.originalColor = this.node.color.clone();\n      this.originalOpacity = this.node.opacity;\n    }\n  }\n\n  /**\n   * Toggles the highlight state\n   */\n  public toggleHighlight(): void {\n    if (this.isHighlighted) {\n      this.clearHighlight();\n    } else {\n      this.setHighlight();\n    }\n  }\n\n  /**\n   * Sets the highlight\n   */\n  public setHighlight(): void {\n    if (!this.sprite) return;\n\n    this.isHighlighted = true;\n    this.node.color = this.highlightColor;\n    this.node.opacity = this.highlightOpacity;\n  }\n\n  /**\n   * Removes the highlight\n   */\n  public clearHighlight(): void {\n    if (!this.sprite) return;\n\n    this.isHighlighted = false;\n    this.node.color = this.originalColor;\n    this.node.opacity = this.originalOpacity;\n  }\n\n  /**\n   * Checks if the sprite is highlighted\n   */\n  public isHighlightedState(): boolean {\n    return this.isHighlighted;\n  }\n\n  /**\n   * Changes the highlight color\n   */\n  public setHighlightColor(color: cc.Color): void {\n    this.highlightColor = color;\n    if (this.isHighlighted && this.sprite) {\n      this.node.color = color;\n    }\n  }\n\n  /**\n   * Changes the highlight opacity\n   */\n  public setHighlightOpacity(opacity: number): void {\n    this.highlightOpacity = opacity;\n    if (this.isHighlighted && this.sprite) {\n      this.node.opacity = opacity;\n    }\n  }\n\n  /**\n   * Force updates the original values (if the sprite has changed)\n   */\n  public updateOriginalValues(): void {\n    if (this.sprite) {\n      this.originalColor = this.node.color.clone();\n      this.originalOpacity = this.node.opacity;\n    }\n  }\n\n  /**\n   * Resets to the original values\n   */\n  public resetToOriginal(): void {\n    this.clearHighlight();\n    this.updateOriginalValues();\n  }\n\n  onDestroy() {\n    // Remove the highlight when destroying\n    this.clearHighlight();\n  }\n}\n","import { Booster } from \"./Booster\";\nimport { Board } from \"../board/Board\";\nimport { Tile, TileKind } from \"../board/Tile\";\nimport { InfrastructureEventBus } from \"../../infrastructure/InfrastructureEventBus\";\nimport { EventNames } from \"../events/EventNames\";\nimport { BoosterService } from \"./BoosterService\";\nimport TileView from \"../../ui/views/TileView\";\n\n/**\n * Generic booster that transforms a single tile into a specific super tile.\n * The booster waits for the player to select a tile and immediately consumes\n * a charge on placement. The created super tile can be activated later as a\n * normal tile interaction without spending another charge.\n */\nexport class SuperTileBooster implements Booster {\n  id: string;\n  charges: number;\n\n  constructor(\n    id: string,\n    private board: Board,\n    private getView: (p: cc.Vec2) => TileView | undefined,\n    private bus: InfrastructureEventBus,\n    private svc: BoosterService,\n    charges: number,\n    private kind: TileKind,\n  ) {\n    this.id = id;\n    this.charges = charges;\n  }\n\n  canActivate(): boolean {\n    return this.charges > 0;\n  }\n\n  start(): void {\n    const onPlace = (pos: unknown): void => {\n      this.bus.off(EventNames.BoosterCancelled, onCancel);\n      this.bus.off(EventNames.GroupSelected, onPlace);\n      if (this.charges <= 0) return;\n      const p = pos as cc.Vec2;\n      const tile = this.board.tileAt(p);\n      if (!tile || tile.kind !== TileKind.Normal) return;\n      // Списываем заряд при установке, чтобы отмена не допускалась\n      // и игрок не мог бесконечно откладывать оплату за созданный супер-тайл.\n      // Активация эффекта произойдёт позже обычным нажатием по тайлу,\n      // поэтому логика зарядов отделена от последующего использования.\n      this.svc.consume(this.id);\n      const superTile: Tile = { ...tile, kind: this.kind };\n      this.board.setTile(p, superTile);\n      const view = this.getView(p);\n      view?.apply(superTile);\n      this.bus.emit(EventNames.SuperTilePlaced, {\n        kind: this.kind,\n        position: p,\n      });\n    };\n\n    const onCancel = (): void => {\n      this.bus.off(EventNames.GroupSelected, onPlace);\n      this.bus.off(EventNames.BoosterCancelled, onCancel);\n    };\n\n    this.bus.on(EventNames.GroupSelected, onPlace);\n    this.bus.on(EventNames.BoosterCancelled, onCancel);\n  }\n}\n","import * as seedrandom from \"seedrandom\";\nimport { BoardConfig } from \"../../config/ConfigLoader\";\nimport { TileKind } from \"../board/Tile\";\n\n/**\n * Returns the type of super tile based on the random number generator.\n * With the same seed, the sequence is deterministic.\n */\nexport class SuperTileFactory {\n  /** Random number generator for choosing the tile type. */\n  private rng: () => number;\n\n  constructor(private cfg: BoardConfig) {\n    // If a seed is specified, use it for deterministic RNG\n    this.rng = cfg.rngSeed ? seedrandom(cfg.rngSeed) : Math.random;\n  }\n\n  /**\n   * Creates the type of super tile based on customizable chances.\n   * If chances are not configured, the default values are used:\n   * SuperRow: 50%, SuperCol: 30%, SuperBomb: 15%, SuperClear: 5%\n   */\n  make(kindSeed = this.rng()): TileKind {\n    const chances = this.cfg.superChances;\n\n    if (chances) {\n      // Use customizable chances\n      let cumulative = 0;\n\n      cumulative += chances.row;\n      if (kindSeed < cumulative) return TileKind.SuperRow;\n\n      cumulative += chances.col;\n      if (kindSeed < cumulative) return TileKind.SuperCol;\n\n      cumulative += chances.bomb;\n      if (kindSeed < cumulative) return TileKind.SuperBomb;\n\n      return TileKind.SuperClear;\n    } else {\n      // Use default values\n      if (kindSeed < 0.5) return TileKind.SuperRow;\n      if (kindSeed < 0.8) return TileKind.SuperCol;\n      if (kindSeed < 0.95) return TileKind.SuperBomb;\n      return TileKind.SuperClear;\n    }\n  }\n}\n","import { Board } from \"../Board\";\nimport { InfrastructureEventBus } from \"../../../infrastructure/InfrastructureEventBus\";\nimport { ICommand } from \"./ICommand\";\nimport { EventNames } from \"../../events/EventNames\";\n\n/**\n * Swaps tiles at two positions on the board and notifies listeners.\n */\nexport class SwapCommand implements ICommand {\n  constructor(\n    private board: Board,\n    private a: cc.Vec2,\n    private b: cc.Vec2,\n    private bus: InfrastructureEventBus,\n  ) {}\n\n  async execute(): Promise<void> {\n    if (!this.board.inBounds(this.a) || !this.board.inBounds(this.b)) {\n      throw new Error(\"SwapCommand: coordinates out of bounds\");\n    }\n    const tA = this.board.tileAt(this.a);\n    const tB = this.board.tileAt(this.b);\n    this.board.setTile(this.a, tB);\n    this.board.setTile(this.b, tA);\n    // Notify listeners with coordinates so UI can animate the swap\n    this.bus.emit(EventNames.SwapDone, this.a, this.b);\n  }\n}\n","import { Booster } from \"./Booster\";\nimport { Board } from \"../board/Board\";\nimport { InfrastructureEventBus } from \"../../infrastructure/InfrastructureEventBus\";\nimport { SwapCommand } from \"../board/commands/SwapCommand\";\nimport { BoardSolver } from \"../board/BoardSolver\";\nimport { EventNames } from \"../events/EventNames\";\n\n/**\n * Teleport booster allows swapping any two tiles in two taps without\n * extra confirmation.\n *\n * First tap selects tile A and emits {@link EventNames.BoosterTargetSelected}\n * with stage=\"first\" so the UI can highlight it. A second tap on the same\n * tile or outside the board cancels the selection and leaves charges intact.\n * Tapping a different tile B emits stage=\"second\" and triggers an immediate\n * swap. UI listens for {@link EventNames.SwapDone} to play a scale\n * out/in animation that keeps the swap atomic.\n *\n * By default the swap is always applied and a charge is consumed regardless of\n * the board state after the swap. When constructed with `requireMove=true` the\n * swap is reverted if no moves remain, {@link EventNames.SwapCancelled} is\n * emitted and the charge is preserved.\n */\nexport class TeleportBooster implements Booster {\n  id = \"teleport\";\n  charges: number;\n  constructor(\n    private board: Board,\n    private bus: InfrastructureEventBus,\n    charges: number,\n    /**\n     * When true, a swap that doesn't produce any subsequent moves is reverted\n     * and the charge isn't spent. Defaults to false meaning the swap always\n     * applies and consumes a charge.\n     */\n    private requireMove = false,\n  ) {\n    this.charges = charges;\n  }\n\n  canActivate(): boolean {\n    return this.charges > 0;\n  }\n\n  start(): void {\n    if (this.charges <= 0) {\n      // Activation guard in case service skips canActivate check\n      this.bus.emit(EventNames.BoosterCancelled);\n      return;\n    }\n\n    let first: cc.Vec2 | null = null;\n\n    const externalCancel = (): void => {\n      this.bus.off(EventNames.GroupSelected, onFirst);\n      this.bus.off(EventNames.GroupSelected, onSecond);\n      this.bus.off(EventNames.InvalidTap, cancel);\n      this.bus.off(EventNames.BoosterCancelled, externalCancel);\n      first = null;\n    };\n\n    const cancel = (): void => {\n      this.bus.off(EventNames.GroupSelected, onSecond);\n      this.bus.off(EventNames.InvalidTap, cancel);\n      this.bus.off(EventNames.BoosterCancelled, externalCancel);\n      first = null;\n      this.bus.emit(EventNames.BoosterCancelled);\n      // Wait again for the first selection\n      rearm();\n    };\n\n    const onSecond = async (posB: unknown) => {\n      if (this.charges <= 0 || !first) return;\n      const b = posB as cc.Vec2;\n      // second tap on the same tile acts as cancellation\n      if (b.x === first.x && b.y === first.y) {\n        cancel();\n        return;\n      }\n      this.bus.off(EventNames.GroupSelected, onSecond);\n      this.bus.off(EventNames.InvalidTap, cancel);\n      this.bus.off(EventNames.BoosterCancelled, externalCancel);\n      this.bus.emit(EventNames.BoosterTargetSelected, {\n        id: this.id,\n        stage: \"second\",\n        pos: b,\n      });\n\n      // Cache tiles in case we need to revert\n      const tA = this.board.tileAt(first);\n      const tB = this.board.tileAt(b);\n\n      // Perform swap with scale animation handled by UI on SwapDone\n      await new SwapCommand(this.board, first, b, this.bus).execute();\n\n      if (this.requireMove) {\n        const solver = new BoardSolver(this.board);\n        if (!solver.hasMoves()) {\n          // revert silently without emitting SwapDone again\n          if (tA && tB) {\n            this.board.setTile(first, tA);\n            this.board.setTile(b, tB);\n          }\n          this.bus.emit(EventNames.SwapCancelled);\n          return;\n        }\n      }\n\n      this.charges--;\n      this.bus.emit(EventNames.BoosterConsumed, this.id);\n    };\n\n    const onFirst = (posA: unknown) => {\n      this.bus.off(EventNames.GroupSelected, onFirst);\n      first = posA as cc.Vec2;\n      this.bus.emit(EventNames.BoosterTargetSelected, {\n        id: this.id,\n        stage: \"first\",\n        pos: first,\n      });\n      this.bus.on(EventNames.GroupSelected, onSecond);\n      // Taps outside the board publish InvalidTap which cancels the booster\n      this.bus.on(EventNames.InvalidTap, cancel);\n    };\n\n    const rearm = (): void => {\n      this.bus.on(EventNames.GroupSelected, onFirst);\n      this.bus.on(EventNames.BoosterCancelled, externalCancel);\n    };\n\n    // Wait for the first cell selection\n    rearm();\n  }\n}\n","const { ccclass, property } = cc._decorator;\n\nimport { TileKind } from \"./Tile\";\nimport { FXController } from \"../fx/FXController\";\n\n/**\n * Metadata for the visual prefab of a tile.\n * Specifies which kind it belongs to and which visual effects to play.\n */\n\n@ccclass()\nexport class TileAppearanceConfig extends cc.Component {\n  /** Type of super tile (or Normal for normal). */\n  private static readonly ccEnum = (\n    cc as unknown as { Enum?: (e: object) => unknown }\n  ).Enum;\n  @property({\n    type: TileAppearanceConfig.ccEnum\n      ? TileAppearanceConfig.ccEnum(TileKind)\n      : TileKind,\n  })\n  kind: TileKind = TileKind.Normal;\n\n  /**\n   * Prefab of the visual effect that plays when the tile appears.\n   */\n  @property(cc.Prefab)\n  spawnFx: cc.Prefab | null = null;\n\n  /**\n   * Prefab of the visual effect that plays when the tile is activated\n   * (e.g. when a super tile is triggered).\n   */\n  @property(cc.Prefab)\n  activateFx: cc.Prefab | null = null;\n\n  // Additional parameters can be added here (color flashes, multipliers, etc.)\n\n  onLoad(): void {\n    if (this.activateFx) {\n      FXController.setPrefab(this.kind, this.activateFx);\n    }\n  }\n}\n","const { ccclass, property } = cc._decorator;\n\nimport { loadBoardConfig } from \"../../config/ConfigLoader\";\nimport { EventBus as bus } from \"../../core/EventBus\";\nimport { EventNames } from \"../../core/events/EventNames\";\nimport GameBoardController from \"./GameBoardController\";\nimport TileView from \"../views/TileView\";\n\n@ccclass()\nexport default class TileInputController extends cc.Component {\n  @property(cc.Node)\n  tilesLayer: cc.Node = null;\n\n  private boardCtrl!: GameBoardController;\n\n  onLoad(): void {\n    this.boardCtrl = this.getComponent(GameBoardController)!;\n    console.log(\"TileInputController onLoad\", this.boardCtrl);\n    if (this.tilesLayer.width === 0 || this.tilesLayer.height === 0) {\n      const cfg = loadBoardConfig();\n      this.tilesLayer.width = cfg.cols * cfg.tileWidth;\n      this.tilesLayer.height = cfg.rows * cfg.tileHeight;\n    }\n\n    // Attach a single click listener on the tilesLayer node\n    this.tilesLayer.on(\n      cc.Node.EventType.TOUCH_END,\n      (e: cc.Event.EventTouch) => {\n        const worldPos = e.getLocation();\n        const local = this.tilesLayer.convertToNodeSpaceAR(worldPos);\n        // convert node-space coordinates to column/row using tile size\n        const col = Math.floor(\n          (local.x + this.tilesLayer.width / 2) / loadBoardConfig().tileWidth,\n        );\n        const row = Math.floor(\n          (this.tilesLayer.height / 2 - (local.y - 12)) /\n            loadBoardConfig().tileHeight,\n        );\n        this.handleTap(col, row);\n      },\n      this,\n    );\n  }\n\n  handleTap(col: number, row: number): void {\n    const view: TileView | undefined = this.boardCtrl.tileViews[row]?.[col];\n    if (!view || !view.isInteractive()) {\n      console.debug(\n        `Tile tap ignored: falling=${view?.[\"isFalling\"]} feedbackActive=${view?.[\"isFeedbackActive\"]} at {${col},${row}}`,\n      );\n      // Tap on an empty area is used by some boosters (e.g. teleport)\n      // as a cancellation signal. We publish InvalidTap so that subscribers can\n      // reset their state.\n      bus.emit(EventNames.InvalidTap, new cc.Vec2(col, row));\n      return;\n    }\n    console.debug(`Tile tap feedback started at {${col},${row}}`);\n    bus.emit(EventNames.GroupSelected, new cc.Vec2(col, row));\n  }\n}\n","const { ccclass } = cc._decorator;\n\nimport { EventBus as bus } from \"../../core/EventBus\";\nimport { EventNames } from \"../../core/events/EventNames\";\nimport GameBoardController from \"./GameBoardController\";\n\n@ccclass()\nexport default class TilePressFeedback extends cc.Component {\n  private boardCtrl!: GameBoardController;\n\n  onLoad(): void {\n    this.boardCtrl = this.getComponent(GameBoardController)!;\n    bus.on(EventNames.TilePressed, this.onTilePressed, this);\n  }\n\n  private onTilePressed(pos: cc.Vec2): void {\n    const view = this.boardCtrl.tileViews[pos.y]?.[pos.x];\n    view?.pressFeedback();\n  }\n}\n","const { ccclass, property } = cc._decorator;\n\nimport type { Tile, TileColor } from \"../../core/board/Tile\";\nimport { TileKind } from \"../../core/board/Tile\";\nimport { TileAppearanceConfig } from \"../../core/board/TileAppearanceConfig\";\nimport { VfxInstance } from \"../../core/fx/VfxInstance\";\n\n/**\n * TileView represents a game tile. It contains a `visualRoot` container where\n * different visual prefabs are substituted depending on the model.\n */\n@ccclass()\nexport default class TileView extends cc.Component {\n  /** Node where visual variants of the tile are instantiated. */\n  @property(cc.Node)\n  visualRoot: cc.Node = null;\n\n  /** Prefabs of normal tiles (by colors). The order corresponds to the enumeration of colors. */\n  @property([cc.Prefab])\n  normalVariants: cc.Prefab[] = [];\n\n  /**\n   * Prefabs of super‑tiles by index {@link TileKind}.\n   * Index 1 → SuperRow, 2 → SuperCol, 3 → SuperBomb, 4 → SuperClear.\n   * The array must contain placeholders for unused types to\n   * correspond to the values of the enumeration.\n   */\n  @property([cc.Prefab])\n  superVariants: cc.Prefab[] = new Array(TileKind.SuperClear + 1).fill(null!);\n\n  /** Current visual node placed in visualRoot. */\n  private currentVisual: cc.Node | null = null;\n\n  /** Prefab of the activation effect taken from {@link TileAppearanceConfig}. */\n  private activateFx: cc.Prefab | null = null;\n\n  /** Cache of the tile model for possible updates. */\n  public tile!: Tile;\n\n  /** Position of the tile on the board for logging and events. */\n  public boardPos: cc.Vec2 = cc.v2(0, 0);\n\n  /** Tile in the falling state. */\n  private isFalling = false;\n  /** Tile plays the feedback animation. */\n  private isFeedbackActive = false;\n\n  /** Returns true if the tile is ready to respond to input. */\n  isInteractive(): boolean {\n    return !this.isFalling && !this.isFeedbackActive;\n  }\n\n  /** Called before the falling animation starts. */\n  startFall(): void {\n    this.isFalling = true;\n  }\n\n  /** Ends the falling state. */\n  endFall(): void {\n    this.isFalling = false;\n  }\n\n  /**\n   * Substitutes the appropriate visual prefab for the tile data.\n   * The old visual node is removed, then a new one is instantiated in visualRoot.\n   * If {@link TileAppearanceConfig.spawnFx} is present, the VFX is played.\n   */\n  apply(tile: Tile): void {\n    this.tile = tile;\n\n    // 1. Select the appropriate prefab by color/kind\n    let prefab: cc.Prefab | undefined;\n    if (tile.kind === TileKind.Normal) {\n      const idx = this.colorIndex(tile.color);\n      prefab = this.normalVariants[idx];\n    } else {\n      prefab = this.superVariants[tile.kind];\n    }\n    if (!prefab) return;\n\n    // 2. Remove the previous visualization\n    if (this.currentVisual) {\n      // In the test environment, destroy may be missing\n      const maybe = this.currentVisual as unknown as { destroy?: () => void };\n      if (typeof maybe.destroy === \"function\") {\n        maybe.destroy();\n      }\n      this.currentVisual = null;\n    }\n\n    // 3. Instantiate a new one and place it in visualRoot\n    const node = cc.instantiate(prefab);\n    node.parent = this.visualRoot;\n    this.currentVisual = node;\n\n    // 4. Read the visual prefab config and play the effects\n    const cfg = node.getComponent(TileAppearanceConfig);\n    if (cfg) {\n      this.activateFx = cfg.activateFx;\n      if (cfg.spawnFx) {\n        const fx = cc.instantiate(cfg.spawnFx);\n        fx.parent = this.node;\n      }\n    } else {\n      this.activateFx = null;\n    }\n  }\n\n  /**\n   * Activates a super‑tile, starting the effect from {@link TileAppearanceConfig}.\n   */\n  activateSuper(): void {\n    if (this.activateFx) {\n      const fx = cc.instantiate(this.activateFx);\n      // Position effect relative to a persistent layer so it survives tile removal\n      const parent =\n        (this.node.parent as cc.Node | null) ||\n        (cc.director.getScene?.() as cc.Node | null);\n      fx.parent = parent || this.node;\n      fx.setPosition(this.node.position);\n\n      const instance = fx.getComponent(VfxInstance);\n      instance?.play();\n      // Prevent repeated activation from triggering the effect again\n      this.activateFx = null;\n    }\n    // Additional indication can be added here\n  }\n\n  /** Feedback animation. */\n  pressFeedback(): void {\n    this.isFeedbackActive = true;\n    const target = this.node;\n\n    const defaultAnchor = cc.v2(0, 1);\n\n    const maybe = target as unknown as {\n      stopAllActions?: () => void;\n      setScale?: (x: number, y?: number) => void;\n    };\n    if (typeof maybe.stopAllActions === \"function\") maybe.stopAllActions();\n    if (typeof maybe.setScale === \"function\") maybe.setScale(1, 1);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    target.runAction(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (cc.sequence as any)(\n        cc.scaleTo(0.08, 0.9),\n        cc.scaleTo(0.1, 1.0),\n        cc.callFunc(() => {\n          target.setAnchorPoint(defaultAnchor);\n          this.isFeedbackActive = false;\n        }),\n      ),\n    );\n  }\n\n  /** Returns the index of the color in the array of normal variants. */\n  private colorIndex(color: TileColor): number {\n    const order: TileColor[] = [\"red\", \"blue\", \"green\", \"yellow\", \"purple\"];\n    const idx = order.indexOf(color);\n    return idx >= 0 ? idx : 0;\n  }\n}\n","/**\n * Definitions of the game tile model.\n */\n\n/**\n * Possible colors of tiles on the board.\n */\nexport type TileColor = \"red\" | \"blue\" | \"green\" | \"yellow\" | \"purple\";\n\n/**\n * Enumeration of tile types.\n */\nexport enum TileKind {\n  /** normal tile */\n  Normal,\n  /** super tile: burns a row */\n  SuperRow,\n  /** super tile: burns a column */\n  SuperCol,\n  /** radius R */\n  SuperBomb,\n  /** clears the entire field */\n  SuperClear,\n}\n\n/**\n * Interface of the game tile.\n */\nexport interface Tile {\n  /** unique identifier */\n  id: number;\n  /** color of the tile */\n  color: TileColor;\n  /** type of the tile */\n  kind: TileKind;\n}\n\n/**\n * Factory for creating tiles.\n */\nexport class TileFactory {\n  /** counter of identifiers */\n  private static nextId = 0;\n\n  /**\n   * Creates a normal tile of the given color.\n   * @param color Color of the tile\n   * @returns New tile with type {@link TileKind.Normal}\n   */\n  public static createNormal(color: TileColor): Tile {\n    return {\n      id: ++this.nextId,\n      color,\n      kind: TileKind.Normal,\n    };\n  }\n}\n","import { InfrastructureEventBus } from \"../../infrastructure/InfrastructureEventBus\";\nimport { EventNames } from \"../events/EventNames\";\nexport class TurnManager {\n  /** Remaining turns in the current session. */\n  private turnsLeft: number;\n  /** Starting amount of turns to allow resetting. */\n  private readonly initialTurns: number;\n\n  /**\n   * Creates a turn manager with the given initial amount of turns.\n   * @param initialTurns Starting number of turns\n   * @param bus Event bus used to emit turn related events\n   */\n  constructor(\n    initialTurns: number,\n    private bus: InfrastructureEventBus,\n  ) {\n    this.initialTurns = initialTurns;\n    this.turnsLeft = initialTurns;\n  }\n\n  /**\n   * Consumes one turn and notifies listeners.\n   *\n   * Emits `TurnUsed` with remaining turns after decrement. When no turns\n   * remain the `OutOfTurns` event is emitted once the count reaches zero.\n   */\n  useTurn(): void {\n    this.turnsLeft--;\n    this.bus.emit(EventNames.TurnUsed, this.turnsLeft);\n    if (this.turnsLeft === 0) {\n      this.bus.emit(EventNames.OutOfTurns);\n    }\n  }\n\n  /**\n   * Returns the number of turns still available.\n   */\n  getRemaining(): number {\n    return this.turnsLeft;\n  }\n\n  /**\n   * Resets remaining turns back to their initial value.\n   */\n  reset(): void {\n    this.turnsLeft = this.initialTurns;\n  }\n}\n","const { ccclass, property } = cc._decorator;\n\n/**\n * Component that plays a VFX prefab and resolves when it finishes.\n */\n@ccclass()\nexport class VfxInstance extends cc.Component {\n  @property([cc.ParticleSystem])\n  particleSystems: cc.ParticleSystem[] = [];\n\n  @property([cc.Animation])\n  animations: cc.Animation[] = [];\n\n  @property([cc.Component])\n  extras: cc.Component[] = [];\n\n  /**\n   * Starts configured effects and resolves once all of them finish.\n   */\n  play(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const ps of this.particleSystems) {\n      if (!ps) continue;\n      // prevent auto removal so we can destroy node ourselves\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      (ps as unknown as { autoRemoveOnFinish?: boolean }).autoRemoveOnFinish =\n        false;\n      promises.push(\n        new Promise<void>((resolve) => {\n          const target =\n            typeof (ps as unknown as { once?: unknown }).once === \"function\"\n              ? (ps as unknown as {\n                  once: (event: string, cb: () => void) => void;\n                })\n              : ps.node;\n          target.once(\"finished\", resolve);\n          ps.resetSystem();\n        }),\n      );\n    }\n\n    for (const anim of this.animations) {\n      if (!anim) continue;\n      promises.push(\n        new Promise<void>((resolve) => {\n          anim.once(\"finished\", resolve);\n          anim.play();\n        }),\n      );\n    }\n\n    for (const extra of this.extras) {\n      if (!extra) continue;\n      const anyExtra = extra as unknown as {\n        play?: () => Promise<void> | void;\n        once?: (event: string, cb: () => void) => void;\n      };\n      if (typeof anyExtra.play === \"function\") {\n        const result = anyExtra.play();\n        promises.push(Promise.resolve(result));\n      } else if (typeof anyExtra.once === \"function\") {\n        promises.push(\n          new Promise<void>((resolve) => {\n            anyExtra.once!(\"finished\", resolve);\n          }),\n        );\n      }\n    }\n\n    if (promises.length === 0) {\n      this.node.destroy();\n      return Promise.resolve();\n    }\n\n    return Promise.all(promises).then(() => {\n      this.node.destroy();\n    });\n  }\n}\n\nexport default VfxInstance;\n","/*\n * This script is automatically generated by Cocos Creator and is only compatible with projects prior to v2.1.0.\n * You do not need to manually add this script in any other project.\n * If you don't use cc.Toggle in your project, you can delete this script directly.\n * If your project is hosted in VCS such as git, submit this script together.\n *\n * 此脚本由 Cocos Creator 自动生成，仅用于兼容 v2.1.0 之前版本的工程，\n * 你无需在任何其它项目中手动添加此脚本。\n * 如果你的项目中没用到 Toggle，可直接删除该脚本。\n * 如果你的项目有托管于 git 等版本库，请将此脚本一并上传。\n */\n\nif (cc.Toggle) {\n    // Whether the 'toggle' and 'checkEvents' events are fired when 'toggle.check() / toggle.uncheck()' is called in the code\n    // 在代码中调用 'toggle.check() / toggle.uncheck()' 时是否触发 'toggle' 与 'checkEvents' 事件\n    cc.Toggle._triggerEventInScript_check = true;\n}\n"],"file":"index.js"}