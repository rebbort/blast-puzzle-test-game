const { ccclass, property } = cc._decorator;

import { EventBus as bus } from "../../core/EventBus";
import { EventNames } from "../../core/events/EventNames";
import GameBoardController from "./GameBoardController";
import TileView from "../views/TileView";
import type { Board } from "../../core/board/Board";
import { loadBoardConfig } from "../../config/ConfigLoader";

@ccclass()
export default class MoveFlowController extends cc.Component {
  /** Parent node for new tile views */
  @property(cc.Node)
  tilesLayer!: cc.Node;

  /** Cached matrix of tile view components. Filled on load. */
  private tileViews!: TileView[][];
  /** Board model for reading final tile positions */
  private board!: Board;
  /** Reference to board controller so we can update its matrix */
  private boardCtrl!: GameBoardController;

  onLoad(): void {
    // Cache references to TileView matrix generated by GameBoardController
    this.boardCtrl = this.node.getComponent(GameBoardController)!;
    this.board = this.boardCtrl.getBoard();
    this.tileViews = this.boardCtrl.tileViews;

    // Listen for core events signalling board updates
    bus.on(EventNames.RemoveStarted, this.onRemove, this);
    bus.on(EventNames.FallDone, this.onFall, this);
    bus.on(EventNames.FillDone, this.onFill, this);
  }

  /**
   * Plays scale + fade animation on removed tile views.
   * @param positions coordinates of tiles removed by the core
   */
  private onRemove(positions: cc.Vec2[]): void {
    // Refresh local reference in case another controller replaced it
    this.tileViews = this.boardCtrl.tileViews;
    positions.forEach((p) => {
      const view = this.tileViews[p.y]?.[p.x];
      if (!view) return;
      view.node.runAction(
        cc.sequence(
          cc.spawn(cc.scaleTo(0.15, 0), cc.fadeOut(0.15)),
          cc.callFunc(() => view.node.destroy()),
        ),
      );
      this.tileViews[p.y][p.x] = undefined as unknown as TileView;
      this.boardCtrl.tileViews[p.y][p.x] = undefined as unknown as TileView;
    });
  }

  /**
   * Animates tiles falling after removal.
   * @param dirtyCols column indices reported by the core's FallCommand
   *                  that contained holes and were shifted down.
   *                  Each tile view in these columns moves to its new Y.
   */
  private onFall(): void {
    // Build mapping from tile model instances to their views
    const map = new Map<unknown, TileView>();
    this.tileViews.forEach((row) =>
      row.forEach((v) => {
        if (!v) return;
        map.set((v as unknown as { tile: unknown }).tile, v);
      }),
    );

    // Reconstruct matrix according to board state and move views
    const updated: (TileView | undefined)[][] = [];
    for (let r = 0; r < this.board.rows; r++) {
      updated[r] = new Array(this.board.cols);
    }

    this.board.forEach((p, t) => {
      const view = map.get(t);
      if (!view) return;
      const target = this.computePos(p.x, p.y);
      const dist = Math.abs(view.node.y - target.y);
      const dur = dist / 1400;
      view.node.runAction(cc.moveTo(dur, target.x, target.y));
      updated[p.y][p.x] = view;
    });

    this.tileViews = updated as TileView[][];
    this.boardCtrl.tileViews = this.tileViews;
  }

  /**
   * Refreshes the local tile view matrix after new tiles were spawned.
   * Filling is separate from falling because new pieces appear only
   * after all existing ones settle. We simply sync references so the
   * next fall step moves the correct nodes.
   */
  private onFill(): void {
    this.tileViews = this.boardCtrl.tileViews;
  }

  /**
   * Compute tile position exactly like in GameBoardController.
   * Board uses column/row with origin at the top-left whereas Cocos
   * positions are centred. Keeping the math identical ensures that
   * UI nodes line up with the model.
   */
  private computePos(col: number, row: number): cc.Vec2 {
    const cfg = loadBoardConfig();
    const x = (col - this.board.cols / 2) * cfg.tileWidth;
    const y =
      (this.board.rows / 2 - row) * cfg.tileHeight -
      GameBoardController.VERTICAL_OFFSET;
    return cc.v2(x, y);
  }
}
