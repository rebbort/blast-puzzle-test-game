const { ccclass, property } = cc._decorator;

import { EventBus as bus } from "../../core/EventBus";
import { EventNames } from "../../core/events/EventNames";
import GameBoardController from "./GameBoardController";
import TileView from "../views/TileView";
import type { Board } from "../../core/board/Board";
import { runFallAnimation } from "../utils/FallAnimator";
import { computeTilePosition } from "../utils/PositionUtils";

@ccclass()
export default class MoveFlowController extends cc.Component {
  /** Parent node for new tile views */
  @property(cc.Node)
  tilesLayer!: cc.Node;

  /** Cached matrix of tile view components. Filled on load. */
  private tileViews!: TileView[][];
  /** Board model for reading final tile positions */
  private board!: Board;
  /** Reference to board controller so we can update its matrix */
  private boardCtrl!: GameBoardController;

  onLoad(): void {
    // Cache references to TileView matrix generated by GameBoardController
    this.boardCtrl = this.node.getComponent(GameBoardController)!;
    this.board = this.boardCtrl.getBoard();
    this.tileViews = this.boardCtrl.tileViews;

    // Listen for core events signalling board updates
    bus.on(EventNames.RemoveStarted, this.onRemove, this);
    bus.on(EventNames.FallDone, this.onFall, this);
    bus.on(EventNames.FillDone, this.onFill, this);
    bus.on(EventNames.SuperTileCreated, this.onSuperTileCreated, this);
  }

  /**
   * Plays scale + fade animation on removed tile views.
   * @param positions coordinates of tiles removed by the core
   */
  private onRemove(positions: cc.Vec2[]): void {
    // Refresh local reference in case another controller replaced it
    this.tileViews = this.boardCtrl.tileViews;
    for (let i = 0; i < positions.length; i++) {
      const p = positions[i];
      const view = this.tileViews[p.y]?.[p.x];
      if (!view) continue;
      view.node.runAction(
        cc.sequence(
          cc.spawn(cc.scaleTo(0.15, 0), cc.fadeOut(0.15)),
          cc.callFunc(() => view.node.destroy()),
        ),
      );
      this.tileViews[p.y][p.x] = undefined as unknown as TileView;
      this.boardCtrl.tileViews[p.y][p.x] = undefined as unknown as TileView;
    }
  }

  /**
   * Animates tiles falling after removal.
   * @param dirtyCols column indices reported by the core's FallCommand
   *                  that contained holes and were shifted down.
   *                  Each tile view in these columns moves to its new Y.
   */
  private onFall(): void {
    // Build mapping from tile model instances to their views
    const map = new Map<unknown, TileView>();
    for (let rowIndex = 0; rowIndex < this.tileViews.length; rowIndex++) {
      const row = this.tileViews[rowIndex];
      for (let colIndex = 0; colIndex < row.length; colIndex++) {
        const v = row[colIndex];
        if (!v) continue;
        map.set(v.tile, v);
      }
    }

    // Reconstruct matrix according to board state and move views
    const updated: (TileView | undefined)[][] = [];
    for (let r = 0; r < this.board.rows; r++) {
      updated[r] = new Array(this.board.cols);
    }

    // Получаем все позиции и тайлы из board
    const positions: cc.Vec2[] = [];
    const tiles: unknown[] = [];

    this.board.forEach((p, t) => {
      positions.push(p);
      tiles.push(t);
    });

    // Обрабатываем каждую позицию
    for (let i = 0; i < positions.length; i++) {
      const p = positions[i];
      const t = tiles[i];
      const view = map.get(t);

      if (!view) {
        continue;
      }

      const target = computeTilePosition(p.x, p.y, this.board);
      const dist = Math.floor(Math.abs(view.node.y - target.y));

      if (dist > 0) {
        runFallAnimation(view.node, target);
      }

      view.node.zIndex = this.board.rows - p.y - 1;
      view.boardPos = cc.v2(p.x, p.y);
      updated[p.y][p.x] = view;
    }

    this.tileViews = updated as TileView[][];
    this.boardCtrl.tileViews = this.tileViews;
  }

  /**
   * Updates local references after new tiles were spawned.
   */
  private onFill(): void {
    this.tileViews = this.boardCtrl.tileViews;
  }

  /**
   * Spawns a view for a newly created super tile.
   */
  private onSuperTileCreated(pos: cc.Vec2): void {
    const view = this.boardCtrl.spawn(pos);
    view.apply(this.board.tileAt(pos)!);
    this.tileViews = this.boardCtrl.tileViews;
  }
}
