const { ccclass, property } = cc._decorator;

import { EventBus as bus } from "../../core/EventBus";
import { EventNames } from "../../core/events/EventNames";
import GameBoardController from "./GameBoardController";
import TileView from "../views/TileView";
import type { Board } from "../../core/board/Board";
import { runFallAnimation } from "../utils/FallAnimator";
import { computeTilePosition } from "../utils/PositionUtils";
import { TileKind } from "../../core/board/Tile";
import { shock } from "../../config/ShockwaveConfig";

@ccclass()
export default class MoveFlowController extends cc.Component {
  /** Parent node for new tile views */
  @property(cc.Node)
  tilesLayer: cc.Node = null;

  /** Cached matrix of tile view components. Filled on load. */
  private tileViews!: TileView[][];
  /** Board model for reading final tile positions */
  private board!: Board;
  /** Reference to board controller so we can update its matrix */
  private boardCtrl!: GameBoardController;
  /** Coordinates scheduled for removal in current move */
  private pendingRemoval: Set<string> = new Set();

  onLoad(): void {
    // Cache references to TileView matrix generated by GameBoardController
    this.boardCtrl = this.node.getComponent(GameBoardController)!;
    this.board = this.boardCtrl.getBoard();
    this.tileViews = this.boardCtrl.tileViews;

    // Listen for core events signalling board updates
    bus.on(EventNames.RemoveStarted, this.onRemove, this);
    bus.on(EventNames.FallDone, this.onFall, this);
    bus.on(EventNames.FillDone, this.onFill, this);
    bus.on(EventNames.SuperTileCreated, this.onSuperTileCreated, this);
    bus.on(EventNames.SuperTileActivated, this.onSuperTileActivated, this);
  }

  onDestroy(): void {
    bus.off(EventNames.RemoveStarted, this.onRemove, this);
    bus.off(EventNames.FallDone, this.onFall, this);
    bus.off(EventNames.FillDone, this.onFill, this);
    bus.off(EventNames.SuperTileCreated, this.onSuperTileCreated, this);
    bus.off(EventNames.SuperTileActivated, this.onSuperTileActivated, this);
  }

  /**
   * Plays scale + fade animation on removed tile views.
   * @param positions coordinates of tiles removed by the core
   */
  private onRemove(positions: cc.Vec2[]): void {
    this.pendingRemoval = new Set(positions.map((p) => `${p.x},${p.y}`));
    // Refresh local reference in case another controller replaced it
    this.tileViews = this.boardCtrl.tileViews;
    for (let i = 0; i < positions.length; i++) {
      const p = positions[i];
      const view = this.tileViews[p.y]?.[p.x];
      if (!view) continue;
      view.node.runAction(
        cc.sequence(
          cc.spawn(cc.scaleTo(0.15, 0), cc.fadeOut(0.15)),
          cc.callFunc(() => view.node.destroy()),
        ),
      );
      this.tileViews[p.y][p.x] = undefined as unknown as TileView;
      this.boardCtrl.tileViews[p.y][p.x] = undefined as unknown as TileView;
    }
  }

  /**
   * Animates tiles falling after removal.
   * @param dirtyCols column indices reported by the core's FallCommand
   *                  that contained holes and were shifted down.
   *                  Each tile view in these columns moves to its new Y.
   */
  private onFall(): void {
    // Build mapping from tile model instances to their views
    const map = new Map<unknown, TileView>();
    for (let rowIndex = 0; rowIndex < this.tileViews.length; rowIndex++) {
      const row = this.tileViews[rowIndex];
      for (let colIndex = 0; colIndex < row.length; colIndex++) {
        const v = row[colIndex];
        if (!v) continue;
        map.set(v.tile, v);
      }
    }

    // Reconstruct matrix according to board state and move views
    const updated: (TileView | undefined)[][] = [];
    for (let r = 0; r < this.board.rows; r++) {
      updated[r] = new Array(this.board.cols);
    }

    // Получаем все позиции и тайлы из board
    const positions: cc.Vec2[] = [];
    const tiles: unknown[] = [];

    this.board.forEach((p, t) => {
      positions.push(p);
      tiles.push(t);
    });

    // Обрабатываем каждую позицию
    for (let i = 0; i < positions.length; i++) {
      const p = positions[i];
      const t = tiles[i];
      const view = map.get(t);

      if (!view) {
        continue;
      }

      const target = computeTilePosition(p.x, p.y, this.board);
      const dist = Math.floor(Math.abs(view.node.y - target.y));

      if (dist > 0) {
        runFallAnimation(view.node, target);
      }

      view.node.zIndex = this.board.rows - p.y - 1;
      view.boardPos = cc.v2(p.x, p.y);
      updated[p.y][p.x] = view;
    }

    this.tileViews = updated as TileView[][];
    this.boardCtrl.tileViews = this.tileViews;
  }

  /**
   * Updates local references after new tiles were spawned.
   */
  private onFill(): void {
    this.tileViews = this.boardCtrl.tileViews;
  }

  /**
   * Spawns a view for a newly created super tile.
   */
  private onSuperTileCreated(pos: cc.Vec2): void {
    const view = this.boardCtrl.spawn(pos);
    view.apply(this.board.tileAt(pos)!);
    this.tileViews = this.boardCtrl.tileViews;
  }

  /** Handles shockwave animations for activated super tiles. */
  private onSuperTileActivated(kind: TileKind, pos: cc.Vec2): void {
    switch (kind) {
      case TileKind.SuperBomb:
        this.applyBombShockwave(pos);
        break;
      case TileKind.SuperRow:
        this.applyLineShockwave(pos, true);
        break;
      case TileKind.SuperCol:
        this.applyLineShockwave(pos, false);
        break;
      default:
        break;
    }
  }

  /** Pushes surrounding tiles outwards when a SuperBomb explodes. */
  private applyBombShockwave(center: cc.Vec2): void {
    const centerPos = computeTilePosition(center.x, center.y, this.board);

    for (let y = center.y - 2; y <= center.y + 2; y++) {
      for (let x = center.x - 2; x <= center.x + 2; x++) {
        const dist = Math.max(Math.abs(x - center.x), Math.abs(y - center.y));
        if (dist < 1 || dist > 2) continue;
        const key = `${x},${y}`;
        if (this.pendingRemoval.has(key)) continue;

        const view = this.tileViews[y]?.[x];
        if (!view || !view.isInteractive()) continue;

        const node = view.node;
        const dx = node.x - centerPos.x;
        const dy = node.y - centerPos.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const offset = cc.v2(
          (dx / len) * shock.bombOffset,
          (dy / len) * shock.bombOffset,
        ); // 12px is enough to notice without overlap
        // Use relative movement so we don't rely on absolute coordinates.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (cc.tween(node) as any)
          .by(shock.bombDurationOut, { position: offset })
          .by(
            shock.bombDurationBack,
            { position: cc.v2(-offset.x, -offset.y) },
            { easing: "quadOut" },
          )
          .call(() => node.setPosition(Math.round(node.x), Math.round(node.y)))
          .start();
      }
    }
  }

  /**
   * Applies a perpendicular nudge to tiles adjacent to a rocket trail.
   * @param isRow true for horizontal rockets, false for vertical
   */
  private applyLineShockwave(center: cc.Vec2, isRow: boolean): void {
    const max = isRow ? this.board.cols : this.board.rows;
    for (let i = 0; i < max; i++) {
      const dx = isRow ? Math.abs(i - center.x) : 0;
      const dy = isRow ? 0 : Math.abs(i - center.y);
      const delay = (dx + dy) * shock.lineDuration; // rocket crosses one tile per lineDuration

      const targets: cc.Vec2[] = [];
      if (isRow) {
        targets.push(cc.v2(i, center.y - 1), cc.v2(i, center.y + 1));
      } else {
        targets.push(cc.v2(center.x - 1, i), cc.v2(center.x + 1, i));
      }

      for (const t of targets) {
        const key = `${t.x},${t.y}`;
        if (!this.board.inBounds(t) || this.pendingRemoval.has(key)) continue;
        const view = this.tileViews[t.y]?.[t.x];
        if (!view || !view.isInteractive()) continue;

        const node = view.node;
        // Direction points away from the rocket path. For a horizontal rocket
        // tiles above should move further up and tiles below further down.
        // Same idea for vertical rockets: tiles left of the path move further
        // left, tiles on the right move further right.
        const sign = isRow
          ? Math.sign(t.y - center.y)
          : Math.sign(t.x - center.x);
        const dir = isRow
          ? cc.v2(0, -sign * shock.lineOffset) // 8px sideways nudge
          : cc.v2(sign * shock.lineOffset, 0);
        // Relative tween keeps original coordinate intact after return.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (cc.tween(node) as any)
          .delay(delay)
          .by(shock.lineDuration, { position: dir })
          .by(
            shock.lineDuration,
            { position: cc.v2(-dir.x, -dir.y) },
            { easing: "quadOut" },
          )
          .call(() => node.setPosition(Math.round(node.x), Math.round(node.y)))
          .start();
      }
    }
  }

  /**
   * Updates internal references after the board was reset.
   */
  public reset(board: Board, tileViews: TileView[][]): void {
    this.board = board;
    this.tileViews = tileViews;
    this.boardCtrl = this.node.getComponent(GameBoardController)!;
  }
}
