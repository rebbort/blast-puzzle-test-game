const { ccclass, property } = cc._decorator;

import { EventBus as bus } from "../../core/EventBus";
import { EventNames } from "../../core/events/EventNames";
import GameBoardController from "./GameBoardController";
import TileView from "../views/TileView";
import { loadBoardConfig } from "../../config/ConfigLoader";

@ccclass()
export default class MoveFlowController extends cc.Component {
  /** Parent node for new tile views */
  @property(cc.Node)
  tilesLayer!: cc.Node;

  /** Cached matrix of tile view components. Filled on load. */
  private tileViews!: TileView[][];

  onLoad(): void {
    // Cache references to TileView matrix generated by GameBoardController
    const board = this.node.getComponent(GameBoardController)!;
    this.tileViews = board.tileViews;

    // Listen for core events signalling board updates
    bus.on(EventNames.TilesRemoved, this.onRemove, this);
    bus.on(EventNames.FallStarted, this.onFall, this);
    bus.on(EventNames.FillStarted, this.onFill, this);
  }

  /**
   * Plays scale + fade animation on removed tile views.
   * @param positions coordinates of tiles removed by the core
   */
  private onRemove(positions: cc.Vec2[]): void {
    positions.forEach((p) => {
      const view = this.tileViews[p.y][p.x];
      view.node.runAction(cc.spawn(cc.scaleTo(0.15, 0), cc.fadeOut(0.15)));
    });
  }

  /**
   * Animates tiles falling after removal.
   * @param dirtyCols column indices reported by the core's FallCommand
   *                  that contained holes and were shifted down.
   *                  Each tile view in these columns moves to its new Y.
   */
  private onFall(dirtyCols: number[]): void {
    dirtyCols.forEach((col) => {
      // For every row in the column compute new Y position
      this.tileViews.forEach((rowViews, r) => {
        const view = rowViews[col];
        const targetY = this.computePos(col, r).y;
        const dist = Math.abs(view.node.y - targetY);
        // Duration is proportional to traveled distance (approx 1400px/sec)
        const dur = dist / 1400;
        view.node.runAction(cc.moveTo(dur, view.node.x, targetY));
      });
    });
  }

  /**
   * Spawns new tiles for empty slots and drops them in.
   * @param emptySlots map returned by FillCommand where keys are column
   *                   numbers and values are arrays of board coordinates.
   */
  private onFill(emptySlots: Record<number, cc.Vec2[]>): void {
    Object.entries(emptySlots).forEach(([colStr, slots]) => {
      const col = parseInt(colStr, 10);
      slots.forEach((p) => {
        // Instantiate via GameBoardController.spawn to reuse prefabs
        const board = this.node.getComponent(GameBoardController)!;
        const view = board.spawn(p);
        // Place above the board then drop down
        const startPos = this.computePos(col, -1);
        view.node.setPosition(startPos.x, startPos.y);
        view.node.parent = this.tilesLayer;
        const target = this.computePos(p.x, p.y);
        const dist = Math.abs(startPos.y - target.y);
        const dur = dist / 1400;
        view.node.runAction(cc.moveTo(dur, target));
      });
    });
  }

  /**
   * Compute tile position exactly like in GameBoardController.
   */
  private computePos(col: number, row: number): cc.Vec2 {
    const cfg = loadBoardConfig();
    const x = (col - this.tileViews[0].length / 2) * cfg.tileWidth;
    const y =
      (this.tileViews.length / 2 - row) * cfg.tileHeight -
      GameBoardController.VERTICAL_OFFSET;
    return cc.v2(x, y);
  }
}
